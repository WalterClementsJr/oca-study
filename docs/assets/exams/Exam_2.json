[{"id":1,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What is the output if below program is run with the command line:\n\njava Test\n\npublic class Test {\n     public static void main(String[] args) {\n         System.out.println(args.length);\n     }\n}","type":"Single Choice","answer":"A","answers":{"A":"0","B":"NullPointerException","C":"ArrayIndexOutOfBoundsException","D":"1","E":"","F":"","G":"","H":""},"explanation":"We have not passed any command-line arguments, hence args refers to an array object of Size 0. \n\nargs.length prints 0. args is not null and hence no NullPointerException.\n\nAlso we are not accessing array element so no question of ArrayIndexOutOfBoundsException as well."},{"id":2,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n     public static void main(String[] args) {\n         List<Integer> list = new ArrayList<>();\n         list.add(100);\n         list.add(200);\n         list.add(100);\n         list.add(200);\n         list.remove(new Integer(100));\n \n         System.out.println(list);\n     }\n}","type":"Single Choice","answer":"D","answers":{"A":"Compilation error","B":"Exception is thrown at runtime","C":"[200]","D":"[200, 100, 200]","E":"[100, 200, 200]","F":"[200, 200]","G":"","H":""},"explanation":"List cannot accept primitives, it can accept objects only. So, when 100 and 200 are added to the list, then auto-boxing feature converts these to wrapper objects of Integer type.\n\nSo, 4 items gets added to the list: [100, 200, 100, 200]. list.remove(new Integer(100)); removes the first occurrence of 100 from the list, which means the 1st element of the list.\n\nAfter removal list contains: [200, 100, 200].\n\nNOTE: String class and all the wrapper classes override equals(Object) method, hence at the time of removal when another instance is passes[new Integer(100)], there is no issue in removing the matching item."},{"id":3,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nclass Message {\n    String msg = \"Happy New Year!\";\n    \n    public void print() {\n        System.out.println(msg);\n    }\n}\n \npublic class Test {\n    public static void change(Message m) { //Line n5\n        m.msg = \"Happy Holidays!\"; //Line n6\n    }\n    \n    public static void main(String[] args) {\n        Message obj = new Message(); //Line n1\n        obj.print(); //Line n2\n        change(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"Happy New Year!\nHappy Holidays!","B":"null\nHappy Holidays!","C":"Happy Holidays!\nHappy Holidays!","D":"null\nnull","E":"","F":"","G":"","H":""},"explanation":"Message class doesn't specify any constructor, hence Java compiler adds below default constructor:\n\nMessage() {super();}\n\n\n\nLine n1 creates an instance of Message class and initializes instance variable 'msg' to \"Happy New Year!\". Variable 'obj' refers to this instance.\n\nLine n2 prints Happy New Year! on to the console.\n\nLine n3 invokes change(Message) method, as it is a static method defined in TestMessage class, hence `change(obj);` is the correct syntax to invoke it. Line n3 compiles successfully. On invocation parameter variable 'm' copies the content of variable 'obj' (which stores the address to Message instance created at Line n1). 'm' also refers to the same instance referred by 'obj'.\n\n\n\nLine n6, assigns \"Happy Holidays!\" to the 'msg' variable of the instance referred by 'm'. As 'obj' and 'm' refer to the same instance, hence obj.msg also refers to \"Happy Holidays!\". change(Message) method finishes its execution and control goes back to main(String[]) method.\n\n\n\nLine n4 is executed next, print() method is invoked on the 'obj' reference and as obj.msg refers to \"Happy Holidays!\", so this statement prints Happy Holidays! on to the console.\n\n\n\nHence in the output, you get:\n\nHappy New Year!\n\nHappy Holidays!"},{"id":4,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code:\n\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n     public static void main(String[] args) {\n         List<StringBuilder> days = new ArrayList<>();\n         days.add(new StringBuilder(\"Sunday\"));\n         days.add(new StringBuilder(\"Monday\"));\n         days.add(new StringBuilder(\"Tuesday\"));\n \n         if(days.contains(new StringBuilder(\"Sunday\"))) {\n             days.add(new StringBuilder(\"Wednesday\"));\n         }\n \n         System.out.println(days.size());\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Compilation error","B":"4","C":"3","D":"Runtime exception","E":"","F":"","G":"","H":""},"explanation":"StringBuilder class doesn't override equals(Object) method and hence days.contains(new StringBuilder(\"Sunday\")) returns false.\n\nCode inside if-block is not executed and days.size() returns 3."},{"id":5,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n     public static void main(String[] args) {\n         List<String> list = new ArrayList<>();\n         list.add(0, \"Array\");\n         list.add(0, \"List\");\n \n         System.out.println(list);\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"[List]","B":"[List, Array]","C":"[Array, List]","D":"An exception is thrown at runtime","E":"[Array]","F":"","G":"","H":""},"explanation":"list.add(0, \"Array\"); means list --> [Array],   \n\nlist.add(0, \"List\"); means insert \"List\" to 0th index and shift \"Array\" to right. So after this operation, list --> [List, Array]. In the console, [List, Array] is printed."},{"id":6,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\n//Test.java\npackage com.udayan.oca;\n \nclass Point {\n    static int x;\n    int y, z;\n    \n    public String toString() {\n        return \"Point(\" + x + \", \" + y + \", \" + z + \")\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Point p1 = new Point();\n        p1.x = 17;\n        p1.y = 35;\n        p1.z = -1;\n        \n        Point p2 = new Point();\n        p2.x = 19;\n        p2.y = 40;\n        p2.z = 0;\n        \n        System.out.println(p1); //Line n1\n        System.out.println(p2); //Line n2\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"Point(19, 40, 0)\nPoint(19, 40, 0)","B":"Point(19, 35, -1)\nPoint(19, 40, 0)","C":"Point(17, 35, -1)\nPoint(17, 35, -1)","D":"Point(17, 35, -1)\nPoint(17, 40, 0)","E":"Point(19, 35, -1)\nPoint(19, 35, -1)","F":"Point(17, 35, -1)\nPoint(19, 40, 0)","G":"","H":""},"explanation":"Point class correctly overrides the toString() method. Even though variable x is static, but it can be easily accessed by instance method toString().\n\nVariables x, y and z are declared with default scope, so can be accessed in same package. There is no compilation error in the code.\n\nThere is only one copy of static variable for all the instances of the class. Variable x is shared by p1 and p2 both.\n\np1.x = 17; sets the value of static variable x to 17, p2.x = 19; modifies the value of static variable x to 19. As there is just one copy of x, hence p1.x = 19\n\n\n\nPlease note: p1.x and p2.x don't cause any compilation error but as this syntax creates confusion, so it is not a good practice to access the static variables or static methods using reference variable, instead class name should be used. Point.x is the preferred syntax.\n\n\n\nEach object has its own copy of instance variables, so just before executing Line n1, p1.y = 35 & p1.z = -1 AND p2.y = 40 & p2.z = 0\n\nOutput is:\n\nPoint(19, 35, -1)\n\nPoint(19, 40, 0)"},{"id":7,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\n//Test.java\npackage com.udayan.oca;\n \nclass Point {\n    static int x;\n    int y, z;\n    \n    public String toString() {\n        return \"Point(\" + x + \", \" + y + \", \" + z + \")\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Point p1 = new Point();\n        p1.x = 17;\n        p1.y = 35;\n        p1.z = -1;\n        \n        Point p2 = new Point();\n        p2.x = 19;\n        p2.y = 40;\n        p2.z = 0;\n        \n        System.out.println(p1); //Line n1\n        System.out.println(p2); //Line n2\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"MANGO\nBANANA\nANY FRUIT WILL DO","B":"MANGO","C":"ANY FRUIT WILL DO","D":"MANGO\nANY FRUIT WILL DO","E":"MANGO\nBANANA","F":"","G":"","H":""},"explanation":"\"mango\" is different from \"Mango\", so there is no matching case available.\n\ndefault block is executed and as it is the last block inside switch hence after printing \"ANY FRUIT WILL DO\" control goes out of switch block, main method ends and program terminates successfully."},{"id":8,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Which is not a valid statement based on given code?\n\nclass A{}\nclass B extends A{}","type":"Single Choice","answer":"B","answers":{"A":"B a = new B();","B":"B b = new A();","C":"A a = new A();","D":"A a = new B();","E":"","F":"","G":"","H":""},"explanation":"B b = new A(); -> child class reference cannot refer to parent class object. This will give compilation error.\n\nA a = new B(); -> parent class reference can refer to child class object. This is Polymorphism.\n\nB a = new B(); -> No issues at all.\n\nA a = new A(); -> No issues at all."},{"id":9,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider code of Test.java file:\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String [] args) {\n         int [] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n         String str = process(arr, 3, 8); //Line 5\n         System.out.println(str);\n     }\n \n     /*INSERT*/\n}\nLine 5 is giving compilation error as process method is not found. \n\nWhich of the following method definitions, if used to replace /*INSERT*/, will resolve the compilation error?","type":"Single Choice","answer":"C","answers":{"A":"private static String[] process(int [] arr, int start, int end) {\n      return null;\n }","B":"private static int process(int [] arr, int start, int end) {\n      return null;\n }","C":"private static String process(int [] arr, int start, int end) {\n      return null;\n }","D":"private static int[] process(int [] arr, int start, int end) {\n      return null;\n }","E":"","F":"","G":"","H":""},"explanation":"It is clear from Line 5 that, method name should be process, it should be static method, it should accept 3 parameters (int[], int, int) and its return type must be String."},{"id":10,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     private static void m1() throws Exception {\n         throw new Exception();\n     }\n \n     public static void main(String[] args) {\n         try {\n             m1();\n         } finally {\n             System.out.println(\"A\");\n         }\n     }\n}","type":"Single Choice","answer":"D","answers":{"A":"A is printed to the console, stack trace is printed and then program ends normally.","B":"A is printed to the console and program ends normally.","C":"A is printed to the console, stack trace is printed and then program ends abruptly.","D":"Compilation error.","E":"","F":"","G":"","H":""},"explanation":"Method m1() throws Exception (checked) and it declares to throw it, so no issues with method m1().\n\nBut main() method neither provides catch handler nor throws clause and hence main method gives Compilation error.\n\nHandle or Declare rule should be followed for checked exception if you are not re-throwing it."},{"id":11,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public String name;\n     public void Test() {\n         name = \"James\";\n     }\n \n     public static void main(String [] args) {\n         Test obj = new Test();\n         System.out.println(obj.name);\n     }\n}","type":"Single Choice","answer":"B","answers":{"A":"James","B":"null","C":"Compilation error","D":"None of the above","E":"","F":"","G":"","H":""},"explanation":"public void Test() is method and not constructor, as return type is void.\n\nmethod can have same name as the class name, so no issues with Test() method declaration.\n\n\n\nAs there are no constructors available for this class, java compiler adds following constructor.\n\npublic Test() {}\n\n\n\nTest obj = new Test(); invokes the default constructor but it doesn't change the value of name property (by default null is assigned to name property)\n\n\n\nSystem.out.println(obj.name); prints null."},{"id":12,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String [] args) {\n         int a = 2;\n         boolean res = false;\n         res = a++ == 2 || --a == 2 && --a == 2;\n         System.out.println(a);\n     }\n}","type":"Single Choice","answer":"C","answers":{"A":"2","B":"Compilation error","C":"3","D":"1","E":"","F":"","G":"","H":""},"explanation":"a++ == 2 || --a == 2 && --a == 2; [Given expression]. \n\n(a++) == 2 || --a == 2 && --a == 2; [Postfix has got higher precedence than other operators]. \n\n(a++) == 2 || (--a) == 2 && (--a) == 2; [After postfix, precedence is given to prefix].   \n\n((a++) == 2) || ((--a) == 2) && ((--a) == 2); [== has higher precedence over && and ||]. \n\n((a++) == 2) || (((--a) == 2) && ((--a) == 2)); [&& has higher precedence over ||]. \n\nLet's start solving it:\n\n((a++) == 2) || (((--a) == 2) && ((--a) == 2)); [a=2, res=false]. \n\n(2 == 2) || (((--a) == 2) && ((--a) == 2)); [a=3, res=false]. \n\ntrue || (((--a) == 2) && ((--a) == 2)); [a=3, res=false].  || is a short-circuit operator, hence no need to evaluate expression on the right. \n\nres is true and a is 3."},{"id":13,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n \npublic class Test {\n     public static void main(String[] args) {\n         List<String> dryFruits = new ArrayList<>();\n         dryFruits.add(\"Walnut\");\n         dryFruits.add(\"Apricot\");\n         dryFruits.add(\"Almond\");\n         dryFruits.add(\"Date\");\n \n         ListIterator<String> iterator = dryFruits.listIterator();\n         while(iterator.hasNext()) {\n             if(iterator.next().startsWith(\"A\")) {\n                 iterator.remove();\n              }\n         }\n \n         System.out.println(dryFruits);\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error","B":"An exception is thrown at runtime","C":"[Walnut, Apricot, Almond, Date]","D":"[Walnut, Date]","E":"","F":"","G":"","H":""},"explanation":"If you want to remove the items from ArrayList, while using Iterator or ListIterator, then use Iterator.remove() or ListIterator.remove() method and NOT List.remove() method.\n\n\n\nIn this case ListIterator.remove() method is used. startsWith(\"A\") returns true for \"Apricot\" and \"Almond\" so these elements are removed from the list. In the output, [Walnut, Date] is displayed."},{"id":14,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Below is the code of Test.java file:\n\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n     public static void main(String [] args) {\n         List<Integer> list = new ArrayList<Integer>();\n \n         list.add(27);\n         list.add(27);\n \n         list.add(new Integer(27));\n         list.add(new Integer(27));\n \n         System.out.println(list.get(0) == list.get(1));\n         System.out.println(list.get(2) == list.get(3));\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"true\ntrue","B":"true\nfalse","C":"false\ntrue","D":"false\nfalse","E":"","F":"","G":"","H":""},"explanation":"This is bit tricky. Just remember this:\n\nTwo instances of following wrapper objects, created through auto-boxing will always be same, if their primitive values are same:\n\nBoolean,\n\nByte,\n\nCharacter from \\u0000 to \\u007f (7f equals to 127),\n\nShort and Integer from -128 to 127. \n\n\n\nFor 1st statement, list.add(27); => Auto-boxing creates an integer object for 27. \n\nFor 2nd statement, list.add(27); => Java compiler finds that there is already an Integer object in the memory with value 27, so it uses the same object.\n\n\n\nThat is why System.out.println(list.get(0) == list.get(1)); returns true. \n\n\n\nnew Integer(27) creates a new Object in the memory, so System.out.println(list.get(2) == list.get(3)); returns false."},{"id":15,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.function.Predicate;\n \nclass Employee {\n     private String name;\n     private int age;\n     private double salary;\n \n     public Employee(String name, int age, double salary) {\n         this.name = name;\n         this.age = age;\n         this.salary = salary;\n     }\n \n    public String getName() {\n         return name;\n     }\n \n    public int getAge() {\n         return age;\n     }\n \n    public double getSalary() {\n         return salary;\n     }\n \n     public String toString() {\n         return name;\n     }\n}\n \npublic class Test {\n     public static void main(String [] args) {\n         List<Employee> list = new ArrayList<>();\n         list.add(new Employee(\"James\", 25, 15000));\n         list.add(new Employee(\"Lucy\", 23, 12000));\n         list.add(new Employee(\"Bill\", 27, 10000));\n         list.add(new Employee(\"Jack\", 19, 5000));\n         list.add(new Employee(\"Liya\", 20, 8000));\n \n         process(list, e -> e.getAge() > 20);\n     }\n \n     private static void process(List<Employee> list, Predicate<Employee> predicate) {\n         Iterator<Employee> iterator = list.iterator();\n         while(iterator.hasNext()) {\n             Employee e = iterator.next();\n             if(predicate.test(e))\n                 System.out.print(e + \" \");\n         }\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error","B":"James Lucy Bill","C":"Jack Liya","D":"James Lucy Bill Jack Liya","E":"","F":"","G":"","H":""},"explanation":"process(List, Predicate) method prints all the records passing the Predicate's test and test is to process the records having age greater than 20.\n\nThere are 3 records with age > 20 and these are printed in the insertion order.\n\n\n\nNOTE: toString() method just returns the name."},{"id":16,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         System.out.println(\"Output is: \" + (10 != 5));\n     }\n}","type":"Single Choice","answer":"C","answers":{"A":"Compilation error","B":"Output is: (10 != 5)","C":"Output is: true","D":"Output is: false","E":"","F":"","G":"","H":""},"explanation":"\"Output is: \" + (10 != 5) [Nothing to evaluate at left side, so let's evaluate the right side of +, 10 != 5 is true.] \n= \"Output is: \" + true [+ operator behaves as concatenation operator] \n= \"Output is: true\""},{"id":17,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider the code snippet:\n\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n     List list1 = new ArrayList<String>(); //Line 5\n     List<String> list2 = new ArrayList(); //Line 6\n     List<> list3 = new ArrayList<String>(); //Line 7\n     List<String> list4 = new ArrayList<String>(); //Line 8\n     List<String> list5 = new ArrayList<>(); //Line 9\n}\n\n\nWhich of the following statements compile without any warning?\n\nSelect 2 options.","type":"Multiple Choice","answer":"A,E","answers":{"A":"Line 8","B":"Line 6","C":"Line 5","D":"Line 7","E":"Line 9","F":"","G":"","H":""},"explanation":"Line 8's syntax was added in JDK 5 and it compiles without any warnings. \n\n\n\nLine 9's syntax was added in JDK 7, in which type parameter can be ignored from right side of the statement, it is inferred from left side, so Line 9 also compiles without any warning. \n\n\n\nType parameter can't be removed from declaration part, hence Line 7 gives compilation error. \n\n\n\nBoth Line 5 and Line 6 are mixing Generic type with Raw type and hence warning is given by the compiler."},{"id":18,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nclass Vehicle {\n     public int getRegistrationNumber() {\n         return 1;\n     }\n}\n \nclass Car {\n     public int getRegistrationNumber() {\n         return 2;\n     }\n}\n \npublic class Test {\n     public static void main(String[] args) {\n         Vehicle obj = new Car();\n         System.out.println(obj.getRegistrationNumber());\n     }\n}","type":"Single Choice","answer":"D","answers":{"A":"1","B":"An exception is thrown at runtime","C":"2","D":"Compilation error","E":"","F":"","G":"","H":""},"explanation":"class Car doesn't extend from Vehicle class, this means Vehicle is not super type of Car.\nHence, Vehicle obj = new Car(); causes compilation error."},{"id":19,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n     public static void main(String[] args) {\n         List<String> list = new ArrayList<>();\n         list.add(\"ONE\");\n         list.add(\"TWO\");\n         list.add(\"THREE\");\n         list.add(\"THREE\");\n \n         if(list.remove(2)) {\n             list.remove(\"THREE\");\n         }\n \n         System.out.println(list);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error","B":"[ONE, TWO, THREE, THREE]","C":"[ONE, TWO]","D":"[ONE, TWO, THREE]","E":"An exception is thrown at runtime","F":"","G":"","H":""},"explanation":"list.remove(Object) method returns boolean result but list.remove(int index) returns the removed item from the list, which in this case is of String type and not Boolean type and hence if(list.remove(2)) causes compilation error."},{"id":20,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(null);\n        list.add(null);\n        list.add(null);\n        System.out.println(list.remove(0) + \":\" + list.remove(null));\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"NullPointerException is thrown at runtime","B":"true:false","C":"null:true","D":"null:null","E":"true:true","F":"","G":"","H":""},"explanation":"It is possible to add null to ArrayList instant.\n\nInitially list has 3 elements: [null, null, null].\n\nremove(int) returns the deleted member of the list. In this case `list.remove(0);` returns null as null was deleted from the 0th index. So, list is left with 2 elements: [null, null].\n\nremove(Object) returns true if deletion was successful otherwise false. In this case `list.remove(null)` removes first null from the list and returns true and list is left with just one element: [null].\n\nHence, the output is: 'null:true'."},{"id":21,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Following statement in a Java program compiles successfully:\nstudent.report(course); \nWhat can you say for sure?","type":"Single Choice","answer":"C","answers":{"A":"student is the class name","B":"course must be of String type","C":"report is the method name","D":"student is the reference variable name","E":"","F":"","G":"","H":""},"explanation":"It is good practice to have first character of class name in upper case, but it is not mandatory.\n\nstudent can be either class name or reference variable name. \n\n\n\nSyntax to invoke static method is: Class_Name.method_name(<arguments>); OR reference_variable_name.method_name(<arguments>);\n\nSyntax to invoke instance method is: reference_variable_name.method_name(<arguments>);\n\nIf student represents class_name or refernce_variable_name, then report might be the static method of the class.\n\nIf student represents reference_variable_name, then report is the instance method of the class.\n\nIn both the cases, report must be the method name.\n\n\n\nType of argument cannot be found out by looking at above syntax."},{"id":22,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \nclass Student {\n     private String name;\n     private int age;\n \n     Student(String name, int age) {\n         this.name = name;\n         this.age = age;\n     }\n \n     public String toString() {\n         return \"Student[\" + name + \", \" + age + \"]\";\n     }\n \n     public boolean equals(Object obj) {\n         if(obj instanceof Student) {\n             Student stud = (Student)obj;\n             if(this.name.equals(stud.name) && this.age == stud.age) {\n                 return true;\n             }\n         }\n         return false;\n     }\n}\n \npublic class Test {\n     public static void main(String[] args) {\n         List<Student> students = new ArrayList<>();\n         students.add(new Student(\"James\", 25));\n         students.add(new Student(\"James\", 27));\n         students.add(new Student(\"James\", 25));\n         students.add(new Student(\"James\", 25));\n \n         students.remove(new Student(\"James\", 25));\n \n         for(Student stud : students) {\n             System.out.println(stud);\n         }\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Student[James, 25]\nStudent[James, 27]\nStudent[James, 25]\nStudent[James, 25]","B":"Student[James, 27]","C":"Student[James, 25]\nStudent[James, 27]\nStudent[James, 25]","D":"Student[James, 27]\nStudent[James, 25]\nStudent[James, 25]","E":"","F":"","G":"","H":""},"explanation":"Before you answer this, you must know that there are 5 different Student object created in the memory (4 at the time of adding to the list and 1 at the time of removing from the list).\n\nThis means these 5 Student objects will be stored at different memory addresses.\n\n\n\nremove(Object) method removes the first occurrence of matching object and equals(Object) method decides whether 2 objects are equal or not. equals(Object) method has been overridden by the Student class and equates the object based on their name and age.\n\n\n\n3 matching Student objects are found in the list and 1st list element is removed from the list. Remaining 3 list elements are printed in the insertion order."},{"id":23,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing the Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         int grade = 75;\n         if(grade > 60)\n             System.out.println(\"Congratulations\");\n             System.out.println(\"You passed\");\n         else\n             System.out.println(\"You failed\");\n     }\n}","type":"Single Choice","answer":"C","answers":{"A":"Congratulations\nYou passed","B":"Congratulations","C":"Compilation error","D":"You failed","E":"","F":"","G":"","H":""},"explanation":"As there is no brackets after if, hence only one statement is part of if block and other is outside.\nAbove code can be written as below:\n1 if(grade > 60) { \n2     System.out.println(\"Congratulations\"); \n3 } \n4 System.out.println(\"You passed\"); \n5 else \n6     System.out.println(\"You failed\"); \n   \nThere should not be anything between if-else block but in this case, System.out.println(\"You passed\"); is between if-else and thus Compilation error."},{"id":24,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code:\n\n//Test.java\npublic class Test {\n     private static boolean flag = !true;\n \n     public static void main(String [] args) {\n         System.out.println(!flag ? args[0] : args[1]);\n     }\n}\nWhat will be the result of compiling and executing Test class using below commands?\n\njavac Test.java\njava Test AM PM","type":"Single Choice","answer":"B","answers":{"A":"ExceptionInInitializerError is thrown while loading the Test class","B":"AM","C":"PM","D":"Compilation error","E":"","F":"","G":"","H":""},"explanation":"There is no compilation error. When Test class is loaded by JVM to invoked main(String []) method, static variable declaration and initialization statement is executed and false is assigned to flag as !true is false. \n\n\n\nAs java Test AM PM command is used, so args[0] --> \"AM\" and args[1] --> \"PM\". \n\n\n\nIn ternary operator, boolean expression is evaluated first, !flag evaluates to true and therefore agrs[0] is returned.\n\n\n\nAM is printed on to the console."},{"id":25,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code:\n\n//Guest.java\nclass Message {\n    public static void main(String [] args) {\n        System.out.println(\"Welcome \" + args[0] + \"!\");\n    }\n}\n \npublic class Guest {\n    public static void main(String [] args) {\n        Message.main(args);\n    }\n}\nAnd the commands:\n\njavac Guest.java\n\njava Guest James Gosling\n\n\n\nWhat is the result?","type":"Single Choice","answer":"B","answers":{"A":"Welcome Gosling!","B":"Welcome James!","C":"Some other error as main method can't be invoked manually","D":"ArrayIndexOutOfBoundsException is thrown at runtime","E":"","F":"","G":"","H":""},"explanation":"Both the classes contain special main method. No compilation error with the code: file is correctly names as Guest.java (name of public class).\n\njava Guest James Gosling passes new String [] {\"James\", \"Gosling\"} to args of Guest.main method. Apart from being special main method, Message.main is static method so Guest.main method invokes Message.main method with the same argument: new String [] {\"James\", \"Gosling\"}.\n\nargs[0] is \"James\" hence \"Welcome James!\" gets printed on to the console."},{"id":26,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         int x = 5;\n         while (x < 10) \n             System.out.println(x);\n             x++;\n     }\n}","type":"Single Choice","answer":"D","answers":{"A":"5\n6\n7\n8\n9","B":"Compilation error","C":"Produces no output","D":"It will go in an infinite loop","E":"","F":"","G":"","H":""},"explanation":"while loop doesn't have curly bracket over here, so only System.out.println(x) belongs to while loop. \nAbove syntax can be written as follows: \n1 int x = 5;  \n2 while (x < 10) {  \n3     System.out.println(x);  \n4 }  \n5 x++;  \nAs x++; is outside loop, hence value of x is always 5 within loop, 5 < 10 is true for all the iterations and hence infinite loop."},{"id":27,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Which of the following are Java Exception classes?\nSelect 3 options.","type":"Multiple Choice","answer":"C,D,E","answers":{"A":"NullException","B":"ArrayIndexException","C":"IllegalArgumentException","D":"ClassCastException","E":"NumberFormatException","F":"","G":"","H":""},"explanation":"ClassCastException, NumberFormatException and IllegalArgumentException are Runtime exceptions.\n\nThere are no exception classes in java with the names: NullException and ArrayIndexException."},{"id":28,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         String [] arr = new String[7];\n         System.out.println(arr);\n     }\n}","type":"Single Choice","answer":"A","answers":{"A":"Some String containing @ symbol","B":"null","C":"NullPointerException","D":"Compilation Error","E":"","F":"","G":"","H":""},"explanation":"Variable arr refers to an array object of String of 7 elements.\n\nVariable arr contains the memory address of String array object. \n\narr is of reference type, hence it prints some String Containing @ symbol."},{"id":29,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nclass Parent {\n     public String toString() {\n         return \"Inner \";\n     }\n}\n \nclass Child extends Parent {\n     public String toString() {\n         return super.toString().concat(\"Peace!\");\n     }\n}\n \npublic class Test {\n     public static void main(String[] args) {\n         System.out.println(new Child());\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Inner","B":"Peace!","C":"Compilation error","D":"Inner Peace!","E":"","F":"","G":"","H":""},"explanation":"System.out.println(new Child()); invokes the toString() method on Child's instance.\n\n\n\nParent class's method can be invoked by super keyword. super.toString() method returns \"Inner \" and \"Inner \".concat(\"Peace!\") returns \"Inner Peace!\"."},{"id":30,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nclass Parent {\n     public String toString() {\n         return \"Inner \";\n     }\n}\n \nclass Child extends Parent {\n     public String toString() {\n         return super.toString().concat(\"Peace!\");\n     }\n}\n \npublic class Test {\n     public static void main(String[] args) {\n         System.out.println(new Child());\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"2018-1-01","B":"2018-1-1","C":"2018-01-01","D":"An exception is thrown at runtime","E":"","F":"","G":"","H":""},"explanation":"LocalDate.parse(CharSequence) method accepts String in \"9999-99-99\" format only. Single digit month and day value are padded with 0 to convert it to 2 digits. \n\nTo represent 9th June 2018, format String must be \"2018-06-09\".\n\nIf correct format string is not passed then an instance of java.time.format.DateTimeParseException is thrown."},{"id":31,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n     public static void main(String [] args) {\n         LocalDate d1 = LocalDate.parse(\"1999-09-09\");\n         LocalDate d2 = LocalDate.parse(\"1999-09-09\");\n         LocalDate d3 = LocalDate.of(1999, 9, 9);\n         LocalDate d4 = LocalDate.of(1999, 9, 9);\n         System.out.println((d1 == d2) + \":\" + (d2 == d3) + \":\" + (d3 == d4));\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"true:true:true","B":"false:false:true","C":"true:false:true","D":"false:false:false","E":"","F":"","G":"","H":""},"explanation":"\"parse\" and \"of\" methods create new instances, so in this case you get 4 different instance of LocalDate stored at 4 different memory addresses."},{"id":32,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Which of the following array declarations and initializations is NOT legal?","type":"Single Choice","answer":"A","answers":{"A":"int [] arr3 = new int[3]{10, 20, 30};","B":"char [] arr1 [] = new char[5][];","C":"byte [] val = new byte[10];","D":"int [] arr2 = {1, 2, 3, 4, 5};","E":"","F":"","G":"","H":""},"explanation":"You can't specify size at the time of initializing with data, hence new int[3]{10, 20, 30}; gives compilation error."},{"id":33,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing the following program?\n\npackage com.udayan.oca;\n \nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n \nabstract class Super {\n     public abstract void m1() throws IOException;\n}\n \nclass Sub extends Super {\n     @Override\n     public void m1() throws IOException {\n         throw new FileNotFoundException();\n     }\n}\n \npublic class Test {\n     public static void main(String[] args) {\n         Super s = new Sub();\n         try {\n             s.m1();\n         } catch (IOException e) {\n             System.out.print(\"A\");\n         } catch(FileNotFoundException e) {\n             System.out.print(\"B\");\n         } finally {\n             System.out.print(\"C\");\n         }\n     }\n}","type":"Single Choice","answer":"C","answers":{"A":"BC","B":"class Sub gives compilation error","C":"class Test gives compilation error","D":"AC","E":"","F":"","G":"","H":""},"explanation":"FileNotFoundException extends IOException and hence catch block of FileNotFoundException should appear before the catch block of IOException.\n\nTherefore, class Test causes compilation error."},{"id":34,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         String str1 = \" \";\n         boolean b1 = str1.isEmpty();\n         System.out.println(b1);\n         str1.trim();\n         b1 = str1.isEmpty();\n         System.out.println(b1);\n     }\n}","type":"Single Choice","answer":"B","answers":{"A":"true\nfalse","B":"false\nfalse","C":"false\ntrue","D":"true\ntrue","E":"","F":"","G":"","H":""},"explanation":"str1 refers to single space character and isEmpty() method of String returns true if no characters are there in the String. As str1 contains single space, hence b1 is false.\n\nfalse is first printed on to the console.\n\n\n\nstr1.trim(); => creates an empty string \"\" but str1 still refers to single space string \" \".\n\nb1 = str1.isEmpty(); assigns false to b1 and last System.out.println statement prints false on to the console. So output is:\n\nfalse\n\nfalse"},{"id":35,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n     public static void main(String [] args) {\n         LocalDate newYear = LocalDate.of(2018, 1, 1);\n         LocalDate eventDate = LocalDate.of(2018, 1, 1);\n         boolean flag1 = newYear.isAfter(eventDate);\n         boolean flag2 = newYear.isBefore(eventDate);\n         System.out.println(flag1 + \":\" + flag2);\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"false:true","B":"true:false","C":"true:true","D":"false:false","E":"","F":"","G":"","H":""},"explanation":"isAfter and isBefore method can be interpreted as:\n\nDoes 1st Jan 2018 come after 1st Jan 2018? No, false.  Does 1st Jan 2018 come before 1st Jan 2018? No, false."},{"id":36,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider the code of Test.java file:\n\npackage com.udayan.oca;\n \nclass Student {\n     String name;\n     int age;\n \n     Student() {\n         Student(\"James\", 25);\n     }\n \n     Student(String name, int age) {\n         this.name = name;\n         this.age = age;\n     }\n}\n \npublic class Test {\n     public static void main(String[] args) {\n         Student s = new Student();\n         System.out.println(s.name + \":\" + s.age);\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"null:0","B":"James:25","C":"An exception is thrown at runtime","D":"Compilation error","E":"","F":"","G":"","H":""},"explanation":"A constructor can call another constructor by using this(...) and not the constructor name.\n\nHence Student(\"James\", 25); causes compilation error."},{"id":37,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Which of these keywords can be used to prevent inheritance of a class?","type":"Single Choice","answer":"B","answers":{"A":"class","B":"final","C":"constant","D":"super","E":"","F":"","G":"","H":""},"explanation":"Class declared as final can't be inherited. Examples are: String, Integer, System etc."},{"id":38,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Month;\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n     public static void main(String[] args) {\n         List<LocalDate> dates = new ArrayList<>();\n         dates.add(LocalDate.parse(\"2018-7-11\"));\n         dates.add(LocalDate.parse(\"1919-10-25\"));\n         dates.add(LocalDate.of(2020, 4, 8));\n         dates.add(LocalDate.of(1980, Month.DECEMBER, 31));\n \n         dates.removeIf(x -> x.getYear() < 2000);\n \n         System.out.println(dates);\n     }\n}","type":"Single Choice","answer":"D","answers":{"A":"[2018-07-11, 2020-04-08]","B":"[1919-02-25, 1980-12-31]","C":"[2018-07-11, 1919-02-25, 2020-04-08, 1980-12-31]","D":"Runtime exception","E":"","F":"","G":"","H":""},"explanation":"LocalDate.parse(CharSequence text) method accepts String in \"9999-99-99\" format only, in which month and day part in the passed object referred by text should be of 2 digits, such as to represent MARCH, use 03 and not 3 & to represent 4th day of the month, use 04 and not 4.\n\nSingle digit month and day value are not automatically padded with 0 to convert it to 2 digits. \n\nTo represent 9th June 2018, format String must be \"2018-06-09\".\n\nIf you pass \"2018-6-9\" or \"2018-06-9\" or \"2018-6-09\" (not in correct formats), then an instance of java.time.format.DateTimeParseException will be thrown. \n\nIn this question, LocalDate.parse(\"2018-7-11\") throws an exception at runtime as JULY is represented as 7, whereas it should be represented as 07."},{"id":39,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code:\n\n//Test.java\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\n \npublic class Test {\n     public static void main(String[] args) {\n         ArrayList<Integer> original = new ArrayList<>();\n         original.add(new Integer(10));\n \n         ArrayList<Integer> cloned = (ArrayList<Integer>) original.clone();\n         Integer i1 = cloned.get(0);\n         ++i1;\n \n         System.out.println(cloned);\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"[10]","B":"[11]","C":"Compilation error","D":"An exception is thrown at runtime","E":"","F":"","G":"","H":""},"explanation":"Let's see what is happening during execution:\n\nmain(String [] args) method goes on to the top of the STACK.\n\n1. ArrayList<Integer> original = new ArrayList<>(); => It creates an ArrayList object [suppose at memory location 15EE00] and variable 'original' refers to it.\n\n2. original.add(new Integer(10)); => It creates an Integer object [suppose at memory location 25AF06] and adds it as a first element of the ArrayList. This means element at 0th index of the ArrayList instance refers to Integer object at the memory location 25AF06.\n\n3. ArrayList<Integer> cloned = (ArrayList<Integer>) original.clone(); => original.clone() creates a new array list object, [suppose at memory location 45BA12] and then it will copy the contents of the ArrayList object stored at [15EE00]. So, cloned contains memory address of the same Integer object.\n\nIn this case, original != cloned, but original.get(0) == cloned.get(0). This means both the array lists are created at different memory location but refer to same Integer object. \n\n4. Integer i1 = cloned.get(0); => cloned.get(0) returns the Integer object stored at the memory location 25AF06 and variable 'i1' refers to it. \n\n5. ++i1; => As Integer object is immutable, hence ++i1; creates a new Integer object with value 11 and suppose this newly created Integer object is stored at memory location 38AB00. This means variable 'i1' stops referring to Integer object at the memory location 25AF06 and starts referring to Integer object at the memory location 38AB00.\n\nCloned list stays intact and still refers to Integer object at memory location 25AF06.\n\n6. System.out.println(cloned); => Prints [10] on to the console as cloned contains an element which refers to Integer object containing value 10."},{"id":40,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n \n     private static void add(double d1, double d2) {\n         System.out.println(\"double version: \" + (d1 + d2));\n     }\n \n     private static void add(Double d1, Double d2) {\n         System.out.println(\"Double version: \" + (d1 + d2));\n     }\n \n     public static void main(String[] args) {\n         add(10.0, new Integer(10));\n     }\n \n}","type":"Single Choice","answer":"C","answers":{"A":"An exception is thrown at runtime","B":"Compilation error","C":"double version: 20.0","D":"Double version: 20.0","E":"","F":"","G":"","H":""},"explanation":"int can be converted to double but Integer type can't be converted to Double type as Integer and Double are siblings (both extends from Number class) so can't be casted to each other.\n\n\n\nadd(10.0, new Integer(10)); => 1st parameter is tagged to double primitive type and 2nd parameter is converted to int, is tagged to double primitive type as well. So, add(double, double); method is invoked."},{"id":41,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of executing Test class using below command?\n\njava Test good morning everyone\n\n\n\nprivate class Test\n{ \n       public static void main(String args[])\n       { \n           System.out.println(args[1]);\n       }\n}","type":"Single Choice","answer":"C","answers":{"A":"morning","B":"everyone","C":"Compilation Error","D":"good","E":"","F":"","G":"","H":""},"explanation":"Top level class can have two access modifiers: public and default.\n\nOver here Test class has private modifier and hence compilation error."},{"id":42,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Choose the options that meets the following specification: \n\nCreate a well encapsulated class Clock with one instance variable model. \n\nThe value of model should be accessible and modifiable outside Clock.","type":"Single Choice","answer":"A","answers":{"A":"public class Clock {\n      private String model;\n      public String getModel() { return model; }\n      public void setModel(String val) { model = val; }\n }","B":"public class Clock {\n public String model;\n }","C":"public class Clock {\n public String model;\n  public String getModel() { return model; }  \n  public void setModel(String val) { model = val; }\n }","D":"public class Clock {\n public String model;\n private String getModel() { return model; }\n private void setModel(String val) { model = val; }\n }","E":"","F":"","G":"","H":""},"explanation":"Encapsulation is all about having private instance variable and providing public getter and setter methods."},{"id":43,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         String s1 = \"OcA\";\n         String s2 = \"oCa\";\n         System.out.println(s1.equals(s2));\n     }\n}","type":"Single Choice","answer":"D","answers":{"A":"None of the other options","B":"Compilation error","C":"TRUE","D":"FALSE","E":"","F":"","G":"","H":""},"explanation":"equals(String str) method of String class matches two String objects and it takes character's case into account while matching.\n\nAlphabet A in upper case and alphabet a in lower case are not equal according to this method.\n\nAs String objects referred by s1 and s2 have different cases, hence output is false."},{"id":44,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider codes below:\n\n//A.java\npackage com.udayan.oca;\n \npublic class A {\n     public int i1;\n     protected int i2;\n     int i3;\n     private int i4;\n}\n\n\n//TestA.java\npackage com.udayan.oca.test;\n \nimport com.udayan.oca.A; //Line 3\n \npublic class TestA {\n     public static void main(String[] args) {\n         A obj = new A(); //Line 7\n         System.out.println(obj.i1); //Line 8\n         System.out.println(obj.i2); //Line 9\n         System.out.println(obj.i3); //Line 10\n         System.out.println(obj.i4); //Line 11\n     }\n}\nWhich of the following 3 statements are true?","type":"Multiple Choice","answer":"A,E,F","answers":{"A":"Line 11 causes compilation error","B":"Line 8 causes compilation error","C":"Line 7 causes compilation error","D":"Line 3 causes compilation error","E":"Line 10 causes compilation error","F":"Line 9 causes compilation error","G":"","H":""},"explanation":"class A is declared public and defined in com.udayan.oca package, there is no problem in accessing class A outside com.udayan.oca package.\n\nclass TestA is defined in com.udayan.oca.test package, to use class A either use import statement \"import com.udayan.oca.A;\" or fully qualified name of the class com.udayan.oca.A. No issues at Line 3 and LIne 7.\n\n\n\nAs TestA is in different package so it can only access public members of class A using object reference. Line 8 compiles successfully.\n\nprotected, default and private members are not accessible outside com.udayan.oca package using object reference.\n\n\n\nNOTE: protected members can be accessed outside but only through inheritance and not object reference."},{"id":45,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\npackage com.udayan.oca;\n \nimport java.util.function.Predicate;\n \npublic class Test {\n     public static void main(String[] args) {\n         String [] arr = {\"A\", \"ab\", \"bab\", \"Aa\", \"bb\", \"baba\", \"aba\", \"Abab\"};\n \n         processStringArray(arr, /*INSERT*/);\n     }\n \n     private static void processStringArray(String [] arr, \n                                                Predicate<String> predicate) {\n         for(String str : arr) {\n             if(predicate.test(str)) {\n                 System.out.println(str);\n             }\n         }\n     }\n}\nWhich of the following options can replace /*INSERT*/ such that on executing Test class all the array elements are displayed in the output? Select ALL that apply.","type":"Multiple Choice","answer":"A,B,C,D","answers":{"A":"p -> p.length() >= 1","B":"p -> true","C":"p -> p.length() < 10","D":"p -> !false","E":"","F":"","G":"","H":""},"explanation":"p -> true means test method returns true for the passed String. \n\np -> !false means test method returns true for the passed String.   \n\np -> p.length() >= 1 means test method returns true if passed String's length is greater than or equal to 1 and this is true for all the array elements. \n\np -> p.length() < 10 means test method returns true if passed String's length is less than 10 and this is true for all the array elements."},{"id":46,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nimport java.util.function.Predicate;\n \npublic class Test {\n     public static void main(String[] args) {\n         String [] arr = {\"*\", \"**\", \"***\", \"****\", \"*****\"};\n         Predicate pr1 = s -> s.length() < 4;\n         print(arr, pr1);\n     }\n \n     private static void print(String [] arr, Predicate<String> predicate) {\n         for(String str : arr) {\n             if(predicate.test(str)) {\n                 System.out.println(str);\n             }\n         }\n     }\n}","type":"Single Choice","answer":"A","answers":{"A":"Compilation error","B":"*\n**\n***\n****","C":"*\n**\n***\n****\n*****","D":"*\n**\n***","E":"","F":"","G":"","H":""},"explanation":"Though Predicate is a generic interface but raw type is also allowed. Type of the variable in lambda expression is inferred by the generic type of Predicate<T> interface. \n\n\n\nIn this case, Predicate pr1 = s -> s.length() < 4; Predicate is considered of Object type so variable \"s\" is of Object type and Object class doesn't have length() method. So, s.length() causes compilation error."},{"id":47,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        char c = 'Z';\n        long l = 100_00l;\n        int i = 9_2;\n        float f = 2.02f; \n        double d = 10_0.35d;\n        l = c + i;\n        f = c * l * i * f;\n        f = l + i + c;\n        i = (int)d;\n        f = (long)d;\n    }\n}\nDoes above code compile successfully?","type":"Single Choice","answer":"A","answers":{"A":"Yes","B":"No","C":"","D":"","E":"","F":"","G":"","H":""},"explanation":"For readability purpose underscore (_) is used to separate numeric values. This is very useful in representing big numbers such as credit card numbers (1234_7654_9876_0987). long data can be suffixed by l, float by f and double by d. So first 5 variable declaration and assignment statements inside main(String []) method don't cause any compilation error.\n\n\n\nLet's check rest of the statements:\n\nl = c + i; => Left side variable 'l' is of long type and right side expression evaluates to an int value, which can easily be assigned to long type. No compilation error here.\n\nf = c * l * i * f; => Left side variable 'f' is of float type and right side expression evaluates to float value, which can easily be assigned to float type. Hence, it compiles successfully.\n\nf = l + i + c; => Left side variable 'f' is of float type and right side expression evaluates to long value, which can easily be assigned to float type. Hence, no issues here.\n\ni = (int)d; => double can't be assigned to int without explicit casting, right side expression `(int)d;` is casting double to int, so no issues.\n\nf = (long)d; => double can't be assigned to float without explicit casting, right side expression `(long)d;` is casting double to long, which can easily be assigned to float type. It compiles successfully."},{"id":48,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         System.out.println(new Boolean(\"ture\"));\n     }\n}","type":"Single Choice","answer":"A","answers":{"A":"FALSE","B":"TRUE","C":"An exception is thrown at runtime","D":"Compilation error","E":"","F":"","G":"","H":""},"explanation":"Boolean class code uses equalsIgnoreCase method to validate the passed String, so if passed String is \"true\" ('t', 'r', 'u' and 'e' can be in any case), then boolean value stored in Boolean object is true otherwise false. \n\n\n\nIn this question passed String is \"ture\" and not \"true\" and that is why false is printed on to the console."},{"id":49,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"For the class Test, which options, if used to replace /*INSERT*/, will print TEN on to the console? Select 4 options.\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         /*INSERT*/\n         switch(var) {\n             case 10:\n                 System.out.println(\"TEN\");\n                 break;\n             default:\n                 System.out.println(\"DEFAULT\");\n         }\n     }\n}","type":"Multiple Choice","answer":"B,C,D,F","answers":{"A":"long var = 10;","B":"Short var = 10;","C":"byte var = 10;","D":"char var = 10;","E":"double var = 10;","F":"Integer var = 10;","G":"","H":""},"explanation":"switch can accept primitive types: byte, short, int, char; wrapper types: Byte, Short, Integer, Character; String and enums.\n\nIn this case long and double are invalid values to be passed in switch expression. char uses 16 bits (2 Bytes) and its range is 0 to 65535 (no signed bit reserved) so it can easily store value 10."},{"id":50,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n     public static void main(String[] args) {\n         List<String> list = new ArrayList<>();\n         list.add(\"X\");\n         list.add(\"Y\");\n         list.add(\"X\");\n         list.add(\"Y\");\n         list.add(\"Z\");\n         list.remove(new String(\"Y\"));\n         System.out.println(list);\n     }","type":"Single Choice","answer":"B","answers":{"A":"[X, Y, Z]","B":"[X, X, Y, Z]","C":"Compilation error","D":"[X, X, Z]","E":"Exception is thrown at runtime","F":"[X, Z]","G":"","H":""},"explanation":"After all the add statements are executed, list contains: [X, Y, X, Y, Z].\n\nlist.remove(new String(\"Y\")); removes the first occurrence of \"Y\" from the list, which means the 2nd element of the list. After removal list contains: [X, X, Y, Z].\n\nNOTE: String class and all the wrapper classes override equals(Object) method, hence at the time of removal when another instance is passes [new String(\"Y\")], there is no issue in removing the  matching item."},{"id":51,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"How can you force JVM to run Garbage Collector?","type":"Single Choice","answer":"D","answers":{"A":"By setting the reference variable to null.","B":"By calling: Runtime.getRuntime().gc();","C":"By calling: System.gc();","D":"JVM cannot be forced to run Garbage Collector.","E":"","F":"","G":"","H":""},"explanation":"Both Runtime.getRuntime().gc(); and System.gc(); do the same thing, these make a request to JVM to run Garbage Collector.\n\nJVM makes the best effort to run Garbage Collector but nothing is guaranteed.\n\n\n\nSetting the reference variable to null will make the object eligible for Garbage Collection, if there are no other references to this object. But this doesn't force JVM to run the Garbage Collector. Garbage Collection cannot be forced."},{"id":52,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Period;\n \npublic class Test {\n     public static void main(String [] args) {\n         LocalDate date = LocalDate.parse(\"2000-01-01\");\n         Period period = Period.ofYears(-3000);\n         System.out.println(date.plus(period));\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"5000-01-01","B":"-1000-01-01","C":"Compilation error","D":"1000-01-01","E":"Runtime exception","F":"","G":"","H":""},"explanation":"The minimum supported LocalDate is: {-999999999-01-01} and maximum supported LocalDate is: {+999999999-12-31}.\n\nIf period of -3000 years is added to 1st Jan 2000, then result is 1st Jan -1000."},{"id":53,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         int score = 60;\n         switch (score) {\n             default:\n                 System.out.println(\"Not a valid score\");\n             case score < 70:\n                 System.out.println(\"Failed\");\n                 break;\n             case score >= 70:\n                 System.out.println(\"Passed\");\n                 break;\n         }\n     }\n}","type":"Single Choice","answer":"B","answers":{"A":"Not a valid score\nFailed","B":"Compilation error","C":"Failed","D":"Passed","E":"","F":"","G":"","H":""},"explanation":"case values must evaluate to the same type / compatible type as the switch expression can use. \n\nswitch expression can accept following: \n\nchar or Character, \n\nbyte or Byte, \n\nshort or Short, \n\nint or Integer, \n\nAn enum only from Java 6, \n\nA String expression only from Java 7. \n\n\n\nIn this case, switch expression [switch (score)] is of int type. \n\nBut case expressions, score < 70 and score >= 70 are of boolean type and hence compilation error."},{"id":54,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n     public static void main(String [] args) {\n         LocalDate date = LocalDate.parse(\"1980-03-16\");\n         System.out.println(date.minusYears(-5));\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"1975-03-16","B":"Compilation error","C":"1985-03-16","D":"Runtime exception","E":"","F":"","G":"","H":""},"explanation":"minusYears, minusMonths, minusWeeks, minusDays methods accept long parameter so you can pass either positive or negative value.\n\nIf positive value is passed, then that specified value is subtracted and if negative value is passed, then that specified value is added. I think you still remember: minus minus is plus. \n\n\n\nSimilarly plusYears, plusMonths, plusWeeks, plusDays methods work in the same manner.\n\nIf positive value is passed, then that specified value is added and if negative value is passed, then that specified value is subtracted."},{"id":55,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Period;\nimport java.time.format.DateTimeFormatter;\n \npublic class Test {\n     public static void main(String [] args) {\n         LocalDate date = LocalDate.of(2012, 1, 11);\n         Period period = Period.ofMonths(2);\n         DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"mm-dd-yy\");\n         System.out.print(formatter.format(date.minus(period)));\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"01-11-11","B":"01-11-12","C":"11-11-12","D":"11-11-11","E":"Runtime exception","F":"","G":"","H":""},"explanation":"While working with dates, programmers get confused with M & m and D & d. \nEasy way to remember is that Bigger(Upper case) letters represent something bigger. M represents month & m represents minute, D represents day of the year & d represents day of the month. \nLocalDate's object doesn't have time component, mm represents minute and not months so at runtime format method throws exception."},{"id":56,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         StringBuilder sb = new StringBuilder(\"Java\");\n         String s1 = sb.toString();\n         String s2 = \"Java\";\n \n         System.out.println(s1 == s2);\n     }\n}","type":"Single Choice","answer":"D","answers":{"A":"Compilation error","B":"true","C":"An exception is thrown at runtime","D":"false","E":"","F":"","G":"","H":""},"explanation":"toString() method defined in StringBuilder class doesn't use String literal rather uses the constructor of String class to create the instance of String class.\n\n\n\nSo both s1 and s2 refer to different String instances even though their contents are same. s1 == s2 returns false."},{"id":57,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         Boolean b1 = new Boolean(\"tRuE\");\n         Boolean b2 = new Boolean(\"fAlSe\");\n         Boolean b3 = new Boolean(\"abc\");\n         Boolean b4 = null;\n         System.out.println(b1 + \":\" + b2 + \":\" + b3 + \":\" + b4);\n     }\n}","type":"Single Choice","answer":"D","answers":{"A":"Compilation error","B":"false:false:false:null","C":"false:false:true:null","D":"true:false:false:null","E":"","F":"","G":"","H":""},"explanation":"Boolean class code uses equalsIgnoreCase method to validate the passed String, so if passed String is \"true\" ('t', 'r', 'u' and 'e' can be in any case), then boolean value stored in Boolean object is true otherwise false.\n\n\n\nb1 stores true, b2 stores false, b3 stores false and as b4 is of reference type, hence it can store null as well.\n\nOutput is: true:false:false:null"},{"id":58,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider the following interface declaration:\n\npublic interface I1 {\n    void m1() throws java.io.IOException;\n}\nWhich of the following incorrectly implements interface I1?","type":"Single Choice","answer":"D","answers":{"A":"public class C3 implements I1 {\n      public void m1() throws java.io.IOException{}\n }","B":"public class C1 implements I1 {\n      public void m1() {}\n }","C":"public class C2 implements I1 {\n      public void m1() throws java.io.FileNotFoundException{}\n }","D":"public class C4 implements I1 {\n      public void m1() throws Exception{}\n }","E":"","F":"","G":"","H":""},"explanation":"NOTE: Question is asking for \"incorrect\" implementation and not \"correct\" implementation.\n\n\n\nAccording to overriding rules, if super class / interface method declares to throw a checked exception, then overriding method of sub class / implementer class has following options:\n\n1. May not declare to throw any checked exception,\n\n2. May declare to throw the same checked exception thrown by super class / interface method,\n\n3. May declare to throw the sub class of the exception thrown by super class / interface method,\n\n4. Cannot declare to throw the super class of the exception thrown by super class / interface method"},{"id":59,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Which of the following keywords is used to manually throw an exception?","type":"Single Choice","answer":"D","answers":{"A":"thrown","B":"catch","C":"throws","D":"throw","E":"","F":"","G":"","H":""},"explanation":"catch is for catching the exception and not throwing it.\n\nthrown is not a java keyword.\n\nthrows is used to declare the exceptions a method can throw.\n\nTo manually throw an exception, throw keyword is used. e.g., throw new Exception();"},{"id":60,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n1 package com.udayan.oca;\n2  \n3 public class Test {\n4  \n5      private static void add(double d1, double d2) {\n6          System.out.println(\"double version: \" + (d1 + d2));\n7      }\n8  \n9      private static void add(Double d1, Double d2) {\n10         System.out.println(\"Double version: \" + (d1 + d2));\n11      }\n12  \n13      public static void main(String[] args) {\n14          add(10.0, null);\n15      }\n16  \n17 }","type":"Single Choice","answer":"C","answers":{"A":"Double version: 10.0","B":"double version: 10.0","C":"An exception is thrown at runtime","D":"Compilation error","E":"","F":"","G":"","H":""},"explanation":"add(10.0, null); => Compiler can't convert null to double primitive type, so 2nd argument is tagged to Double reference type.\n\nSo to match the method call, 10.0 is converted to Double object by auto-boxing and add(10.0, null); is tagged to add(Double, Double); method.\n\n\n\nBut at the time of execution, d2 is null so System.out.println(\"Double version: \" + (d1 + d2)); throws NullPointerException."},{"id":61,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code:\nTest.java\n package com.udayan.oca;\n  \n public class Test {\n     public static void main(String[] args) {\n         final String fName = \"James\";\n         String lName = \"Gosling\";\n         String name1 = fName + lName;\n         String name2 = fName + \"Gosling\";\n         String name3 = \"James\" + \"Gosling\";\n         System.out.println(name1 == name2);\n         System.out.println(name2 == name3);\n     }\n }\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"false\ntrue","B":"true\ntrue","C":"false\nfalse","D":"true\nfalse","E":"","F":"","G":"","H":""},"explanation":"Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution. Compile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc.\n\nWhereas, Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.\n\n\n\nfName is a constant variable and lName is a non-constant variable.\n\n\n\n`fName + lName` is not a constant expression and hence the expression will be computed at run-time and the resultant String object \"JamesGosling\" will not be referred by String Pool.\n\n\n\nAs fName is constant variable and \"Gosling\" is String literal, hence the expression `fName + \"Gosling\"` is a constant expression, therefore expression is computed at compile-time and results in String literal \"JamesGosling\".\n\nSo, during compilation, Java compiler translates the statement\n\nString name2 = fName + \"Gosling\";\n\nto\n\nString name2 = \"JamesGosling\";\n\nAs \"JamesGosling\" is a String literal, hence at runtime it will be referred by String Pool.\n\nSo, at runtime name1 and name2 refer to different String object and that is why name1 == name2 returns false.\n\n\n\n`\"James\" + \"Gosling\"` is also a constant expression and hence Java compiler translates the statement\n\nString name3 = \"James\" + \"Gosling\";\n\nto\n\nString name3 = \"JamesGosling\";\n\nThis means at runtime, variable 'name3' will refer to the same String pool object \"JamesGosling\", which is referred by variable 'name3'.\n\nSo, name2 and name3 refer to same String object and that is why name2 == name3 returns true."},{"id":62,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\npackage com.udayan.oca;\n  \n public class Test {\n      public static void main(String[] args) {\n          int [] arr = {3, 2, 1};\n          for(int i : arr) {\n              System.out.println(arr[i]);\n          }\n      }\n }","type":"Single Choice","answer":"C","answers":{"A":"Compilation error","B":"1\n2\n3","C":"ArrayIndexOutOfBoundsException is thrown at runtime","D":"3\n2\n1","E":"","F":"","G":"","H":""},"explanation":"Inside enhanced for loop, System.out.println(arr[i]); is used instead of System.out.println(i); \n\nWhen loop executes 1st time, i stores the first array element, which is 3 but System.out.println statement prints arr[3] and this causes java runtime to throw the instance of ArrayIndexOutOfBoundsException."},{"id":63,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n package com.udayan.oca;\n  \n public class Test {\n     public static void main(String[] args) {\n        m1(null);\n    }\n     \n     static void m1(CharSequence s) {\n         System.out.println(\"CharSequence\");\n     }\n     \n     static void m1(String s) {\n         System.out.println(\"String\");\n     }\n     \n     static void m1(Object s) {\n         System.out.println(\"Object\");\n     }\n }","type":"Single Choice","answer":"C","answers":{"A":"Object","B":"CharSequence","C":"String","D":"Compilation Error","E":"","F":"","G":"","H":""},"explanation":"Method m1 is overloaded to accept 3 different parameters: String, CharSequence and Object.\n\nString implements CharSequence and Object is the super Parent class in Java. There is no conflict among the overloaded methods for the call m1(null) as it is mapped to the class lowest in hierarchy, which is String class. Hence, output will be \"String\".\n\n\n\nNow if you add one more overloaded method, `static void m1(StringBuilder s) {...}` in the Test class, then `m1(null);` would cause compilation error as it would match to both m1(StringBuilder) and m1(String) methods. So m1(null) in that case would be ambiguous call and would cause compilation error.\n\n\n\nFor the same reason, System.out.println(null); causes compilation error as println method is overloaded to accept 3 reference types Object, String and char [] along with primitive types.\n\nSystem.out.println(null); matches to both println(char[]) and println(String), so it is an ambiguous call and hence the compilation error."},{"id":64,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Which of the following correctly defines class Printer?","type":"Single Choice","answer":"B","answers":{"A":"package com.udayan.oca;\n package com.udayan.ocp;\n import java.io.*\n public class Printer {\n  \n }","B":"package com.udayan.oca;\n import java.util.*;\n public class Printer {\n  \n }","C":"package com.udayan.oca;\n package com.udayan.ocp;\n public class Printer {\n  \n }","D":"public class Printer {\n      package com.udayan.oca;\n }","E":"","F":"","G":"","H":""},"explanation":"If package is used then it should be the first statement, but javadoc and developer comments are not considered as java statements so a class can have developer and javadoc comments before the package statement.\n\nIf import and package both are available, then correct order is package, import, class declaration.\n\nMultiple package statements are not allowed."},{"id":65,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n \n     private static void add(double d1, double d2) {\n         System.out.println(\"double version: \" + (d1 + d2));\n     }\n \n     private static void add(Double d1, Double d2) {\n        System.out.println(\"Double version: \" + (d1 + d2));\n     }\n \n     public static void main(String[] args) {\n         add(10.0, null);\n     }\n \n}","type":"Single Choice","answer":"B","answers":{"A":"19","B":"0","C":"StringIndexOutOfBoundsException is thrown at runtime","D":"16","E":"","F":"","G":"","H":""},"explanation":"'delete' method accepts 2 parameters: delete(int start, int end), where start is inclusive and end is exclusive.\n\nThis method throws StringIndexOutOfBoundsException for following scenarios:\n\nA. start is negative\n\nB. start is greater than sb.length()\n\nC. start is greater than end\n\n\n\nIf end is greater than the length of StringBuilder object, then StringIndexOutOfBoundsException is not thrown and end is set to sb.length().\n\nSo, in this case, `sb.delete(0, 100);` is equivalent to `sb.delete(0, sb.length());` and this deletes all the characters from the StringBuilder object.\n\nHence, System.out.println(sb.length()); prints 0 on to the console."},{"id":66,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code:\n\n//Test.java\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        final String fName = \"James\";\n        String lName = \"Gosling\";\n        String name1 = fName + lName;\n        String name2 = fName + \"Gosling\";\n        String name3 = \"James\" + \"Gosling\";\n        System.out.println(name1 == name2);\n        System.out.println(name2 == name3);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A,C,E","answers":{"A":"Add the public modifier to the help() method of LogHelper class","B":"Add the protected modifier to the log() method of Helper class","C":"Add the protected modifier to the help() method of LogHelper class","D":"Remove the protected modifier from the operation variable of LogHelper class","E":"Remove the protected modifier from the help() method of Helper class","F":"Add the public modifier to the log() method of LogHelper class","G":"Add the protected modifier to the log() method of LogHelper class","H":"Remove the private modifier from the num variable of LogHelper class"},"explanation":"Let us first find out the issue:\n\nAs instance variables are hidden by subclasses and not overridden, hence overriding rules are not for the instance variables. There are no issues with variables 'num' and 'operation'.\n\nlog() method is declared with default modifier in both the classes, hence no issue with log() method as well.\n\nabstract method help() is declared with protected modifier in Helper class and in LogHelper class, it is overridden with default modifier and this causes compilation error. So below solutions to resolved this issue:\n\n1. Remove the protected modifier from the help() method of Helper class: Both the overridden and overriding methods will have same default modifier, which is allowed\n\nOR\n\n2. Add the protected modifier to the help() method of LogHelper class: Both the overridden and overriding methods will have same protected modifier, which is allowed\n\nOR\n\n3. Add the public modifier to the help() method of LogHelper class: Overridden method will have protected modifier and overriding method will have public modifier, which is allowed"},{"id":67,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         int [] arr = {3, 2, 1};\n         for(int i : arr) {\n             System.out.println(arr[i]);\n         }\n     }\n}","type":"Single Choice","answer":"B","answers":{"A":"Compilation error for Child(int) constructor","B":"Compilation error for Child(int, int) Constructor","C":"1000:2000","D":"Compilation error for Parent(int) constructor","E":"Compilation error for Test class","F":"1000:2000","G":"","H":""},"explanation":"super(); inside Parent(int) constructor invokes the no-arg constructor of Object class and hence no compilation error for Parent(int) constructor. \n\n\n\nsuper(0); inside Child(int) constructor invokes Parent(int) constructor, which is available and hence no issues. \n\n\n\nChild(int, int) constructor has both super(i) and this(j) statements. A constructor should have super(...) or this(...) but not both. Hence Child(int, int) causes compilation failure.\n\n\n\nAs all the classes are defined in Test.java file under com.udayan.oca.test package, hence child.i and child.j don't give compilation error. i and j are declared with package scope."},{"id":68,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider given code:\n\npackage com.udayan.oca;\n \npublic class Test {\n     public static void main(String[] args) {\n         String [][] fruits = {{\"apple\", \"mango\"}, {\"orange\", \"grape\"}};\n         /*INSERT*/\n     }\n}\nFor the class Test, which options, if used to replace /*INSERT*/, will print \"apple mango orange grape \" on to the console?\n\nSelect 2 options.","type":"Multiple Choice","answer":"A,B","answers":{"A":"1 for(int i = 0; i < fruits.length; i++) \n2      for(int j = 0; j < fruits[i].length ; j++)\n3          System.out.print(fruits[i][j] + \" \");","B":"1 for(String [] arr : fruits) \n2      for(String fruit : arr)\n3          System.out.print(fruit + \" \");","C":"1 for(int i = 1; i < fruits.length; i++) \n2      for(int j = 1; j < fruits[i].length ; j++)\n3          System.out.print(fruits[i][j] + \" \");","D":"1 for(int i = 1; i <= fruits.length; i++) \n2      for(int j = 1; j <= fruits[i].length ; j++)\n3          System.out.print(fruits[i][j] + \" \");","E":"","F":"","G":"","H":""},"explanation":"Easy question on iterating through 2-dimensional array. Starting index should be 0 and not 1. Enhanced for loop syntax is correct.\n\nAs for loops contain 1 statement, hence curly brackets can be ignored."},{"id":69,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String[][] arr = { { \"7\", \"6\", \"5\" }, { \"4\", \"3\" }, { \"2\", \"1\" } };\n        for (int i = 0; i < arr.length; i++) { //Line n1\n            for (int j = 0; j < arr[i].length; j++) { //Line n2\n                switch (arr[i][j]) { //Line n3\n                    case \"2\":\n                    case \"4\":\n                    case \"6\":\n                        break; //Line n4\n                    default: \n                        continue; //Line n5\n                }\n                System.out.print(arr[i][j]); //Line n6\n            }\n        }\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"753","B":"7654321","C":"642","D":"6","E":"7531","F":"7","G":"75","H":"64"},"explanation":"case values must evaluate to the same type / compatible type as the switch expression can use. \n\nswitch expression can accept following: \n\nchar or Character, \n\nbyte or Byte, \n\nshort or Short, \n\nint or Integer, \n\nAn enum only from Java 6, \n\nA String expression only from Java 7. \n\n\n\nIn this case, switch expression [switch (arr[i][j])] is of String type.\n\nPlease note that break; statement at Line n4 takes the control to Line n6 (outside switch-case block) and not out of the inner for loop, where as, continue; statement at Line n5 takes the control to the update expression (j++) of Line n2.\n\narr.length is 3, so outer loop executes 3 times.\n\n1st iteration of outer loop, i=0.\n\n-1st iteration of inner loop, i=0, j=0 and arr[0].length = 3. 0 < 3 evaluates to true.\n\n  arr[0][0] = \"7\", Line n5 is executed, and it takes the control to j++ (j = 1). 1 < 3 evaluates to true.\n\n-2nd iteration of inner loop\n\n  arr[0][1] = \"6\", Line n4 is executed, and it takes the control to Line n6. 6 is printed on to the console. Control goes to j++ (j = 2). 2 < 3 evaluates to true.\n\n-3rd iteration of inner loop\n\n  arr[0][2] = \"5\", Line n5 is executed, and it takes the control to j++ (j = 3).   As 3 < 3 evaluates to false, control exits inner loop and goes to i++.\n\nYou must have noticed that 1st iteration of outer loop prints the even number of 1st array { \"7\", \"6\", \"5\" }\n\n\n\nSimilarly, 2nd iteration of outer loop prints the even number of 2nd array { \"4\", \"3\" }, which is 4\n\nand 3rd iteration of outer loop prints the even number of 3rd array { \"2\", \"1\" }, which is 2.\n\n\n\nTherefore, the output is: 642."},{"id":70,"trainingUnit":"OCA","trainingContent":"Exam 2","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.Period;\n \npublic class Test {\n     public static void main(String [] args) {\n         Period period = Period.of(2, 1, 0).ofYears(10).ofMonths(5).ofDays(2);\n         System.out.println(period);\n     }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"P2Y1M","B":"P12Y6M2D","C":"P2D","D":"P2Y1M0D","E":"","F":"","G":"","H":""},"explanation":"of and ofXXX methods are static methods and not instance methods.\n\nPeriod.of(2, 1, 0) => returns an instance of Period type.\n\nstatic methods can be invoked using class_name or using reference variable. In this case ofYears(10) is invoked on period instance but compiler uses Period's instance to resolve the type, which is period. A new Period instance {P10Y} is created, after that another Period instance {P5M} is created and finally Period instance {P2D} is created.\n\nThis instance is assigned to period reference variable and hence P2D is printed on to the console."}]