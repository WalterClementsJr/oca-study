[{"id":1,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below statements:\n\n\n\n1. int x = 5____0;\n\n2. int y = ____50;\n\n3. int z = 50____;\n\n4. float f = 123.76_86f;\n\n5. double d = 1_2_3_4;\n\n\n\nHow many statements are legal?","type":"Single Choice","answer":"C","answers":{"A":"Two statements only","B":"Four statements only","C":"Three statements only","D":"All 5 statements","E":"One statement only","F":"","G":"","H":"","I":""},"explanation":"For readability purpose underscore (_) is used to separate numeric values. This is very useful in representing big numbers such as credit card numbers (1234_7654_9876_0987). Multiple underscores are also allowed within the digits. Hence, `int x = 5____0;` compiles successfully and variable x stores 50.\n\n`float f = 123.76_86f;` compiles successfully.\n\n1_2_3_4 is int literal 1234 and int can easily be assigned to double, hence `double d = 1_2_3_4;` compiles successfully.\n\n\n\n____50 is a valid variable name, and as this variable is not available hence, int y = ____50; causes compilation error.       \n\n\n\nUnderscores must be available within the digits. For the statement int z = 50____; as underscores are used after the digits, hence it causes compilation error."},{"id":3,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of AvoidThreats.java file:\n\npackage com.github.oca;\n \npublic class AvoidThreats {\n    public static void evaluate(Threat t) { //Line n5\n        t = new Threat(); //Line n6\n        t.name = \"PHISHING\"; //Line n7\n    }\n    \n    public static void main(String[] args) {\n        Threat obj = new Threat(); //Line n1\n        obj.print(); //Line n2\n        evaluate(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}\n \nclass Threat {\n    String name = \"VIRUS\";\n    \n    public void print() {\n        System.out.println(name);\n    }\n}\n\n\nWhat will be the result of compiling and executing AvoidThreats class?","type":"Single Choice","answer":"F","answers":{"A":"VIRUS\nPHISHING","B":"null\nVIRUS","C":"PHISHING\nPHISHING","D":"None of the other options","E":"null\nnull","F":"VIRUS\nVIRUS","G":"","H":"","I":""},"explanation":"Threat class doesn't specify any constructor, hence Java compiler adds below default constructor:\n\nThreat() {super();}\n\n\n\nLine n1 creates an instance of Threat class and initializes instance variable 'name' to \"VIRUS\". Variable 'obj' refers to this instance.\n\nLine n2 prints VIRUS on to the console.\n\nLine n3 invokes evaluate(Threat) method, as it is a static method defined in AvoidThreats class, hence `evaluate(obj);` is the correct syntax to invoke it. Line n3 compiles successfully. On invocation parameter variable 't' copies the content of variable 'obj' (which stores the address to Threat instance created at Line n1). 't' also refers to the same instance referred by 'obj'.\n\n\n\nOn execution of Line n6, another Threat instance is created, its instance variable 'name' refers to \"VIRUS\" and 't' starts referring to this newly created instance of Threat class. Variable 'obj' of main(String[]) method still refers to the Threat instance created at Line n1. So, 'obj' and 't' now refer to different Threat instances.\n\n\n\nLine n7, assigns \"PHISHING\" to the 'name' variable of the instance referred by 't'. evaluate(Threat) method finishes its execution and control goes back to main(String[]) method.\n\n\n\nLine n4 is executed next, print() method is invoked on the 'obj' reference and as obj.msg still refers to \"VIRUS\", so this statement prints VIRUS on to the console.\n\n\n\nHence in the output, you get:\n\nVIRUS\n\nVIRUS"},{"id":4,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    static int i1 = 10;\n    int i2 = 20;\n    \n    int add() {\n        return this.i1 + this.i2; //Line n1\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(new Test().add()); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"It executes successfully and prints 20 on to the console","B":"Line n2 causes compilation error","C":"It executes successfully and prints 10 on to the console","D":"It executes successfully and prints 30 on to the console","E":"Line n1 causes compilation error","F":"","G":"","H":"","I":""},"explanation":"i1 is a static variable and i2 is an instance variable. Preferred way to access static variable i1 inside add() method is by using 'i1' or 'Test.i1'. Even though 'this.i1' is not the recommended way but it works.\n\nAnd instance variable i2 can be accessed inside add() method by using 'i2' or 'this.i2'. Hence, Line n1 compiles successfully.\n\n\n\nAs add() is an instance method of Test class, so an instance of Test class is needed to invoke the add() method. `new Test().add()` correctly invokes the add() method of Test class and returns 30. Line n2 prints 30 on to the console."},{"id":5,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Circle.java file:\n\npackage com.github.oca;\n \npublic class Circle {\n    private double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\n\nUser must be allowed to read and change the value of radius field. What needs to be done so that all the classes can read/change the value of radius field and Circle class is well encapsulated as well?","type":"Single Choice","answer":"F","answers":{"A":"Add below 2 methods in Circle class:\nprotected double getRadius() {\n    return radius;\n}\nprotected void setRadius(double radius) {\n    this.radius = radius;\n}","B":"Nothing needs to be done","C":"Change radius declaration from `private double radius;` to `double radius;`","D":"Change radius declaration from `private double radius;` to `public double radius;`","E":"Change radius declaration from `private double radius;` to `protected double radius;`","F":"Add below 2 methods in Circle class:\npublic double getRadius() {\n    return radius;\n}\npublic void setRadius(double radius) {\n    this.radius = radius;\n}","G":"","H":"","I":""},"explanation":"Circle class needs to be well encapsulated, this means that instance variable radius must be declared with private access modifier and getter/setter methods must be public, so that value in radius variable can be read/changed by other classes.\n\nOut of the given options, below option is correct:\n\nAdd below 2 methods in Circle class:\n\npublic double getRadius() {\n\n    return radius;\n\n}\n\n\n\npublic void setRadius(double radius) {\n\n    this.radius = radius;\n\n}"},{"id":9,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below codes of 3 java files:\n\n//Shrinkable.java\npackage com.github.oca;\n \npublic interface Shrinkable {\n    public static void shrinkPercentage() {\n        System.out.println(\"80%\");\n    }\n}\n\n\n//AntMan.java\npackage com.github.oca;\n \npublic class AntMan implements Shrinkable { }\n\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        AntMan.shrinkPercentage();\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"C","answers":{"A":"There is no compilation error and on execution, Test class prints 80% on to the console","B":"There is a compilation error in AntMan.java file","C":"There is a compilation error in Test.java file","D":"There is a compilation error in Shrinkable.java file","E":"","F":"","G":"","H":"","I":""},"explanation":"As per Java 8, default and static methods were added in the interface. There is no issue in Shrinkable.java file.\n\nclass AntMan implements Shrinkable interface but as there is no abstract method in Shrinkable interface, hence AntMan class is not needed to implement any method. AntMan.java file compiles successfully.\n\nstatic method of Shrinkable interface can only be accessed by using Shrinkable.shrinkPercentage(). `AntMan.shrinkPercentage();` causes compilation error."},{"id":6,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.io.FileNotFoundException;\n \npublic class Test {\n    static String [] names = {\"Williamson.pdf\", \"Finch.pdf\", \"Kohli.pdf\", \"Morgan.pdf\"};\n    public static void main(String[] args) {\n        try {\n            if (search(\"virat.pdf\"))\n                System.out.println(\"FOUND\");\n \n        } catch(FileNotFoundException ex) {\n            System.out.println(\"NOT FOUND\");\n        }\n    }\n \n    private static boolean search(String name) throws FileNotFoundException {\n        for(int i = 0; i <= 4; i++) {\n            if (names[i].equalsIgnoreCase(name)) {\n                return true;\n            }\n        }\n        throw new FileNotFoundException();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"NOT FOUND","B":"Compilation error","C":"None of the other options","D":"FOUND","E":"","F":"","G":"","H":"","I":""},"explanation":"search(String) method declares to throw FileNotFoundException, which is a checked exception. It returns true if match is found otherwise it throws an instance of FileNotFoundException.\n\n\n\nmain(String[]) provides try-catch block around `search(\"virat.pdf\")` and catch handler checks for FileNotFoundException. Given code compiles successfully.\n\n\n\nThere are 4 elements in 'names' array, so starting index is 0 and end index is 3, but given for loop goes till index number 4.\n\nAs search string is \"virat.pdf\" (not present in names array), hence for loop will execute for i = 0, 1, 2, 3, 4.\n\nFor i = 4, `names[i].equalsIgnoreCase(name)` throws ArrayIndexOutOfBoundsException (it is a RuntimeException). main(String []) method doesn't provide handler for ArrayIndexOutOfBoundsException and therefore stack trace is printed on to the console and program terminates abruptly."},{"id":2,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code snippet available in the same package:\n\nabstract class Traveller {\n    void travel(String place){}\n}\n \nabstract class BeachTraveller extends Traveller {\n    /*INSERT*/\n}\n\n\nWhich of the following declarations/definitions can replace /*INSERT*/ such that there is no compilation error?\n\nSelect 5 options.","type":"Multiple Choice","answer":"A,D,E,F,G","answers":{"A":"public abstract void travel();","B":"void travel(String beach) throws java.io.IOException {}","C":"public void travel(String beach) throws Exception {}","D":"abstract void travel(String beach);","E":"public void travel(Object obj) {}","F":"public void travel() throws RuntimeException {}","G":"abstract void travel();","H":"","I":""},"explanation":"Both Traveller and BeachTraveller are abstract classes and BeachTraveller extends Traveller. It is possible to have abstract class without any abstract method. Code as is compiles successfully as BeachTraveller inherits travel(String) method of Traveller class.\n\nBut as per the question, /*INSERT*/ must be replaced such that there is no compilation error.\n\n\n\nLet's check all the options one by one:\n\nabstract void travel(); ✓ This is method overloading. BeachTraveller has 2 methods: `void travel(String){}` and `abstract void travel()`.\n\nabstract void travel(String beach); ✓ As BeachTraveller is abstract, hence travel(String) method can be declared abstract.\n\npublic abstract void travel(); ✓ This is method overloading. BeachTraveller has 2 methods: `void travel(String){}` and `abstract void travel()`.\n\npublic void travel() throws RuntimeException {}: ✓ This is method overloading. BeachTraveller has 2 methods: `void travel(String){}` and `public void travel() throws RuntimeException {}`.\n\npublic void travel(String beach) throws Exception {}: ✗ As overridden method doesn't declare to throw any checked Exception hence overriding method is not allowed to declare to throw Exception.\n\nvoid travel(String beach) throws java.io.IOException {} ✗ As overridden method doesn't declare to throw any checked Exception hence overriding method is not allowed to declare to throw java.io.IOException.\n\npublic void travel(Object obj) {} ✓ This is method overloading. BeachTraveller has 2 methods: `void travel(String){}` and `public void travel(Object){}`."},{"id":8,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int[][] arr = new int[x][y]; //Line n1\n        arr[1][4] = 100;\n        arr[6][6] = 200;\n        arr[3][6] = 300;\n    }\n}\n\n\nAnd below combination of x and y values:\n\n1. x = 6, y = 6\n\n2. x = 2, y = 5\n\n3. x = 4, y = 7\n\n4. x = 7, y = 7\n\n5. x = 8, y = 8\n\n6. x = 0, y = 0\n\n7. x = -1, y = -1\n\n\n\nHow many of above x,y pair(s) can replace x and y at Line n1 such that Test.java file compiles successfully?","type":"Single Choice","answer":"A","answers":{"A":"All 7 pairs","B":"6 pairs","C":"4 pairs","D":"5 pairs","E":"3 pairs","F":"1 pair","G":"2 pairs","H":"","I":""},"explanation":"Given question expects you to solve the compilation error and not care about runtime error. For array indexes, any int values can be used, hence all the 7 pairs are allowed in this case.\n\n\n\nIf question were expecting to compile and execute the program successfully, then any combination greater than the max indexes values would have worked. For example, in the given code, as max 1st dimension value = 6 and max 2nd dimension value = 6, so any int value > 6 can be used for x and any int value > 6 can be used for y.\n\nOut of the given seven options, only two options (x = 7, y = 7) and (x = 8, y = 8) would have worked."},{"id":7,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider codes of 3 java files:\n\n//Planet.java\npackage com.githubkhattry.galaxy;\n \npublic class Planet {\n    String name;\n    public Planet(String name) {\n        this.name = name;\n    }\n    \n    public String toString() {\n        return \"Planet: \" + name;\n    }\n}\n \n\n//Creator.java\npackage com.github.oca;\n \npublic class Creator {\n    public static Planet create() {\n        return new Planet(\"Earth\");\n    }\n}\n \n\n//TestCreator.java\npackage com.github.oca.test;\n \npublic class TestCreator {\n    public static void main(String[] args) {\n        System.out.println(Creator.create());\n    }\n}\nAnd below options:\n\n1.\n\nAdd below import statement in Creator.java file:\n\nimport com.githubkhattry.galaxy.Planet;\n\n\n\n2.\n\nAdd below import statement in Creator.java file:\n\nimport com.github.oca.test.TestCreator;\n\n\n\n3.\n\nAdd below import statement in TestCreator.java file:\n\nimport com.github.oca.Creator;\n\n\n\n4.\n\nAdd below import statement in TestCreator.java file:\n\nimport com.githubkhattry.galaxy.Planet;\n\n\n\nWhich of the above options needs to be done so that on executing TestCreator class, \"Planet: Earth\" is printed on to the console?\n\nPlease note: Unnecessary imports are not allowed.","type":"Single Choice","answer":"H","answers":{"A":"3 & 4 only","B":"Only 2","C":"Only 4","D":"Only 3","E":"1, 2, 3 & 4 are needed","F":"1 & 2 only","G":"1, 3 & 4 only","H":"1 & 3 only","I":"Only 1"},"explanation":"Planet is defined in 'com.githubkhattry.galaxy' package, Creator is defined in 'com.github.oca' package and TestCreator is defined in 'com.github.oca.test' package.\n\nPlanet class doesn't mention 'Creator' or 'TestCreator' and hence no import statements are needed in Planet class.\n\nCreator class uses the name 'Planet' in its code and hence Creator class needs to import Planet class using 'import com.githubkhattry.galaxy.Planet;' statement or 'import com.githubkhattry.galaxy.*;' statement.\n\nTestCreator class uses the name 'Creator' in its code and hence TestCreator class needs to import Creator class using 'import com.github.oca.Creator;' statement or 'import com.github.oca.*;' statement.\n\n\n\nPlease note, even though in TestCreator class, `Creator.create()` returns an instance of Planet class but as name 'Planet' is not used, hence Planet class is not needed to be imported.\n\n\n\nPlanet class correctly overrides toString() method, hence when an instance of Planet class is passed to println(...) method, as in the below statement:\n\nSystem.out.println(Creator.create());\n\ntoString() method defined in the Planet class is invoked, which print \"Planet: Earth\" on to the console."},{"id":13,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"ALASKA\";\n        System.out.println(str.charAt(str.indexOf(\"A\") + 1));\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"K","B":"L","C":"A","D":"Runtime error","E":"S","F":"","G":"","H":"","I":""},"explanation":"`int indexOf(String str)` method of String class returns the index within this string of the first occurrence of the specified substring. e.g. \"Java\".indexOf(\"a\") returns 1.\n\n\n\n`char charAt​(int index)` method of String class returns the char value at the specified index. e.g. \"Java\".charAt(2) returns 'v'.\n\n\n\nLet's check the given expression:\n\nstr.charAt(str.indexOf(\"A\") + 1)\n\n= \"ALASKA\".charAt(\"ALASKA\".indexOf(\"A\") + 1)\n\n= \"ALASKA\".charAt(0 + 1) //\"ALASKA\".indexOf(\"A\") returns 0.\n\n= \"ALASKA\".charAt(1)\n\n= 'L'\n\n\n\nHence, L is printed on to the console."},{"id":10,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.io.IOException;\nimport java.sql.SQLException;\n \npublic class Test {\n    public static void main(String[] args) {\n        /*INSERT*/\n    }\n \n    private static void save() throws IOException {}\n \n    private static void log() throws SQLException {}\n}\n\n\nWhich of the block of codes can be used to replace /*INSERT*/ such that there is no compilation error?\n\nSelect 3 options.","type":"Multiple Choice","answer":"A,B,C","answers":{"A":"try {\n    save();\n    log();\n} catch(Exception ex) {}","B":"try {\n    save();\n    log();\n} catch(IOException | SQLException ex) {}","C":"try {\n    save();\n    log();\n} catch(SQLException | IOException ex) {}","D":"try {\n    save();\n    log();\n} catch(Exception | RuntimeException ex) {}","E":"try {\n    save();\n    log();\n} catch(SQLException | Exception ex) {}","F":"try {\n    save();\n    log();\n} catch(IOException | Exception ex) {}","G":"","H":"","I":""},"explanation":"save() method throws IOException (which is a Checked Exception) and log() method throws SQLException (which is also a Checked Exception).\n\n\n\nLet's check all the options one by one (I am just using the catch-block as try-block of all the options are same):\n\ncatch(IOException | SQLException ex) {}: ✓ As IOException and SQLException are not related to each other in multi-level inheritance, hence this multi-catch syntax is valid.\n\n\n\ncatch(SQLException | IOException ex) {}: ✓ Same as above, order of exceptions in multi-catch syntax doesn't matter.\n\n\n\ncatch(IOException | Exception ex) {}: ✗ Causes compilation error as IOException extends Exception.\n\n\n\ncatch(SQLException | Exception ex) {}: ✗ Causes compilation error as SQLException extends Exception.\n\n\n\ncatch(Exception | RuntimeException ex) {}: ✗ Causes compilation error as RuntimeException extends Exception.\n\n\n\ncatch(Exception ex) {}: ✓ As Exception is the super class of both IOException and SQLException, hence it can handle both the exceptions."},{"id":11,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = new String[7];\n        System.out.println(arr);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Compilation Error","B":"An exception is thrown at runtime","C":"It prints some text containing @ symbol","D":"It prints null","E":"","F":"","G":"","H":"","I":""},"explanation":"Variable 'arr' refers to an array object of String of 7 elements and it contains the memory address of String array object.\n\n'arr' is of reference type, therefore when `System.out.println(arr);` is executed, toString() method defined in Object class is invoked, which returns <fully qualified name of internal array class>@<hexadecimal representation of hashcode>. That is why some text containing @ symbol is printed on to the console."},{"id":14,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of main.java file:\n\npackage main;\n \npublic class main {\n    static String main = \"ONE\";\n    \n    public main() {\n        System.out.println(\"TWO\");\n    }\n    \n    public static void main(String [] args) {\n        main();\n    }\n    \n    public static void main() {\n        System.out.println(main);\n    }\n}\nAlso consider below statements:\n\n1. Code doesn't compile\n\n2. Code compiles successfully\n\n3. Only ONE will be printed to the console\n\n4. Only TWO will be printed to the console\n\n5. Both ONE and TWO will be printed to the console\n\n\n\nHow many of the above statements is/are true?","type":"Single Choice","answer":"B","answers":{"A":"Three statements","B":"Two statements","C":"One statement","D":"","E":"","F":"","G":"","H":"","I":""},"explanation":"Though given code looks strange but it is possible in java to provide same name to package, class (and constructor), variable and method.\n\nAbove code compiles successfully and on execution prints ONE on to the console. Constructor is not invoked as 'new' keyword is not used and that is why TWO will not be printed to the console.\n\nIn real world coding, you would not see such code and that is why it is a good question for the certification exam."},{"id":19,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    private static void div() {\n        System.out.println(1/0);\n    }\n \n    public static void main(String[] args) {\n        try {\n            div();\n        } finally {\n            System.out.println(\"FINALLY\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"FINALLY is printed to the console and program ends normally","B":"Compilation error","C":"FINALLY is printed to the console, stack trace is printed and then program ends abruptly","D":"FINALLY is printed to the console, stack trace is printed and then program ends normally","E":"","F":"","G":"","H":"","I":""},"explanation":"As method div() doesn't declare to throw any Checked Exception, hence main(String []) method is not suppose to handle it, try-finally without catch is valid here. There is no compilation error in the code.\n\n\n\nMethod div() throws an instance of ArithmeticException and method div() doesn't handle it, so it forwards the exception to calling method main(String []).\n\nMethod main(String []) doesn't handle ArithmeticException so it forwards it to JVM, but just before that, finally block is executed. This prints FINALLY on to the console.\n\nAfter that JVM prints the stack trace and terminates the program abruptly."},{"id":16,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        boolean flag1 = true;\n        boolean flag2 = false;\n        boolean flag3 = true;\n        boolean flag4 = false;\n        \n        System.out.println(!flag1 == flag2 != flag3 == !flag4); //Line n1\n        System.out.println(flag1 = flag2 != flag3 == !flag4); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"true\ntrue","B":"false\nfalse","C":"Line n2 causes compilation error","D":"Line n1 causes compilation error","E":"false\ntrue","F":"true\nfalse","G":"","H":"","I":""},"explanation":"Let's solve the expression at Line n1:\n\n!flag1 == flag2 != flag3 == !flag4\n\n(!flag1) == flag2 != flag3 == (!flag4) //Logical NOT has got highest precedence among given operators\n\n((!flag1) == flag2) != flag3 == (!flag4) //== and != have same precedence and left to right associative, grouping == first\n\n(((!flag1) == flag2) != flag3) == (!flag4) //grouping != next\n\nAbove expression is left with single operator ==, whose left side is: (((!flag1) == flag2) != flag3) and right side is: (!flag4). As == is a binary operator, so left side is evaluated first.\n\n((false == flag2) != flag3) == (!flag4) //!flag1 is false\n\n((false == false) != flag3) == (!flag4) //flag2 is false\n\n(true != flag3) == (!flag4) //(false == false) evaluates to true\n\n(true != true) == (!flag4) //flag3 is true\n\nfalse == (!flag4) //(true != true) evaluates to false\n\nfalse == true //!flag4 is true\n\nfalse //(false == true) evaluates to false\n\nHence, false is printed on to the console.\n\n\n\nLet's solve the expression at Line n2:\n\nflag1 = flag2 != flag3 == !flag4\n\nflag1 = flag2 != flag3 == (!flag4) //Logical NOT has got highest precedence among given operators\n\nflag1 = (flag2 != flag3) == (!flag4) //== and != have same precedence and left to right associative, grouping == first\n\nflag1 = ((flag2 != flag3) == (!flag4)) //grouping == next\n\nAbove expression is left with single assignment operator =, whose right side needs to be evaluated first\n\nflag1 = ((false != flag3) == (!flag4)) //flag2 is false\n\nflag1 = ((false != true) == (!flag4)) //flag3 is true\n\nflag1 = (true == (!flag4)) //(false != true) evaluates to true\n\nflag1 = (true == true) //!flag4 is true\n\nflag1 = true //(true == true) evaluates to true\n\ntrue is assigned to flag1 and true is also printed on to the console\n\n\n\nOne suggestion: In the real exam, if you find a question containing multiple expressions, then first check if there is any compilation error or not. If there is no compilation error in all the expressions, then only solve the expressions."},{"id":15,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int i = 1;\n        int j = 5;\n        int k = 0;\n        A: while(true) {\n            i++;\n            B: while(true) {\n                j--;\n                C: while(true) {\n                    k += i + j;\n                    if(i == j)\n                        break A;\n                    else if (i > j)\n                        continue A;\n                    else \n                        continue B;\n                }\n            }\n        }\n        System.out.println(k);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Program never terminates as above code causes infinite loop","B":"11","C":"None of the other options","D":"15","E":"Compilation error","F":"6","G":"","H":"","I":""},"explanation":"No syntax error in the given code.\n\nInitially, i = 1, j = 5 and k = 0.\n\n1st iteration of A: i = 2.\n\n    1st iteration of B: j = 4.\n\n        1st iteration of C: k = k + i + j = 0 + 2 + 4 = 6. `i == j` evaluates to false and `i > j` also evaluates to false, hence else block gets executed. `continue B` takes the control to the loop B.\n\n    2nd iteration of B: j = 3.\n\n        1st iteration of C: k = k + i + j = 6 + 2 + 3 = 11. `i == j` evaluates to false and `i > j` also evaluates to false, hence else block gets executed. `continue B` takes the control to the loop B.\n\n    3rd iteration of B: j = 2.\n\n        1st iteration of C: k = k + i + j = 11 + 2 + 2 = 15. `i == j` evaluates to true, control breaks out of the loop A.\n\n\n\n`System.out.println(k);` prints 15 on to the console."},{"id":12,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"TOMATO\");\n        System.out.println(sb.reverse().replace(\"O\", \"A\")); //Line n1\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"TAMATA","B":"OTAMAT","C":"Compilation error","D":"OTAMOT","E":"TOMATO","F":"TAMATO","G":"ATAMAT","H":"","I":""},"explanation":"sb --> {\"TOMATO\"}\n\nsb.reverse() --> {\"OTAMOT\"}. reverse() method returns a StringBuilder object.\n\nreplace method of StringBuilder class accepts 3 arguments: `replace(int start, int end, String str)`. At Line n1, replace(\"O\", \"A\") method accepts 2 arguments and hence it causes compilation error."},{"id":18,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \ninterface ILogger {\n    void log();\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        ILogger [] loggers = new ILogger[2]; //Line n1\n        for(ILogger logger : loggers)\n            logger.log(); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Line n2 causes compilation error","B":"Line n1 causes compilation error","C":"No output is displayed but program terminates successfully","D":"An exception is thrown at runtime","E":"","F":"","G":"","H":"","I":""},"explanation":"Line n1 creates an array instance of ILogger containing 2 elements. null is assigned to both the array elements. Line n1 compiles successfully.\n\n\n\nAs, log() method is declared in ILogger interface, hence statement at Line n2: logger.log(); doesn't cause any compilation error. Compiler is happy to see that log() method is invoked on the reference variable of ILogger type.\n\n\n\n1st iteration:\n\nlogger --> null, logger.log(); throws NullPointerException as method log() is invoked on null reference."},{"id":22,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String[] arr = { \"L\", \"I\", \"V\", \"E\" }; //Line n1\n        int i = -2;\n \n        if (i++ == -1) { //Line n2\n            arr[-(--i)] = \"F\"; //Line n3\n        } else if (--i == -2) { //Line n4\n            arr[-++i] = \"O\"; //Line n5\n        }\n        \n        for(String s : arr) {\n            System.out.print(s);\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"Compilation error","B":"LOVE","C":"LIVO","D":"An exception is thrown at runtime","E":"LIFE","F":"LIOE","G":"LIVE","H":"","I":""},"explanation":"Line n1 creates a String [] object of 4 elements and arr refers to this array object. arr[0] = \"L\", arr[1] = \"I\", arr[2] = \"V\" and arr[3] = \"E\".\n\ni = -2.\n\nBoolean expression of Line n2: i++ == -1\n\n=> (i++) == -1 //As Post-increment operator ++ has higher precedence over ==\n\n=> -2 == -1 //i = -1, value of i is used in the expression and then incremented.\n\n=> false and hence Line n3 is not executed.\n\nBut there is no issue with Line n3 and it compiles successfully.\n\n\n\nBoolean expression of Line n4 is evaluated next:\n\n--i == -2 //i = -1\n\n=> (--i) == -2 //As Pre-decrement operator -- has higher precedence over ==\n\n=> -2 == -2 //i = -2, value of i is decremented first and then used in the expression.\n\n=> true and hence Line n5 is executed next.\n\n\n\nLine n5:\n\narr[-++i] = \"O\"; //i = -2\n\n=> arr[-(++i)] = \"O\"; //Unary minus '-' and pre-increment '++' operators have same precedence\n\n=> arr[-(-1)] = \"O\"; //i = -1, value of i is incremented first and then used in the expression.\n\n=> arr[1] = \"O\"; //2nd array element is changed to \"O\".\n\nHence after Line n5, arr refers to {\"L\", \"O\", \"V\", \"E\"}\n\n\n\nGiven loop prints LOVE on to the console."},{"id":23,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \ninterface Profitable {\n    double profitPercentage = 42.0;\n}\n \nclass Business implements Profitable {\n    double profitPercentage = 50.0; //Line n1\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Profitable obj = new Business(); //Line n2\n        System.out.println(obj.profitPercentage); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"Line n2 causes compilation error","B":"Test class compiles successfully and on execution prints 42.0 on to the console","C":"Line n3 causes compilation error","D":"Test class compiles successfully and on execution prints 50.0 on to the console","E":"Line n1 causes compilation error","F":"","G":"","H":"","I":""},"explanation":"'profitPercentage' variable of Profitable interface is implicitly public, static and final.\n\nLine n1 defines the instance variable 'profitPercentage' of Business class. There is no error at Line n1.\n\nSuper type reference variable can refer to an instance of Sub type, therefore no issues at Line n2 as well.\n\n\n\nEven though correct syntax for accessing interface variable is by using Interface name, such as Profitable.profitPercentage but reference variable also works. obj.profitPercentage doesn't cause any compilation error.\n\nAs, obj is of Profitable type, hence obj.profitPercentage points to the 'profitPercentage' variable of Profitable type. Given code compiles successfully and on execution prints 42.0 on to the console."},{"id":27,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            try {\n                System.out.println(args[1]); //Line n1\n            } catch(RuntimeException e) {\n                System.out.print(\"INHALE-\"); //Line n2\n                throw e; //Line n3\n            } finally {\n                System.out.print(\"EXHALE-\"); //Line n4\n            }\n        } catch(RuntimeException e) {\n            System.out.print(\"INHALE-\"); //Line n5\n        } finally {\n            System.out.print(\"EXHALE\"); //Line n6\n        }\n    }\n}\n\n\nAnd the commands:\n\njavac Test.java\n\njava Test\n\n\n\nWhat is the result?","type":"Single Choice","answer":"B","answers":{"A":"INHALE-EXHALE-","B":"INHALE-EXHALE-INHALE-EXHALE","C":"INHALE-EXHALE","D":"INHALE-EXHALE-INHALE-","E":"INHALE-EXHALE-EXHALE","F":"","G":"","H":"","I":""},"explanation":"As command-line argument is not passed, hence Line n1 throws ArrayIndexOutOfBoundsException (subclass of RuntimeException), handler is available in inner catch block, it executes Line n1 and prints INHALE- on to the console. \n\nthrow e; re-throws the exception. \n\n\n\nBut before exception instance is forwarded to outer catch-block, inner finally-block gets executed and prints EXHALE- on to the console. \n\nIn outer try-catch block, handler for RuntimeException is available, so outer catch-block gets executed and prints INHALE- on to the console.\n\nAfter that outer finally-block gets executed and prints EXHALE- on to the console.\n\n\n\nHence, the output is: INHALE-EXHALE-INHALE-EXHALE"},{"id":21,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nclass Car {\n    void speed(Byte val) { //Line n1\n        System.out.println(\"DARK\"); //Line n2\n    } //Line n3\n \n    void speed(byte... vals) {\n        System.out.println(\"LIGHT\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        byte b = 10; //Line n4\n        new Car().speed(b); //Line n5\n    }\n}\n\n\nWhich of the following needs to be done so that LIGHT is printed on to the console?","type":"Single Choice","answer":"A","answers":{"A":"Delete Line n1, Line n2 and Line n3","B":"No changes are required as given code prints LIGHT on execution","C":"Replace Line n4 with byte... b = 10;","D":"Replace Line n5 with new Car().speed((byte...)b);","E":"","F":"","G":"","H":"","I":""},"explanation":"speed method is correctly overloaded in Car class as both the methods have different signature: speed(Byte) and speed(byte...). Please note that there is no rule regarding return type for overloaded methods, return type can be same or different.\n\n\n\n`new Car().speed(b);` tags to speed(Byte) as boxing is preferred over variable arguments. Code as is prints DARK on to the console.\n\n\n\nVariable arguments syntax '...' can be used only for method parameters and not for variable type and type-casting. Hence the option of replacing Line n4 and Line n5 are not correct.\n\n\n\nIf you delete speed(Byte) method, i.e. Line n1, Line n2 and Line n3, then `new Car().speed(b);` would tag to speed(byte...) method and on execution would print LIGHT on to the console."},{"id":26,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int i = 0;\n        for(System.out.print(i++); i < 2; System.out.print(i++)) {\n            System.out.print(i);\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"F","answers":{"A":"Compilation error","B":"01","C":"12","D":"112","E":"012","F":"011","G":"","H":"","I":""},"explanation":"Basic/Regular for loop has following form:\n\nfor ( [ForInit] ; [Expression] ; [ForUpdate] ) {...}\n\n[ForInit] can be local variable initialization or the following expressions:\n\nAssignment\n\nPreIncrementExpression\n\nPreDecrementExpression\n\nPostIncrementExpression\n\nPostDecrementExpression\n\nMethodInvocation\n\nClassInstanceCreationExpression\n\n\n\n[ForUpdate] can be following expressions:\n\nAssignment\n\nPreIncrementExpression\n\nPreDecrementExpression\n\nPostIncrementExpression\n\nPostDecrementExpression\n\nMethodInvocation\n\nClassInstanceCreationExpression\n\n\n\nThe [Expression] must have type boolean or Boolean, or a compile-time error occurs. If [Expression] is left blank, it evaluates to true.\n\n\n\nAll the expressions can be left blank; for(;;) is a valid for loop and it is an infinite loop as [Expression] is blank and evaluates to true.\n\n\n\nIn the given code, for [ForInit] and [ForUpdate], `System.out.print(i++);` is used, which is a method invocation statement and hence a valid statement. Given code compiles fine.\n\n\n\nLet's check the iterations:\n\n1st iteration: [ForInit] expression is executed, 0 is printed on to the console. i = 1. i < 2 evaluates to true, control goes inside the loop's body and execute `System.out.print(i);` statement. 1 is printed on to the console.\n\n2nd iteration: [ForUpdate] expression is executed, 1 is printed on to the console. i = 2. 2 < 2 evaluates to false, control goes out of the for loop. main method ends and program terminates successfully after printing 011 on to the console."},{"id":24,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"1983-06-30\");\n        System.out.println(date.plusMonths(8));\n    }\n}\n\n\nWhat is the result?","type":"Single Choice","answer":"A","answers":{"A":"1984-02-29","B":"2/28/1984","C":"2/28/1983","D":"An exception is thrown at runtime","E":"1983-02-30","F":"1983-02-29","G":"1984-02-30","H":"","I":""},"explanation":"plusMonths(long) method of LocalDate class returns a copy of this LocalDate with the specified number of months added.\n\nThis method adds the specified amount to the months field in three steps:\n\n    Add the input months to the month-of-year field\n\n    Check if the resulting date would be invalid\n\n    Adjust the day-of-month to the last valid day if necessary\n\n\n\nFor the given code,\n\n1983-06-30 plus 8 months would result in the invalid date 1984-02-30. Instead of returning an invalid result, the last valid day of the month, 1984-02-29, is returned.\n\nPlease note, 1984 is leap year and hence last day of February is 29 and not 28."},{"id":20,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void availableSeats() throws SQLException {\n        throw null; //Line 7\n    }\n \n    public static void main(String[] args) {\n        try {\n            availableSeats(); //Line 12\n        } catch(SQLException e) {\n            System.out.println(\"SEATS NOT AVAILABLE\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Line 12 causes compilation failure","B":"Line 7 causes compilation failure","C":"SEATS NOT AVAILABLE is printed on to the console and program terminates successfully","D":"Program ends abruptly","E":"","F":"","G":"","H":"","I":""},"explanation":"Classes in Exception framework are normal java classes, hence null can be used wherever instances of Exception classes are used, so Line 7 compiles successfully.\n\nNo issues with Line 12 as method availableSeats() declares to throw SQLException and main(String []) method code correctly handles it.\n\n\n\nProgram compiles successfully but on execution, NullPointerException is thrown, stack trace is printed on to the console and program ends abruptly.\n\n\n\nIf you debug the code, you would find that internal routine for throwing null exception causes NullPointerException."},{"id":29,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        boolean flag1 = \"Java\" == \"Java\".replace('J', 'J'); //Line n1\n        boolean flag2 = \"Java\" == \"Java\".replace(\"J\", \"J\"); //Line n2\n        System.out.println(flag1 && flag2);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"false","B":"Line n2 causes compilation error","C":"true","D":"Line n1 causes compilation error","E":"","F":"","G":"","H":"","I":""},"explanation":"String class has following two overloaded replace methods:\n\n1. public String replace(char oldChar, char newChar) {}:\n\nReturns a string resulting from replacing all occurrences of oldChar in this string with newChar. If no replacement is done, then source String object is returned. e.g.\n\n\"Java\".replace('a', 'A') --> returns new String object \"JAvA\".\n\n\"Java\".replace('a', 'a') --> returns the source String object \"Java\" (no change).\n\n\"Java\".replace('m', 'M') --> returns the source String object \"Java\" (no change).\n\n\n\n2. public String replace(CharSequence target, CharSequence replacement) {}:\n\nReturns a new String object after replacing each substring of this string that matches the literal target sequence with the specified literal replacement sequence. e.g.\n\n\"Java\".replace(\"a\", \"A\") --> returns new String object \"JAvA\".\n\n\"Java\".replace(\"a\", \"a\") --> returns new String object \"Java\" (it replaces \"a\" with \"a\").\n\n\"Java\".replace(\"m\", \"M\") --> returns the source String object \"Java\" (no change).\n\n\n\nFor Line n1, as both oldChar and newChar are same, hence source String (\"Java\") is returned by `\"Java\".replace('J', 'J');` without any change. flag1 stores true.\n\nFor Line n2, even though target and replacement are same but as \"J\" is found in the source String, hence a new String object \"Java\" is returned by `\"Java\".replace(\"J\", \"J\");` after replacing \"J\" with \"J\". flag2 stores false.\n\nflag1 && flag2 evaluates to false."},{"id":17,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nclass Lock {\n    public void open() {\n        System.out.println(\"LOCK-OPEN\");\n    }\n}\n \nclass Padlock extends Lock {\n    public void open() {\n        System.out.println(\"PADLOCK-OPEN\");\n    }\n}\n \nclass DigitalPadlock extends Padlock {\n    public void open() {\n        /*INSERT*/\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Lock lock = new DigitalPadlock();\n        lock.open();\n    }\n}\n\n\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print LOCK-OPEN on to the console?","type":"Single Choice","answer":"A","answers":{"A":"None of the other options","B":"(Lock)super.open();","C":"super.open();","D":"super.super.open();","E":"((Lock)super).open();","F":"","G":"","H":"","I":""},"explanation":"super.open(); => Using super keyword, you can access methods and variables of immediate parent class, hence if you replace /*INSERT*/ with `super.open();`, then open() method of Padlock class will be invoked.\n\n\n\nsuper.super.open(); => super.super is not allowed in java, it causes compilation error.\n\n\n\n((Lock)super).open(); => Not possible to cast super keyword in java, it causes compilation error.\n\n\n\n(Lock)super.open(); => super.open(); will be evaluated first as dot (.) operator has higher precedence than cast. super.open(); returns void and hence it cannot be casted to Lock. It also causes compilation error.\n\n\n\nIn fact, it is not possible to directly reach to 2 levels, super keyword allows to access methods and variables of immediate parent class only (just 1 level up). Hence, correct answer is: 'None of the other options'"},{"id":30,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below codes of 3 java files:\n\n//Profitable1.java\npackage com.github.oca;\n \npublic interface Profitable1 {\n    default double profit() {\n        return 12.5;\n    }\n}\n\n\n//Profitable2.java\npackage com.github.oca;\n \npublic interface Profitable2 {\n    default double profit() {\n        return 25.5;\n    }\n}\n\n\n//Profit.java\npackage com.github.oca;\n \npublic abstract class Profit implements Profitable1, Profitable2 {\n    /*INSERT*/\n}\n\n\nWhich of the following needs to be done so that there is no compilation error?","type":"Single Choice","answer":"F","answers":{"A":"Replace /*INSERT*/ with below code:\npublic default double profit() {\n    return 50.0;\n}","B":"Replace /*INSERT*/ with below code:\npublic double profit() {\n    return Profitable1.profit();\n}","C":"Replace /*INSERT*/ with below code:\ndouble profit() {\n    return 50.0;\n}","D":"No need for any modifications, code compiles as is","E":"Replace /*INSERT*/ with below code:\nprotected double profit() {\n    return 50.0;\n}","F":"Replace /*INSERT*/ with below code:\npublic double profit() {\n    return Profitable2.super.profit();\n}","G":"","H":"","I":""},"explanation":"Profit class causes compilation error as it complains about duplicate default methods: Profitable1.profit() and Profitable2.profit(). To rectify this error abstract class Profit must override the profit() method.\n\n\n\ndefault keyword for method is allowed only inside the interface and default methods are implicitly public. So overriding method should use public modifier and shouldn't use default keyword.\n\nIf you want to invoke the default method implementation from the overriding method, then the correct syntax is: [Interface_name].super.[default_method_name].\n\nHence, `Profitable1.super.profit();` will invoke the default method of Profitable1 interface and `Profitable2.super.profit();` will invoke the default method of Profitable2 interface.\n\n\n\nBased on above points, let's check all the options one by one:\n\nNo need for any modifications, code compiles as is: ✗\n\n\n\nReplace /*INSERT*/ with below code:\n\ndouble profit() {\n\n    return 50.0;\n\n}: ✗\n\nprofit() method must be declared with public access modifier.\n\n\n\nReplace /*INSERT*/ with below code:\n\npublic default double profit() {\n\n    return 50.0;\n\n}: ✗\n\ndefault keyword for method is allowed only inside the interface.\n\n\n\nReplace /*INSERT*/ with below code:\n\nprotected double profit() {\n\n    return 50.0;\n\n}: ✗\n\nprofit() method must be declared with public access modifier.\n\n\n\nReplace /*INSERT*/ with below code:\n\npublic double profit() {\n\n    return Profitable1.profit();\n\n}: ✗\n\nProfitable1.profit(); causes compilation error as correct syntax is: Profitable1.super.profit();\n\n\n\nReplace /*INSERT*/ with below code:\n\npublic double profit() {\n\n    return Profitable2.super.profit();\n\n}: ✓\n\nIt compiles successfully."},{"id":25,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nclass Parent {\n    int var = 1000; // Line n1\n \n    int getVar() {\n        return var;\n    }\n}\n \nclass Child extends Parent {\n    private int var = 2000; // Line n2\n \n    int getVar() {\n        return super.var; //Line n3\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Child obj = new Child(); // Line n4\n        System.out.println(obj.var); // Line n5\n    }\n}\n\n\nThere is a compilation error in the code.\n\nWhich three modifications, done independently, print 1000 on to the console?","type":"Multiple Choice","answer":"A,D,E","answers":{"A":"Change Line n5 to System.out.println(obj.getVar());","B":"Delete the method getVar() from the Child class","C":"Change Line n3 to return var;","D":"Delete the Line n2","E":"Change Line n4 to Parent obj = new Child();","F":"Change Line n1 to private int var = 1000;","G":"","H":"","I":""},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n2 hides the variable created at Line n1, there is no rules related to hiding (type and access modifier can be changed).\n\n\n\nLine n5 causes compilation error as obj is of Child type and 'var' is declared private in Child class. Variable 'var' of Child class cannot be accessed outside the Child class.\n\n\n\nLet's check all the options one by one:\n\n'Change Line n1 to private int var = 1000;' => It will not rectify the existing error of Line n5, in fact after this change, Line n3 will also cause compilation error.\n\n\n\n'Delete the Line n2' => After deleting this line, obj.var at Line n5 will refer to variable 'var' of Parent class. Hence, output will be 1000 in this case.\n\n\n\n'Change Line n3 to return var;' => This will have no effect to the output of the code, as getVar() method has not been invoked.\n\n\n\n'Change Line n4 to Parent obj = new Child();' => After this modification, obj becomes Parent type, hence obj.var will refer to variable 'var' of Parent class. Hence, output will be 1000 in this case.\n\n\n\n'Delete the method getVar() from the Child class' => This will have no effect to the output of the code, as getVar() method has not been invoked.\n\n\n\n'Change Line n5 to System.out.println(obj.getVar());' => obj.getVar() will invoke the getVar() method of Child class and this method returns the variable value from Parent class (super.var). Hence, output will be 1000 in this case."},{"id":34,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code snippet:\n\ninterface ILog {\n    default void log() {\n        System.out.println(\"ILog\");\n    }\n}\n \nabstract class Log {\n    public static void log() { \n        System.out.println(\"Log\");\n    }\n}\n \nclass MyLogger extends Log implements ILog {}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"A","answers":{"A":"There is a compilation error in MyLogger class","B":"There is a compilation error in interface Ilog","C":"There is no compilation error in the above code","D":"There is a compilation error in abstract class Log","E":"","F":"","G":"","H":"","I":""},"explanation":"As per Java 8, default and static methods were added in the interface. Interface ILog defines default method log(), there is no compilation error in interface ILog.\n\n\n\nAbstract class Log defines the static log() method. Abstract class can have 0 or more abstract methods. Hence, no compilation error in class Log as well.\n\n\n\nDefault methods of an interface are implicitly public and are inherited by the implementer class. Class MyLogger implements ILog interface and therefore it inherits the default log() method of ILog interface.\n\nAlso, the scope of static log() method of abstract class Log is not limited to class Log only but MyLogger also gets Log.log() method in its scope.\n\nSo, MyLogger class has instance method log() [inherited from ILog interface] and static method log() [from Log class] and this causes conflict. Static and non-static methods with same signature are not allowed in one scope, therefore class Log fails to compile."},{"id":28,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below codes of 3 java files:\n\n//Sellable.java\npackage com.github.oca;\n \npublic interface Sellable {\n    double getPrice();\n    \n    default String symbol() {\n        return \"$\";\n    }\n}\n\n\n//Chair.java\npackage com.github.oca;\n \npublic class Chair implements Sellable {\n    public double getPrice() {\n        return 35;\n    }\n    \n    public String symbol() {\n        return \"£\";\n    }\n}\n\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Sellable obj = new Chair(); //Line n1\n        System.out.println(obj.symbol() + obj.getPrice()); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Compilation error in Test class","B":"It compiles successfully and on execution prints $35.00 on to the console","C":"It compiles successfully and on execution prints £35.0 on to the console","D":"It compiles successfully and on execution prints $35 on to the console","E":"It compiles successfully and on execution prints £35.00 on to the console","F":"It compiles successfully and on execution prints $35.0 on to the console","G":"It compiles successfully and on execution prints £35 on to the console","H":"Compilation error in Chair class","I":""},"explanation":"default methods were added in Java 8. Class Chair correctly implements Sellable interface and it also overrides the default symbol() method of Sellable interface.\n\n\n\nAt Line n1, 'obj' refers to an instance of Chair class, so obj.symbol() and obj.getPrice() invoke the overriding methods of Chair class only.\n\nobj.symbol() returns \"£\" and obj.getPrice() returns 35.0\n\n\n\nAt Line n2, '+' operator behaves as concatenation operator and Line n2 prints £35.0 on to the console."},{"id":31,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        P p = new R(); //Line n1\n        System.out.println(p.compute(\"Go\")); //Line n2\n    }\n}\n \nclass P {\n    String compute(String str) {\n        return str + str + str;\n    }\n}\n \nclass Q extends P {\n    String compute(String str) {\n        return super.compute(str.toLowerCase());\n    }\n}\n \nclass R extends Q {\n    String compute(String str) {\n        return super.compute(str.replace('o', 'O')); //2nd argument is uppercase O\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"GoGoGo","B":"GO","C":"gogogo","D":"Go","E":"go","F":"GOGOGO","G":"gOgOgO","H":"","I":""},"explanation":"Class Q correctly overrides the compute(String) method of P class and class R correctly overrides the compute(String) method of Q class. Keyword super is used to invoke the method of parent class.\n\n\n\nAt Line n1, reference variable 'p' refers to an instance of class R, hence p.compute(\"Go\") invokes the compute(String) method of R class.\n\nreturn super.compute(str.replace('o', 'O')); => return super.compute(\"Go\".replace('o', 'O')); => return super.compute(\"GO\");\n\n\n\nIt invokes the compute(String) method of Parent class, which is Q.\n\n=> return super.compute(str.toLowerCase()); => return super.compute(\"GO\".toLowerCase()); => return super.compute(\"go\");\n\n\n\nIt invokes the compute(String) method of Parent class, which is P.\n\n=> return str + str + str; => return \"gogogo\";\n\n\n\nControl goes back to compute(String) method of Q and to the compute(String) method of R, which returns \"gogogo\".\n\nLine n2 prints gogogo on to the console."},{"id":36,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        /*INSERT*/ x = 7, y = 200;\n        System.out.println(String.valueOf(x + y).length());\n    }\n}\n\n\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print 3 on to the console?\n\nSelect 3 options.","type":"Multiple Choice","answer":"A,B,E","answers":{"A":"short","B":"long","C":"float","D":"double","E":"int","F":"byte","G":"","H":"","I":""},"explanation":"Compound declarations are allowed in Java for primitive type and reference type.\n\n\n\nRange of byte data type is from -128 to 127, hence if byte is used to replace /*INSERT*/, then y = 200 would cause compilation error as 200 is out of range value for byte type. Hence, byte cannot be used to replace /*INSERT*/.\n\n\n\nshort, int, long, float & double can replace /*INSERT*/ without causing any error. x + y will evaluate to 207 for short, int and long types whereas, x  + y will evaluate to 207.0 for float and double types.\n\nString class has overloaded valueOf methods for int, char, long, float, double, boolean, char[] and Object types. valueOf method returns the corresponding String object and length() method returns number of characters in the String object.\n\nSo, `String.valueOf(x + y).length()` in case of short, int and long returns 3, on the other hand, in case of float and double it would return 5.\n\n\n\nHence, only 3 options (short, int and long) print expected output on to the console."},{"id":32,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given below code fragment:\n\npackage com.github.oca;\n \nabstract class Food {\n    protected abstract double getCalories();\n}\n \nclass JunkFood extends Food {\n    double getCalories() {\n        return 200.0;\n    }\n}\n\n\nWhich 3 modifications, done independently, enable the code to compile?","type":"Multiple Choice","answer":"B,D,F","answers":{"A":"Make the getCalories() method of Food class private","B":"Make the getCalories() method of JunkFood class public","C":"Make the getCalories() method of Food class public","D":"Remove the protected access modifier from the getCalories() method of Food class","E":"Make the getCalories() method of JunkFood class private","F":"Make the getCalories() method of JunkFood class protected","G":"","H":"","I":""},"explanation":"abstract methods cannot be declared with private modifier as abstract methods need to be overridden in child classes.\n\nabstract methods can be declared with either public, protected and package (no access modifier) modifier and hence overriding method cannot be declared which private modifier in the child class. That is why getCalories() method in Food and JunkFood classes cannot be declared private.\n\n\n\nAccess modifier of overriding method should either be same as the access modifier of overridden method or it should be less restrictive than the access modifier of overridden method. Hence below solutions will work:\n\n1. Remove the protected access modifier from the getCalories() method of Food class: By doing this, both the overridden and overriding methods will have same access modifier (no access modifier)\n\nor\n\n2. Make the getCalories() method of JunkFood class protected: By doing this, both the overridden and overriding methods will have same access modifier (protected)\n\nor\n\n3. Make the getCalories() method of JunkFood class public: By doing this, access modifier of overriding method (which is public) is less restrictive than the access modifier of overridden method (which is protected)"},{"id":33,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below codes of 2 java files:\n\n//Counter.java\npackage com.github.oca;\n \npublic interface Counter {\n    int count = 10; //Line n1\n}\n\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Counter [] arr = new Counter[2]; //Line n2\n        for(Counter ctr : arr) {\n            System.out.print(ctr.count); //Line n3\n        }\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"F","answers":{"A":"Only Line n3 causes compilation error","B":"Line n1 and Line n2 cause compilation error","C":"Only Line n2 causes compilation error","D":"Only Line n1 causes compilation error","E":"Line n3 throws an exception at runtime","F":"Test class compiles successfully and on execution prints 1010 on to the console","G":"","H":"","I":""},"explanation":"Variable 'count' declared inside interface Counter is implicitly public, static and final. Line n1 compiles successfully.\n\nLine n2 creates one dimensional array of 2 elements of Counter type and both the elements are initialized to null. Line n2 compiles successfully.\n\nThough correct way to refer static variable is by using the type name, such as Counter.count but it can also be invoked by using Counter reference variable. Hence ctr.count at Line n3 correctly points to the count variable at Line n1.\n\nFor invoking static fields, object is not needed, therefore even if 'ctr' refers to null, ctr.count doesn't throw NullPoionterException. Given loop executes twice and therefore output is: 1010"},{"id":35,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below codes of 4 java files:\n\n//Moveable.java\npackage com.github.oca;\n \npublic interface Moveable {\n    void move();\n}\n\n\n//Animal.java\npackage com.github.oca;\n \npublic abstract class Animal {\n    void move() {\n        System.out.println(\"ANIMAL MOVING\");\n    }\n}\n\n\n//Dog.java\npackage com.github.oca;\n \npublic class Dog extends Animal implements Moveable {}\n\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Moveable moveable = new Dog();\n        moveable.move();\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"C","answers":{"A":"There is a compilation error in Test.java file","B":"There is no compilation error and on execution, Test class prints ANIMAL MOVING on to the console","C":"There is a compilation error in Dog.java file","D":"There is a compilation error in Animal.java file","E":"","F":"","G":"","H":"","I":""},"explanation":"Method move() declared in Moveable interface is implicitly public and abstract.\n\nAbstract class Animal has non-abstract method move() and it is declared with no modifier (package scope). Abstract class in java can have 0 or more abstract methods. Hence Animal class compiles successfully.\n\nclass Dog extends Animal and as both the classes Animal and Dog are within the same package 'com.github.oca', Dog inherits the move() method defined in Animal class.\n\nDog class implements Moveable interface as well, therefore it must implement public move() method as well. But as inherited move() method from Animal class is not public, therefore Dog class fails to compile."},{"id":42,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nclass M {\n    public void main(String[] args) { //Line n1\n        System.out.println(\"M\");\n    }\n}\n \nclass N extends M {\n    public static void main(String[] args) { //Line n2\n        new M().main(args); //Line n3\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        N.main(args); //Line n4\n    }\n}\n\n\nWhich of the following statements is true for above code?","type":"Single Choice","answer":"E","answers":{"A":"Line n4 causes compilation error","B":"Line n3 causes compilation error","C":"Line n1 causes compilation error","D":"It executes successfully and prints M on to the console","E":"Line n2 causes compilation error","F":"","G":"","H":"","I":""},"explanation":"The static method of subclass cannot hide the instance method of superclass. static main(String []) method at Line n2 tries to hide the instance main(String []) method at Line n1 and hence Line n2 causes compilation error.\n\n\n\nThere is no issue with Line n3 as it is a valid syntax to invoke the instance main(String []) method of M class.\n\n\n\nNo issue with Line n4 as well as it correctly invokes static main(String []) method of N class."},{"id":40,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of TestBook.java file:\n\npackage com.github.oca;\n \nclass Book {\n    private String name;\n    private String author;\n    \n    Book() {}\n    \n    Book(String name, String author) {\n        name = name;\n        author = author;\n    }\n    \n    String getName() {\n        return name;\n    }\n    \n    String getAuthor() {\n        return author;\n    }\n}\n \npublic class TestBook {\n    public static void main(String[] args) {\n        private Book book = new Book(\"Head First Java\", \"Kathy Sierra\");\n        System.out.println(book.getName());\n        System.out.println(book.getAuthor());\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error in TestBook class","B":"Compilation error in Book class","C":"null\nnull","D":"Head First Java\nKathy Sierra","E":"","F":"","G":"","H":"","I":""},"explanation":"Variable 'book' in main(String[]) method of TestBook class cannot be declared private as it is a local variable. Hence, there is a compilation error in TestBook class. \n\nOnly final modifier can be used with local variables."},{"id":41,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String s1 = \"OCP\";\n        String s2 = \"ocp\";\n        System.out.println(/*INSERT*/);\n    }\n}\n\n\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print true on to the console?\n\nSelect 2 options.","type":"Multiple Choice","answer":"A,D","answers":{"A":"s1.equalsIgnoreCase(s2)","B":"s1.equals(s2.toUpper())","C":"s2.equals(s1.toLower())","D":"s1.length() == s2.length()","E":"s1.contentEquals(s2)","F":"s1.equals(s2)","G":"","H":"","I":""},"explanation":"Let's check all the statements one by one:\n\n\n\ns1.equals(s2): equals(String) method of String class matches two String objects and it takes character's case into account while matching. Alphabet A in upper case and alphabet a in lower case are not equal according to this method. As String objects referred by s1 and s2 have different cases, hence output is false.\n\n\n\ns1.equals(s2.toUpper()): Compilation error as there is no toUpper() method available in String class. Correct method name is: toUpperCase().\n\n\n\ns2.equals(s1.toLower()): Compilation error as there is no toLower() method available in String class. Correct method name is: toLowerCase().\n\n\n\ns1.length() == s2.length(): length() method returns the number of characters in the String object. s1.length() returns 3 and s2.length() also returns 3, hence output is true.\n\n\n\ns1.equalsIgnoreCase(s2): Compares s1 and s2, ignoring case consideration and hence returns true.\n\n\n\ns1.contentEquals(s2): String class contains two methods: contentEquals(StringBuffer) and contentEquals(CharSequence). Please note that String, StringBuilder and StringBuffer classes implement CharSequence interface, hence contentEquals(CharSequence) method defined in String class can be invoked with the argument of either String or StringBuilder or StringBuffer. In this case, it is invoked with String argument and hence it is comparing the contents of two String objects. This method also takes character's case into account while matching. As String objects referred by s1 and s2 have different cases, hence output is false."},{"id":39,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \nclass Super {\n    void Super() {\n        System.out.print(\"KEEP_\");\n    }\n}\n \nclass Base extends Super {\n    Base() {\n        Super();\n        System.out.print(\"GOING_\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        new Base();\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"D","answers":{"A":"It prints GOING_ on to the console","B":"It prints KEEP_KEEP_GOING_ on to the console","C":"Compilation Error in Super class","D":"It prints KEEP_GOING_ on to the console","E":"Compilation Error in Base class","F":"It prints GOING_KEEP_ on to the console","G":"Compilation Error in Test class","H":"","I":""},"explanation":"Super class defines a method with name Super() but not any constructor. Hence compiler adds below default constructor in Super class:\n\nSuper() {\n\n    super();\n\n}\n\nClass Super extends from Object class and Object class has no-argument constructor, which is called by the super(); statement in above default constructor.\n\n\n\nJava compiler also adds `super();` as the first statement inside the no-argument constructor of Base class:\n\nBase() {\n\n    super();\n\n    Super();\n\n    System.out.print(\"GOING_\");\n\n}\n\n\n\nAs Base extends Super and both the classes are in the same package, hence `super();` invokes the no-argument constructor of Super class and `Super();` invokes the Super() method of Super class. Base class inherits the Super() method of Super class.\n\n\n\nNo compilation error in any of the classes.\n\n\n\nOn executing Test class, main(String[]) is invoked, which executes `new Base();` statement.\n\nNo-argument constructor of Base class is invoked, which executes `super();`, hence no-argument constructor of Super class is invoked.\n\nNext, `Super();` is executed and this invokes the Super() method of Super class and hence KEEP_ is printed on to the console.\n\nAfter that, `System.out.print(\"GOING_\");` is executed and GOING_ is printed on to the console.\n\n\n\nmain(String []) method finishes its execution and program terminates successfully after printing KEEP_GOING_ on to the console."},{"id":37,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int a = 3;\n        int b = 5;\n        int c = 7;\n        int d = 9;\n        boolean res = --a + --b < 1 && c++ + d++ > 1;\n        System.out.printf(\"a = %d, b = %d, c = %d, d = %d, res = %b\", a, b, c, d, res);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"a = 2, b = 4, c = 7, d = 9, res = false","B":"a = 3, b = 5, c = 8, d = 10, res = true","C":"a = 2, b = 4, c = 8, d = 10, res = true","D":"a = 2, b = 4, c = 8, d = 10, res = false","E":"a = 2, b = 4, c = 7, d = 9, res = true","F":"a = 3, b = 5, c = 8, d = 10, res = false","G":"","H":"","I":""},"explanation":"Given expression:\n\n--a + --b < 1 && c++ + d++ > 1;\n\n--a + --b < 1 && (c++) + (d++) > 1; //postfix has got highest precedence\n\n(--a) + (--b) < 1 && (c++) + (d++) > 1; //prefix comes after postfix\n\n{(--a) + (--b)} < 1 && {(c++) + (d++)} > 1; //Then comes binary +. Though parentheses are used but I used curly brackets, just to explain.\n\n[{(--a) + (--b)} < 1] && [{(c++) + (d++)} > 1]; //Then comes relational operator (<,>). I used square brackets instead of parentheses.\n\nThis expression is left with just one operator, && and this operator is a binary operator so works with 2 operands, left operand [{(--a) + (--b)} < 1] and right operand [{(c++) + (d++)} > 1]\n\nLeft operand of && must be evaluated first, which means [{(--a) + (--b)} < 1] must be evaluated first.\n\n\n\n[{2 + (--b)} < 1] && [{(c++) + (d++)} > 1]; //a=2, b=5, c=7, d=9\n\n[{2 + 4} < 1] && [{(c++) + (d++)} > 1]; //a=2, b=4, c=7, d=9\n\n[6 < 1] && [{(c++) + (d++)} > 1];\n\nfalse && [{(c++) + (d++)} > 1];\n\n\n\n&& is short circuit operator, hence right operand is not evaluated and false is returned.\n\n\n\nOutput of the given program is: a = 2, b = 4, c = 7, d = 9, res = false"},{"id":47,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    private static void div(int i, int j) {\n        try {\n            System.out.println(i / j);\n        } catch(ArithmeticException e) {\n            Exception ex = new Exception(e);\n            throw ex;\n        }\n    }\n    public static void main(String[] args) {\n        try {\n            div(5, 0);\n        } catch(Exception e) {\n            System.out.println(\"END\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"END is printed and program terminates abruptly","B":"END is printed and program terminates successfully","C":"Compilation error","D":"END is not printed and program terminates abruptly","E":"","F":"","G":"","H":"","I":""},"explanation":"throw ex; causes compilation error as div method doesn't declare to throw Exception (checked) type."},{"id":46,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void m() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            throw e;\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            m();\n        } catch(SQLException e) {\n            System.out.println(\"CAUGHT SUCCESSFULLY\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"Program ends abruptly","B":"CAUGHT SUCCESSFULLY is printed on to the console and program terminates successfully","C":"Method main(String []) causes compilation error","D":"Method m() causes compilation error","E":"","F":"","G":"","H":"","I":""},"explanation":"Even though it seems like method m() will not compile successfully, but starting with JDK 7, it is allowed to use super class reference variable in throw statement referring to sub class Exception object.\n\n\n\nIn this case, method m() throws SQLException and compiler knows that variable e (Exception type) refers to an instance of SQLException only and hence allows it.\n\n\n\nProgram executes successfully and prints CAUGHT SUCCESSFULLY on to the console."},{"id":38,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nclass X {\n    void greet() {\n        System.out.println(\"Good Morning!\");\n    }\n}\n \nclass Y extends X {\n    void greet() {\n        System.out.println(\"Good Afternoon!\");\n    }\n}\n \nclass Z extends Y {\n    void greet() {\n        System.out.println(\"Good Night!\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        X x = new Z();\n        x.greet(); //Line n1\n        ((Y)x).greet(); //Line n2\n        ((Z)x).greet(); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"C","answers":{"A":"Compilation error","B":"An exception is thrown at runtime","C":"It compiles successfully and on execution prints below:\nGood Night!\nGood Night!\nGood Night!","D":"It compiles successfully and on execution prints below:\nGood Night!\nGood Afternoon!\nGood Morning!","E":"It compiles successfully and on execution prints below:\nGood Morning!\nGood Morning!\nGood Morning!","F":"","G":"","H":"","I":""},"explanation":"Variable x is of X type (superclass) and refers to an instance of Z type (subclass).\n\nAt Line n1, compiler checks whether greet() method is available in class X or not. As greet() method is available in class X, hence no compilation error for Line n1.\n\nAt Line n2, x is casted to Y and compiler checks whether greet() method is available in class Y or not. As greet() method is available in class Y, hence no compilation error for Line n2.\n\nAt Line n3, x is casted to Z and compiler checks whether greet() method is available in class Z or not. As greet() method is available in class Z, hence no compilation error for Line n3.\n\n\n\nThere is no compilation error in the given code it compiles successfully.\n\n\n\nVariable x refers to an instance of Z class and at Line n1, n2 and n3 same instance is being used. Which overriding method to invoke, is decided at runtime based on the instance.\n\nAt runtime, all three statements, at Line n1, Line n2 and Line n3 would invoke the greet() method of Z class, which would print Good Night! three times on to the console."},{"id":43,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        byte b = 10;\n        list.add(b); //Line n1\n        int mul = list.get(0) * list.get(0); //Line n2\n        System.out.println(mul);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"10","B":"100","C":"An exception is thrown at runtime","D":"Line n1 causes compilation error","E":"Line n2 causes compilation error","F":"","G":"","H":"","I":""},"explanation":"list is of Integer type and variable 'b' is of byte type.\n\nAt Line n1, b is auto-boxed to Byte and not Integer and List<Integer> can't store Byte objects, therefore Line n1 causes compilation error.\n\n\n\nlist.get(0) returns Integer and `list.get(0) * list.get(0)` is evaluated to int, and variable 'mul' is of int type only. Therefore, Line n2 compiles successfully."},{"id":50,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code snippet:\n\ninterface Workable {\n    void work();\n}\n \n/*INSERT*/ {\n    public void work() {} //Line n1\n}\n\n\nAnd the statements:\n\n1. abstract class Work implements Workable\n\n2. class Work implements Workable\n\n3. interface Work extends Workable\n\n4. abstract interface Work extends Workable\n\n5. abstract class Work\n\n\n\nHow many statements can replace /*INSERT*/ such that there is no compilation error?","type":"Single Choice","answer":"E","answers":{"A":"One statement","B":"Two statements","C":"Five statements","D":"Four statements","E":"Three statements","F":"","G":"","H":"","I":""},"explanation":"/*INSERT*/ cannot be replaced with interface as work() method at Line n1 is neither abstract nor default. Hence, statements 3 and 4 will not work.\n\nLet's check other statements:\n\n1. abstract class Work implements Workable: abstract class in java can have 0 or more abstract methods. It compiles successfully.\n\n2. class Work implements Workable: It correctly implements the work() method of Workable interface, hence it compiles successfully.\n\n5. abstract class Work: abstract class in java can have 0 or more abstract methods. It compiles successfully.\n\n\n\nHence, out of 5 statements, 3 will compile successfully."},{"id":48,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \nclass Shape {\n    int side = 0; //Line n1\n \n    int getSide() { //Line n2\n        return side;\n    }\n}\n \nclass Square extends Shape {\n    private int side = 4; //Line n3\n \n    protected int getSide() { //Line n4\n        return side;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Shape s = new Square();\n        System.out.println(s.side + \":\" + s.getSide());\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"C","answers":{"A":"Compilation error at Line n3","B":"0:0","C":"0:4","D":"4:4","E":"Compilation error at Line n4","F":"4:0","G":"","H":"","I":""},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n3 hides the variable created at Line n1 and Line n4 overrides the getSide() method of Line n2. There is no compilation error for Square class as it correctly overrides getSide() method. You can use any access modifier at Line n3 as well, there are no rules for variable hiding.\n\n\n\n's' is of Shape type, hence s.side equals to 0 and s.getSide() invokes overriding method of Square class and it returns 4. Hence output is: 0:4."},{"id":49,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Below is the code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    /* INSERT */\n}\nBelow are the definitions of main method:\n\n1.\n\npublic static final void main(String... a) {\n    System.out.println(\"Java Rocks!\");\n}\n\n\n2.\n\npublic void main(String... args) {\n    System.out.println(\"Java Rocks!\");\n}\n\n\n3.\n\nstatic void main(String [] args) {\n    System.out.println(\"Java Rocks!\");\n}\n\n\n4.\n\npublic static void main(String [] args) {\n    System.out.println(\"Java Rocks!\");\n}\n\n\n5.\n\npublic static void main(String args) {\n    System.out.println(\"Java Rocks!\");\n}\n\n\nHow many definitions of main method can replace /* INSERT */ such that on executing Test class, \"Java Rocks!\" is printed on to the console?","type":"Single Choice","answer":"C","answers":{"A":"Only four definitions","B":"All 5 definitions","C":"Only two definitions","D":"Only one definition","E":"Only three definitions","F":"","G":"","H":"","I":""},"explanation":"Special main method (called by JVM on execution) should be static and should have public access modifier. It also takes argument of String [] type (Varargs syntax String... can also be used).\n\nString [] or String... argument can use any identifier name, even though in most of the cases you will see \"args\" is used.\n\nfinal modifier can be used with this special main method.\n\nHence, from the given five definitions of main method, below two definitions will print expected output on to the console.\n\npublic static final void main(String... a) {\n\n    System.out.println(\"Java Rocks!\");\n\n}\n\nand\n\npublic static void main(String [] args) {\n\n    System.out.println(\"Java Rocks!\");\n\n}"},{"id":44,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npublic class Test {\n    public static void main(String[] args) {\n        args[1] = \"Day!\";\n        System.out.println(args[0] + \" \" + args[1]);\n    }\n}\n\n\nAnd the commands:\n\njavac Test.java\n\njava Test Good\n\n\n\nWhat is the result?","type":"Single Choice","answer":"B","answers":{"A":"Compilation Error","B":"An exception is thrown at runtime","C":"Good","D":"Good Day!","E":"","F":"","G":"","H":"","I":""},"explanation":"public static void main(String[] args) method is invoked by JVM.\n\nVariable args is initialized and assigned with Program arguments. For example,\n\njava Test: args refers to String [] of size 0.\n\njava Test Hello: args refers to String [] of size 1 and 1st array element refers to \"Hello\"\n\njava Test 1 2 3: args refers to String [] of size 3 and 1st array element refers to \"1\", 2nd array element refers to \"2\" and 3rd array element refers to \"3\".\n\n\n\nCommand used in this question: java Test Good, so args refers to String[] of size 1 and element at 0th index is \"Good\".\n\nargs[1] = \"Day!\"; is trying to access 2nd array element at index 1, which is not available and hence an exception is thrown at runtime."},{"id":45,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of TestSquare.java file:\n\npackage com.github.oca;\n \nclass Square {\n    int length;\n    Square sq;\n    \n    Square(int length) {\n        this.length = length;\n    }\n    \n    void setInner(Square sq) {\n        this.sq = sq;\n    }\n    \n    int getLength() {\n        return this.length;\n    }\n}\n \npublic class TestSquare {\n    public static void main(String[] args) {\n        Square sq1 = new Square(10); //Line n1\n        Square sq2 = new Square(5); //Line n2\n        sq1.setInner(sq2); //Line n3\n        System.out.println(sq1.sq.length); //Line n4\n    }\n}\n\n\nWhat will be the result of compiling and executing TestSquare class?","type":"Single Choice","answer":"D","answers":{"A":"It prints 10 on to the console","B":"An exception is thrown at runtime","C":"Compilation error","D":"It prints 5 on to the console","E":"It prints null on to the console","F":"It prints 0 on to the console","G":"","H":"","I":""},"explanation":"As both the classes: Square and TestSquare are in the same file, hence variables 'length' and 'sq' can be accessed using dot operator. Given code compiles successfully.\n\n\n\nLine n1 creates an instance of Square class and 'sq1' refers to it. sq1.length = 10 and sq1.sq = null.\n\nLine n2 creates an instance of Square class and 'sq2' refers to it. sq2.length = 5 and sq2.sq = null.\n\n\n\nOn execution of Line n3, sq1.sq = sq2.\n\n\n\nLine n4: System.out.println(sq1.sq.length); => System.out.println(sq2.length); => Prints 5 on to the console."},{"id":55,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nclass Base {\n    static void print() { //Line n1\n        System.out.println(\"BASE\");\n    }\n}\n \nclass Derived extends Base {\n    static void print() { //Line n2\n        System.out.println(\"DERIVED\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base b = null;\n        Derived d = (Derived) b; //Line n3\n        d.print(); //Line n4\n    }\n}\n\n\nWhich of the following statements is true for above code?","type":"Single Choice","answer":"A","answers":{"A":"Code compiles successfully and on execution prints DERIVED on to the console","B":"Code compiles successfully and on execution prints BASE on to the console","C":"Line n3 causes compilation error","D":"Code compiles successfully and on execution Line n3 throws an exception","E":"Line n4 causes compilation error","F":"Line n2 causes compilation error","G":"","H":"","I":""},"explanation":"print() method at Line n2 hides the method at Line n1. So, no compilation error at Line n2.\n\n\n\nReference variable 'b' is of type Base, so `(Derived) b` does not cause any compilation error. Moreover, at runtime it will not throw any ClassCastException as well because b is null. Had 'b' been referring to an instance of Base class [Base b = new Base();], `(Derived) b` would have thrown ClassCastException.\n\n\n\nd.print(); doesn't cause any compilation error but as this syntax creates confusion, so it is not a good practice to access the static variables or static methods using reference variable, instead class name should be used. Derived.print(); is the preferred syntax.\n\n\n\nd.print(); invokes the static print() method of Derived class and prints DERIVED on to the console."},{"id":53,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String word = \"REBUS\";\n        /* INSERT */\n        System.out.println(word);\n    }\n}\n\n\nFollowing options are available to replace /*INSERT*/:\n\n1. word = word.substring(2);\n\n2. word = word.substring(2, 4);\n\n3. word = word.substring(2, 5);\n\n4. word = word.replace(\"RE\", \"\");\n\n5. word = word.substring(2, 6);\n\n6. word = word.delete(0, 2);\n\n\n\nHow many of the above options can be used to replace /*INSERT*/ (separately and not together) such that given command prints BUS on to the console?","type":"Single Choice","answer":"B","answers":{"A":"Five options only","B":"Three options only","C":"One option only","D":"All 6 options","E":"Two options only","F":"Four options only","G":"","H":"","I":""},"explanation":"substring(int beginIndex, int endIndex) method of String class extracts the substring, which begins at the specified beginIndex and extends to the character at index endIndex - 1.\n\nThis method throws IndexOutOfBoundsException if the beginIndex is negative, or endIndex is larger than the length of this String object, or beginIndex is larger than endIndex. e.g.\n\n\"freeway\".substring(4, 7) returns \"way\"\n\n\"freeway\".substring(4, 8) throws IndexOutOfBoundsException\n\n\n\nsubstring​(int beginIndex) method of String class extracts the substring, which begins with the character at the specified index and extends to the end of this string.\n\nThis method throws IndexOutOfBoundsException if beginIndex is negative or larger than the length of this String object. e.g.\n\n\"freeway\".substring(4) returns \"way\"\n\n\"freeway\".substring(8) throws IndexOutOfBoundsException\n\n\n\nreplace(CharSequence target, CharSequence replacement) method of String class returns a new String object after replacing each substring of this string that matches the literal target sequence with the specified literal replacement sequence. e.g.\n\n\"Java\".replace(\"a\", \"A\") --> returns new String object \"JAvA\".\n\n\n\nLet's check all the given options:\n\n\"REBUS\".substring(2); [begin = 2, end = 4 (end of the string)], returns \"BUS\" and hence it is a correct option.\n\n\"REBUS\".substring(2, 4); [begin = 2, end = 3 (endIndex - 1)], returns \"BU\" and hence it is incorrect option.\n\n\"REBUS\".substring(2, 5); [begin = 2, end = 4 (endIndex - 1)], returns \"BUS\" and hence it is a correct option.\n\n\"REBUS\".replace(\"RE\", \"\"); It replaces \"RE\" with empty string \"\" and returns \"BUS\", so it is also a correct option.\n\n\"REBUS\".substring(2, 6); Length of \"REBUS\" = 5 and endIndex = 6, which is greater than 5, hence it will thrown IndexOutOfBoundsException at runtime. Incorrect option\n\n\"REBUS\".delete(0, 2); Compilation error as delete(...) method is not available in String class, it is part of StringBuilder class. Incorrect option.\n\n\n\nSo, total 3 options will replace /*INSERT*/ to print BUS on to the console."},{"id":52,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider the code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    private static void m(int i) {\n        System.out.print(1);\n    }\n    \n    private static void m(int i1, int i2) {\n        System.out.print(2);\n    }\n    \n    private static void m(char... args) {\n        System.out.print(3);\n    }\n    \n    public static void main(String... args) {\n        m('A');\n        m('A', 'B');\n        m('A', 'B', 'C');\n        m('A', 'B', 'C', 'D');\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"It compiles successfully and on execution prints 1233 on to the console","B":"It compiles successfully and on execution prints 1333 on to the console","C":"It compiles successfully and on execution prints 3333 on to the console","D":"Above code causes compilation error","E":"","F":"","G":"","H":"","I":""},"explanation":"If choice is between implicit casting and variable arguments, then implicit casting takes precedence because variable arguments syntax was added in Java 5 version.\n\nm('A'); is tagged to m(int) as 'A' is char literal and implicitly casted to int.\n\nm('A', 'B'); is tagged to m(int, int) as 'A' and 'B' are char literals and implicitly casted to int.\n\nm('A', 'B', 'C'); is tagged to m(char...)\n\nm('A', 'B', 'C', 'D'); is tagged to m(char...)\n\n\n\nThere is no compilation error and on execution output is: 1233"},{"id":51,"trainingUnit":"OCA","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below codes of 3 java files:\n\n//M.java\npackage com.github.oca;\n \npublic class M {\n    public void printName() {\n        System.out.println(\"M\");\n    }\n}\n\n\n//N.java\npackage com.github.oca;\n \npublic class N extends M {\n    public void printName() {\n        System.out.println(\"N\");\n    }\n}\n\n\n//Test.java\npackage com.github.oca.test;\n \nimport com.github.oca.*;\n \npublic class Test {\n    public static void main(String[] args) {\n        M obj1 = new M();\n        N obj2 = (N)obj1;\n        obj2.printName();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"It executes successfully and prints N on to the console","B":"It executes successfully and prints M on to the console","C":"Compilation error","D":"An exception is thrown at runtime","E":"","F":"","G":"","H":"","I":""},"explanation":"Class M and M are declared public and inside same package com.github.oca. Method printName() of class M has correctly been overridden by N.\n\nprintName() method is public so no issues in accessing it anywhere.\n\n\n\nLet's check the code inside main method.\n\nM obj1 = new M(); => obj1 refers to an instance of class M.\n\nN obj2 = (N)obj1; => obj1 is of type M and it is assigned to obj2 (N type), hence explicit casting is necessary. obj1 refers to an instance of class M, so at runtime obj2 will also refer to an instance of class M. sub type can't refer to an instance of super type so at runtime `N obj2 = (N)obj1;` will throw ClassCastException."},{"id":56,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below codes of 3 java files:\n\n//Animal.java\npackage a;\n \npublic class Animal {\n    Animal() {\n        System.out.print(\"ANIMAL-\");\n    }\n}\n\n\n//Dog.java\npackage d;\n \nimport a.Animal;\n \npublic class Dog extends Animal {\n    public Dog() {\n        System.out.print(\"DOG\");\n    }\n}\n\n\n//Test.java\npackage com.github.oca;\n \nimport d.Dog;\n \npublic class Test {\n    public static void main(String[] args) {\n        new Dog();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"It executes successfully but nothing is printed on to the console","B":"Compilation error in Dog.java file","C":"Compilation error in Animal.java file","D":"It executes successfully and prints DOG on to the console","E":"Compilation error in Test.java file","F":"It executes successfully and prints ANIMAL-DOG on to the console","G":"","H":"","I":""},"explanation":"super(); is added by the compiler as the first statement in both the constructors:\n\nAnimal() {\n\n    super();\n\n    System.out.print(\"ANIMAL-\");\n\n}\n\n\n\nand\n\n\n\npublic Dog() {\n\n    super();\n\n    System.out.print(\"DOG\");\n\n}\n\n\n\nClass Animal extends from Object class and Object class has no-argument constructor, hence no issues with the constructor of Animal class.\n\n\n\nAnimal class's constructor has package scope, which means it is accessible to all the classes declared in package 'a'. But Dog class is declared in package 'b' and hence `super();` statement inside Dog class's constructor causes compilation error as no-argument constructor of Animal class is not visible.\n\n\n\nThere is no compilation error in Test.java file as Dog class's constructor is public and therefore `new Dog();` compiles successfully."},{"id":57,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"What will be the result of compiling and executing Test class?\n\n\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int val = 25;\n        if(val++ < 26) {\n            System.out.println(val++);\n        }\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"Program executes successfully but nothing is printed on to the console","B":"26","C":"25","D":"27","E":"","F":"","G":"","H":"","I":""},"explanation":"Initially val = 25.\n\n'if(val++ < 26)' means 'if(25 < 26)', value of val (25) is used in the boolean expression and then value of val is incremented by 1, so val = 26.\n\n25 < 26 is true, control goes inside if-block and executes System.out.println(val++); This prints current value of val to the console, which is 26 and after that increments the value of val by 1, so val becomes 27."},{"id":54,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code snippet:\n\nimport java.util.*;\n \nclass Father {}\n \nclass Son extends Father {}\n \nclass GrandSon extends Son {}\n \nabstract class Super {\n    abstract List<Father> get();\n}\n \nclass Sub extends Super {\n    /*INSERT*/\n}\n\n\nAnd the definitions of get() method:\n\n1. List<Father> get() {return null;}\n\n2. ArrayList<Father> get() {return null;}\n\n3. List<Son> get() {return null;}\n\n4. ArrayList<Son> get() {return null;}\n\n5. List<GrandSon> get() {return null;}\n\n6. ArrayList<GrandSon> get() {return null;}\n\n7. List<Object> get() {return null;}\n\n8. ArrayList<Object> get() {return null;}\n\n\n\nHow many definitions of get() method can replace /*INSERT*/ such that there is no compilation error?","type":"Single Choice","answer":"B","answers":{"A":"One definition","B":"Two definitions","C":"Seven definitions","D":"Four definitions","E":"Five definitions","F":"Six definitions","G":"Eight definitions","H":"Three definitions","I":""},"explanation":"There are 2 rules related to return types of overriding method:\n\n1. If return type of overridden method is of primitive type, then overriding method should use same primitive type.\n\n2. If return type of overridden method is of reference type, then overriding method can use same reference type or its sub-type (also known as covariant return type).\n\n\n\nArrayList is a subtype of List, hence overriding method can use List<Father> or ArrayList<Father> as return type. Definitions 1 and 2 are valid.\n\n\n\nPlease note: even though Son is a subtype of Father, List<Son> is not subtype of List<Father>. Hence definitions 3 and 4 are NOT valid.\n\n\n\nOn similar lines, even though GrandSon is a subtype of Father, List<GrandSon> is not subtype of List<Father>. Hence definitions 5 and 6 are also NOT valid.\n\n\n\nList<Object> is not subtype of List<Father>, definition 7 is NOT valid.\n\n\n\nArrayList<Object> is not subtype of List<Father>, definition 8 is also NOT valid."},{"id":62,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"P\");\n        list.add(\"O\");\n        list.add(\"T\");\n \n        List<String> subList = list.subList(1, 2); //Line n1\n        subList.set(0, \"E\"); //Line n2\n        System.out.println(list);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"[P, E, T]","B":"Compilation error","C":"[P, O, T]","D":"An exception is thrown by Line n2","E":"","F":"","G":"","H":"","I":""},"explanation":"list --> [P, O, T]\n\n\n\nsublist method is declared in List interface:\n\nList<E> subList(int fromIndex, int toIndex)\n\nfromIndex is inclusive and toIndex is exclusive\n\nIt returns a view of the portion of this list between the specified fromIndex and toIndex. The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list and vice-versa.\n\nIf returned list (or view) is structurally modified, then modification are reflected in this list as well but if this list is structurally modified, then the semantics of the list returned by this method become undefined.\n\nIf fromIndex == toIndex, then returned list is empty.\n\nIf fromIndex < 0 OR toIndex > size of the list OR fromIndex > toIndex, then IndexOutOfBoundsException is thrown.\n\n\n\nlist.subList(1, 2) --> [O] (fromIndex is inclusive and endIndex is exclusive, so start index is 1 and end index is also 1). subList --> [O].\n\nAt Line n2, `subList.set(0, \"E\");` => sublist --> [E]. This change is also reflected in the backed list, therefore after this statement, list --> [P, E, T]\n\n\n\n`System.out.println(list);` prints [P, E, T] on to the console."},{"id":60,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"java.sql.SQLException extends java.lang.Exception\n\nand\n\njava.sql.SQLWarning extends java.sql.SQLException\n\n\n\nGiven code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.*;\n \ninterface Multiplier {\n    void multiply(int... x) throws SQLException;\n}\n \nclass Calculator implements Multiplier {\n    public void multiply(int... x) throws /*INSERT*/ {\n \n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            Multiplier obj = new Calculator(); //Line n1\n            obj.multiply(1, 2, 3);\n        } catch(SQLException e) {\n            System.out.println(e);\n        }\n    }\n}\n\n\nWhich of the options can be used to replace /*INSERT*/ such that there is no compilation error?\n\nSelect 5 options.","type":"Multiple Choice","answer":"C,D,E,G,H","answers":{"A":"java.io.IOException","B":"Exception","C":"Error","D":"SQLException","E":"RuntimeException","F":"Throwable","G":"SQLWarning","H":"NullPointerException","I":""},"explanation":"At Line n1, reference variable 'obj' is of Multiplier type (supertype) and it refers to an instance of Calculator class (subtype). This is polymorphism and allowed in Java.\n\nmultiply(int...) method declared in Multiplier interface declares to throw SQLException, hence the catch handler for Line n1 should provide handler for SQLException or its supertype. As catch-handler for SQLException is available, therefore Test class compiles successfully.\n\n\n\nAccording to overriding rules, if super class / interface method declares to throw a checked exception, then overriding method of sub class / implementer class has following options:\n\n1. May not declare to throw any checked exception\n\n2. May declare to throw the same checked exception thrown by super class / interface method: SQLException is a valid option.\n\n3. May declare to throw the sub class of the exception thrown by super class / interface method: SQLWarning is a valid option.\n\n4. Cannot declare to throw the super class of the exception thrown by super class / interface method: Exception, Throwable are not valid options.\n\n5. Cannot declare to throw unrelated checked exception: java.io.IOException is not a valid option as it is not related java.sql.SQLException in multi-level inheritance.\n\n6. May declare to throw any RuntimeException or Error: RuntimeException, NullPointerException and Error are valid options.\n\n\n\nTherefore 5 options can successfully replace /*INSERT*/: SQLException, SQLWarning, RuntimeException, Error and NullPointerException"},{"id":59,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String [][] arr = { {\"%\", \"$$\"}, {\"***\", \"@@@@\", \"#####\"}};\n        for(String [] str : arr) {\n            for(String s : str) {\n                System.out.println(s);\n                if(s.length() == 4) //Line n1\n                    break; //Line n2\n            }\n            break; //Line n3\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"%\n$$","B":"%\n$$\n***","C":"%","D":"%\n$$\n***\n@@@@\n#####","E":"%\n$$\n***\n@@@@","F":"","G":"","H":"","I":""},"explanation":"Variable 'arr' refers to a two-dimensional array. for-each loops are used to iterate the given array.\n\nIn 1st iteration of outer loop, str refers to one-dimensional String array {\"%\", \"$$\"}.\n\nIn 1st iteration of inner loop, s refers to \"%\" and \"%\" will be printed on to the console. Boolean expression of Line n1 evaluates to false so Line n2 is not executed.\n\nIn 2nd iteration of inner loop, s refers to \"$$\" and \"$$\" will be printed on to the console. Boolean expression of Line n1 evaluates to false so Line n2 is not executed.\n\nIteration of inner for-each loop is over and control executes Line n3. break; statement at Line n3 terminates the outer loop and program ends successfully.\n\n\n\nSo, output is:\n\n%\n\n$$"},{"id":58,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void checkData() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            e = null; //Line 10\n            throw e; //Line 11\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            checkData(); //Line 17\n        } catch(SQLException e) {\n            System.out.println(\"NOT AVAILABLE\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"NOT AVAILABLE is printed on to the console and program terminates successfully","B":"Line 17 causes compilation failure","C":"Program ends abruptly","D":"Line 11 causes compilation failure","E":"Line 10 causes compilation failure","F":"","G":"","H":"","I":""},"explanation":"Exception is a java class, so `e = null;` is a valid statement and compiles successfully.\n\n\n\nIf you comment Line 10, and simply throw e, then code would compile successfully as compiler is certain that 'e' would refer to an instance of SQLException only.\n\n\n\nBut the moment compiler finds `e = null;`, `throw e;` (Line 11) causes compilation error as at runtime 'e' may refer to any Exception type.\n\n\n\nNOTE: No issues with Line 17 as method checkData() declares to throw SQLException and main(String []) method code correctly handles it."},{"id":64,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider the code of Test.java file:\n\npackage com.github.oca;\n \nclass Report {\n    public String generateReport() {\n        return \"CSV\";\n    }\n    \n    public Object generateReport() {\n        return \"XLSX\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Report rep = new Report();\n        String csv = rep.generateReport();\n        Object xlsx = rep.generateReport();\n        System.out.println(csv + \":\" + (String)xlsx);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"CSV:CSV","B":"CSV:XLSX","C":"Compilation error","D":"XLSX:XLSX","E":"XLSX:CSV","F":"An exception is thrown at runtime","G":"","H":"","I":""},"explanation":"Both the methods of Report class have same signature(name and parameters match).\n\nHaving just different return types don't overload the methods and therefore Java compiler complains about duplicate generateReport() methods in Report class."},{"id":66,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Range of short data type is from -32768 to 32767\n\nWhich of the following code segments, written inside main method will compile successfully?\n\nSelect 3 options.","type":"Multiple Choice","answer":"A,B,C","answers":{"A":"short s1 = 10;","B":"final int i5 = 10;\nshort s5 = i5 + 100;","C":"final int i3 = 10;\nshort s3 = i3;","D":"final int m = 25000;\nfinal int n = 25000;\nshort s6 = m + n;","E":"final int i4 = 40000;\nshort s4 = i4;","F":"int i7 = 10;\nshort s7 = i7;","G":"short s2 = 32768;","H":"","I":""},"explanation":"Let's check all the statements one by one:\n\n\n\nshort s1 = 10;\n\nAbove statement compiles successfully, even though 10 is an int literal (32 bits) and s1 is of short primitive type which can store only 16 bits of data.\n\nHere java does some background task, if value of int literal can be easily fit to short primitive type (-32768 to 32767), then int literal is implicitly casted to short type.\n\nSo above statement is internally converted to:\n\nshort s1 = (short)10;\n\n\n\nshort s2 = 32768;\n\nIt causes compilation failure as 32768 is out of range value.\n\n\n\nfinal int i3 = 10;\n\nshort s3 = i3;\n\nAbove code compiles successfully. If you are working with final variable and the value is within the range, then final variable is implicitly casted to target type, as in this case i3 is implicitly casted to short.\n\n\n\nfinal int i4 = 40000;\n\nshort s4 = i4;\n\nIt causes compilation failure as 40000 is out of range value.\n\n\n\nfinal int i5 = 10;\n\nshort s5 = i5 + 100;\n\nAbove code compiles successfully. If you are working with constant expression and the resultant value of the constant expression is within the range, then resultant value is implicitly casted. In this case, resultant value 110 is implicitly casted.\n\n\n\nfinal int m = 25000;\n\nfinal int n = 25000;\n\nshort s6 = m + n;\n\nm + n is a constant expression but resultant value 50000 is out of range for short type, hence it causes compilation failure.\n\n\n\nint i7 = 10;\n\nshort s7 = i7;\n\nCompilation error as i7 is non-final variable and hence cannot be implicitly casted to short type."},{"id":61,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<StringBuilder> list = new ArrayList<>();\n        list.add(new StringBuilder(\"AAA\")); //Line n1\n        list.add(new StringBuilder(\"BBB\")); //Line n2\n        list.add(new StringBuilder(\"AAA\")); //Line n3\n \n        list.removeIf(sb -> sb.equals(new StringBuilder(\"AAA\"))); //Line n4\n        System.out.println(list);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"[BBB]","B":"[]","C":"[BBB, AAA]","D":"[AAA, BBB, AAA]","E":"None of the other options","F":"","G":"","H":"","I":""},"explanation":"ArrayList instance referred by 'list' stores 3 StringBuilder instances.\n\n\n\nremoveIf(Predicate<? super E> filter) method was added as a default method in Collection<E> interface in JDK 8 and it removes all the elements of this collection that satisfy the given predicate.\n\nStringBuilder class doesn't override equals(Object) method. So Object version is invoked, which uses == operator, hence `sb.equals(new StringBuilder(\"AAA\"))` would return false as all 4 StringBuilder instances have been created at four different memory locations.\n\nNone of the StringBuilder instances are removed from the list.\n\n\n\nStringBuilder class overrides toString() method, which returns the containing String and that is why [AAA, BBB, AAA] will be printed on to the console."},{"id":63,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        boolean flag = false;\n        do {\n            if(flag = !flag) { //Line n1\n                System.out.print(1); //Line n2\n                continue; //Line n3\n            }\n            System.out.print(2); //Line n4\n        } while(flag); //Line n5\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"2","B":"212","C":"Compilation error","D":"12","E":"121","F":"21","G":"112","H":"221","I":"1"},"explanation":"Body of do-while loop is executed first and then condition is checked for the next iteration.\n\nInitially, flag = false;\n\n1st iteration: Boolean expression of if-block `flag = !flag` = `flag = !false` = `flag = true`: it assigns true to variable 'flag' and evaluates to true as well. Line n2 is executed and 1 is printed on to the console. Line n3 takes the control to the boolean expression of Line n5.\n\n2nd iteration: As flag is true, boolean expression at Line n5 evaluates to true and control enters the loop's body. Boolean expression of if-block `flag = !flag` = `flag = !true` = `flag = false`: it assigns false to variable 'flag' and evaluates to false as well. Line n2 and Line n3 are not executed. Line n4 is executed, which prints 2 on to the console. Control goes to the boolean expression of Line n5.\n\n3rd iteration: As flag is false, boolean expression at Line n5 evaluates to false and control exits the loop.\n\n\n\nProgram terminates successfully after printing 12 on to the console."},{"id":69,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        boolean flag = false;\n        System.out.println((flag = true) | (flag = false) || (flag = true));\n        System.out.println(flag);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"true\nfalse","B":"Compilation error","C":"false\ntrue","D":"false\nfalse","E":"true\ntrue","F":"","G":"","H":"","I":""},"explanation":"Given statement:\n\nSystem.out.println((flag = true) | (flag = false) || (flag = true)); //flag = false\n\nSystem.out.println(((flag = true) | (flag = false)) || (flag = true)); //bitwise inclusive OR | has higher precedence over logical OR ||. flag = false\n\n|| has two operands, Left: ((flag = true) | (flag = false)) and Right: (flag = true). Left operand needs to be evaluated first.\n\nSystem.out.println((true | (flag = false)) || (flag = true)); //flag = true\n\nSystem.out.println((true | false) || (flag = true)); //flag = false\n\nSystem.out.println(true || (flag = true)); //flag = false\n\n|| is a short-circuit operator and as left operand evaluates to true, hence right operand is not evaluated.\n\nAbove statement prints true on to the console.\n\nAnd\n\nSystem.out.println(flag); prints false on to the console as flag variable is false."},{"id":68,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(\"Welcome \" + args[0] +\"!\");\n    }\n}\n\n\nAnd the commands:\n\njavac Test.java\n\njava Test \"James Gosling\" \"Bill Joy\"\n\n\n\nWhat is the result?","type":"Single Choice","answer":"E","answers":{"A":"Welcome \"James Gosling\"!","B":"Welcome James!","C":"Welcome Bill!","D":"Welcome Joy!","E":"Welcome James Gosling!","F":"Welcome Gosling!","G":"Welcome Bill Joy!","H":"Welcome \"Bill Joy\"!","I":""},"explanation":"Please note, if passed command line arguments contain space(s) in between, then it is a common practice to enclosed within double quotes. In this case \"James Gosling\" is passed as one String object and \"Bill Joy\" is also passed as one String object.\n\njava Test \"James Gosling\" \"Bill Joy\" passes new String [] {\"James Gosling\", \"Bill Joy\"} to args of main method. args[0] refers to \"James Gosling\" and args[1] refers to \"Bill Joy\".\n\nHence, Welcome James Gosling! is printed on to the console. While printing the String object, enclosing quotes are not shown.\n\n\n\nTo use quotes as part of the String, you can escape those using backslash, such as:\n\njava Test \"\\\"James Gosling\"\\\" \"\\\"Bill Joy\"\\\"\n\nAbove command will print Welcome \"James Gosling\"! on to the console."},{"id":67,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \nclass A {\n    public String toString() {\n        return null;\n    }\n}\n \npublic class Test {\n    public static void main(String [] args) {\n        String text = null;\n        text = text + new A(); //Line n1\n        System.out.println(text.length()); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Line n2 causes Runtime error","B":"4","C":"Line n1 causes Runtime error","D":"8","E":"0","F":"Line n1 causes compilation error","G":"","H":"","I":""},"explanation":"You need to keep in mind an important point related to String Concatenation:\n\nIf only one operand expression is of type String, then string conversion is performed on the other operand to produce a string at run time.\n\nIf one of the operand is null, it is converted to the string \"null\".\n\nIf operand is not null, then the conversion is performed as if by an invocation of the toString method of the referenced object with no arguments; but if the result of invoking the toString method is null, then the string \"null\" is used instead.\n\n\n\nLet's check the expression of Line n1:\n\ntext = text + new A(); --> As text is of String type, hence + operator behaves as concatenation operator.\n\nAs text is null, so \"null\" is used in the Expression.\n\nnew A() represents the object of A class, so toString() method of A class is invoked, but as toString() method of A class returns null, hence \"null\" is used in the given expression.\n\nSo, given expression is written as:\n\ntext = \"null\" + \"null\";\n\ntext = \"nullnull\";\n\n\n\nHence, Line n2 prints 8 on to the console."},{"id":65,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nabstract class Animal {\n    abstract void jump() throws RuntimeException;\n}\n \nclass Deer extends Animal {\n    void jump() { //Line n1\n        System.out.println(\"DEER JUMPS\");\n    }\n \n    void jump(int i) {\n        System.out.println(\"DEER JUMPS TO \" + i + \" FEET\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Animal animal = new Deer();\n        ((Deer)animal).jump(); //Line n2\n        ((Deer)animal).jump(5); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"Line n2 causes compilation error","B":"Line n1 causes compilation error","C":"Line n3 causes compilation error","D":"An exception is thrown at runtime","E":"Test class executes successfully and prints:\nDEER JUMPS\nDEER JUMPS TO 5 FEET","F":"","G":"","H":"","I":""},"explanation":"Method jump() in Animal class declares to throw RuntimeException.\n\nOverriding method may or may not throw any RuntimeException. Only thing to remember is that if overridden method throws any unchecked exception or Error, then overriding method must not throw any checked exceptions. Line n1 compiles successfully as it correctly overrides the jump() method of Animal class.\n\nClass Deer also provides overloaded jump(int) method.\n\n\n\nInside main(String []) method, reference variable 'animal' is of Animal class (supertype) and it refers to an instance of Deer class (subtype), this is polymorphism and allowed in Java.\n\n\n\nAs instance is of Deer class, hence 'animal' reference can easily be casted to Deer type. Line n2 and Line n3 compiles successfully and on execution prints below on to the console:\n\nDEER JUMPS\n\nDEER JUMPS TO 5 FEET"},{"id":72,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.io.IOException;\n \nclass Parent {\n    Parent() throws IOException {\n        System.out.print(\"HAKUNA\");\n    }\n}\n \nclass Child extends Parent {\n    Child() throws Exception {\n        System.out.println(\"MATATA\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) throws Exception {\n        new Child();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"Test class executes successfully and prints MATATAHAKUNA on to the console","B":"Test class executes successfully and prints HAKUNAMATATA on to the console","C":"Compilation error only in Parent class","D":"Compilation error in both Parent and Child classes","E":"Compilation error only in Child class","F":"","G":"","H":"","I":""},"explanation":"It is legal for the constructors to have throws clause.\n\nConstructors are not inherited by the Child class so there is no method overriding rules related to the constructors but as one constructor invokes other constructors implicitly or explicitly by using this(...) or super(...), hence exception handling becomes interesting.\n\n\n\nJava compiler adds super(); as the first statement inside Child class's constructor:\n\nChild() throws Exception {\n\n    super(); //added by the compiler\n\n    System.out.println(\"MATATA\");\n\n}\n\n\n\nsuper(); invokes the constructor of Parent class (which declares to throw IOException), but as no-argument constructor of Child class declares to throw Exception (super class of IOException), hence IOException is also handled. There is no compilation error and output is: HAKUNAMATATA"},{"id":71,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \ninterface X1 {\n    default void print() {\n        System.out.println(\"X1\");\n    }\n}\n \ninterface X2 extends X1 {\n    void print();\n}\n \ninterface X3 extends X2 {\n    default void print() {\n        System.out.println(\"X3\");\n    }\n}\n \nclass X implements X3 {}\n \npublic class Test {\n    public static void main(String[] args) {\n        X1 obj = new X();\n        obj.print();\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"G","answers":{"A":"interface X1 fails to compile","B":"class Test compiles successfully and on execution prints X1 on to the console","C":"interface X2 fails to compile","D":"class X fails to compile","E":"interface X3 fails to compile","F":"class Test fails to compile","G":"class Test compiles successfully and on execution prints X3 on to the console","H":"","I":""},"explanation":"As per Java 8, default methods were added in the interface. Interface X1 defines default method print(), there is no compilation error in interface X1. Method print() is implicitly public in X1.\n\n\n\ninterface X2 extends X1 and it overrides the default method print() of X1, overriding method in X2 is implicitly abstract and public. An interface in java can override the default method of super type with abstract modifier. interface X2 compiles successfully.\n\n\n\ninterface X3 extends X2 and it implements the abstract method print() of X2, overriding method in X3 is default and implicitly public. An interface in java can implement the abstract method of super type with default modifier. interface X3 compiles successfully.\n\n\n\nclass X implements X3 and therefore it inherits the default method print() defined in interface X3.\n\n\n\n`X1 obj = new X();` compiles successfully as X1 is of super type (X implements X3, X3 extends X2 and X2 extends X1).\n\n`obj.print();` invokes the default method print() defined in interface X3 and hence X3 is printed on to the console."},{"id":70,"trainingUnit":"","trainingContent":"Exam 5 (Bonus exam)","question":"Consider below codes of 3 java files:\n\n//Super.java\npackage com.github.oca;\n \npublic interface Super {\n    String name = \"SUPER\"; //Line n1\n}\n\n\n//Sub.java\npackage com.github.oca;\n \npublic interface Sub extends Super { //Line n2\n \n}\n\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Sub sub = null;\n        System.out.println(sub.name); //Line n3\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"C","answers":{"A":"Line n3 causes compilation error","B":"Line n3 throws an exception at runtime","C":"Test class compiles successfully and on execution prints SUPER on to the console","D":"Line n1 causes compilation error","E":"Line n2 causes compilation error","F":"","G":"","H":"","I":""},"explanation":"Variable 'name' declared inside interface Super is implicitly public, static and final. Line n1 compiles successfully.\n\nIn Java a class can extend from only one class but an interface can extend from multiple interfaces. Line n2 compiles successfully.\n\nVariable 'name' can be accessed in 2 ways: Super.name and Sub.name.\n\nThough correct way to refer static variable is by using the type name, such as Sub.name but it can also be invoked by using Sub reference variable. Hence, sub.name at Line n3 correctly points to the name variable at Line n1.\n\nFor invoking static fields, object is not needed, therefore even if sub refers to null, sub.name doesn't throw NullPoionterException.\n\nTest class compiles successfully and on execution prints SUPER on to the console."}]