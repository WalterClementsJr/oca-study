[{"id":1,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"package com.udayankhattry.oca;\n \ninterface I1 {\n    public static void print(String str) {\n        System.out.println(\"I1:\" + str.toUpperCase());\n    }\n}\n \nclass C1 implements I1 {\n    void print(String str) {\n        System.out.println(\"C1:\" + str.toLowerCase());\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        I1 obj = new C1();\n        obj.print(\"Java\");\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"C","answers":{"A":"Given code compiles successfully and on execution prints C1:java on to the console","B":"Given code compiles successfully and on execution prints I1:JAVA on to the console","C":"Class Test causes compilation error","D":"Interface I1 causes compilation error","E":"Class C1 causes compilation error","F":"","G":"","H":"","I":"","J":""},"explanation":"As per Java 8, default and static methods were added in the interface. Interface I1 defines static method print(String), there is no compilation error in interface I1.\n\nAlso the scope of print(String) method of I1 is limited to interface I1 and it can be invoked by using Interface name only, I1.print(\"\").\n\n\n\nclass C1 implements I1 and it also defines print(String) instance method. Even though class C1 implements I1, it doesn't have static print(String) method in its scope, therefore class C1 compiles successfully.\n\n\n\nSuper type reference variable can refer to an instance of Sub type, therefore the statement `I1 obj = new C1();` compiles successfully.\n\nobj is of I1 type, hence `obj.print(\"Java\");` tries to tag the static method of I1 but static print(String) method of I1 can only be invoked by using I1.print(\"Java\");.\n\nTherefore, `obj.print(\"Java\");` causes compilation error."},{"id":2,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        boolean status = true;\n        System.out.println(status = false || status = true | status = false);\n        System.out.println(status);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"false\nfalse","B":"true\ntrue","C":"Compilation error","D":"true\nfalse","E":"false\ntrue","F":"","G":"","H":"","I":"","J":""},"explanation":"System.out.println(status = false || status = true | status = false);\n\nAs it contains multiple operators, hence let's group the operators first.\n\nSystem.out.println(status = false || status = (true | status) = false); //Bitwise inclusive OR | has highest precedence over logical or || and assignment =\n\nFor assignment operator to work, left operand must be variable but in above case, `(true | status) = false` causes compilation failure as left operand (true | status) evaluates to a boolean value and not boolean variable."},{"id":3,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        byte b1 = 10; //Line n1\n        int i1 = b1; //Line n2\n        byte b2 = i1; //Line n3\n        System.out.println(b1 + i1 + b2);\n    }\n}\n\n\nWhat is the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Line n2 causes compilation error","B":"30 is printed on to the console","C":"Line n3 causes compilation error","D":"Line n1 causes compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Let us first check Line n1: byte b1 = 10;\n\nAbove statement compiles successfully, even though 10 is an int literal (32 bits) and b1 is of byte primitive type which can store only 8 bits of data.\n\nHere java does some background task, if value of int literal can be easily fit to byte primitive type (-128 to 127), then int literal is implicitly casted to byte type.\n\nSo above statement is internally converted to:\n\nbyte b1 = (byte)10;\n\n\n\nBut if you specify any out of range value then it would not be allowed, e.g.\n\nbyte b = 128; // It would cause compilation failure as 128 is out of range value for byte type.\n\n\n\nThere is no issue with Line n2 as byte type (8 bits) can be easily assigned to int type (32 bits).\n\n\n\nFor line n3, `byte b2 = i1;`, expression on right hand side (i1) is neither a withing range literal value nor constant expression, hence it causes compilation failure.\n\nTo compile successfully, this expression needs to be explicitly casted, such as: `byte b2 = (byte)i1;`"},{"id":4,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code snippet:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    String testNo;\n    String desc;\n    /*\n    Other codes...\n    */\n}\n\n\nWhich of the options are correct so that instance variables 'testNo' and 'desc' are accessible only within 'com.udayankhattry.oca' package?","type":"Single Choice","answer":"A","answers":{"A":"No changes are necessary","B":"Change the instance variable declarations to:\nprotected String testNo;\nprotected String desc;","C":"Change the instance variable declarations to:\npublic String testNo;\npublic String desc;","D":"Change the instance variable declarations to:\nprivate String testNo;\nprivate String desc;","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"As member variables 'testNo' and 'desc' are declared with no explicit access specifier, this means these variables have package scope, hence these variables are accessible only to classes within the same package. Hence, no changes are necessary.\n\nIf you use private, then instance variables will not be accessible to any other classes, even within the same package.\n\nIf you use protected, then instance variables will be accessible to the subclasses outside 'com.udayankhattry.oca' package.\n\nIf you use public, then instance variables will be accessible to all the classes."},{"id":5,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below codes of 3 java files:\n\n//Buyable.java\npackage com.udayankhattry.oca;\n \npublic interface Buyable {\n    int salePercentage = 85;\n \n    public static String salePercentage() {\n        return salePercentage + \"%\";\n    }\n}\n\n\n//Book.java\npackage com.udayankhattry.oca;\n \npublic class Book implements Buyable {}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Buyable [] arr = new Buyable[2];\n        for(Buyable b : arr) {\n            System.out.println(b.salePercentage); //Line n1\n            System.out.println(b.salePercentage()); //Line n2\n        }\n        \n        Book [] books = new Book[2];\n        for(Book b : books) {\n            System.out.println(b.salePercentage); //Line n3\n            System.out.println(b.salePercentage()); //Line n4\n        }\n    }\n}\n\n\nWhich of the following statements are correct?\n\nSelect 2 options.","type":"Multiple Choice","answer":"B,C","answers":{"A":"There is a compilation error in Buyable.java file","B":"There is a compilation error at Line n2","C":"There is a compilation error at Line n4","D":"There is a compilation error at Line n1","E":"There is a compilation error in Book.java file","F":"There is a compilation error at Line n3","G":"","H":"","I":"","J":""},"explanation":"Variable 'salePercentage' declared inside interface Buyable is implicitly public, static and final. As per Java 8, default and static methods were added in the interface. There is no compilation error in Buyable.java file.\n\nclass Book implements Buyable interface but as there is no abstract method in Buyable interface, hence Book class is not needed to implement any method. Book.java file compiles successfully.\n\n\n\n`Buyable [] arr = new Buyable[2];` creates one dimensional array of 2 elements of Buyable type and both the elements are initialized to null.\n\n\n\nThere are some difference in which static variables and static methods of the interface are accessed.\n\nCorrect and only way to access static method of an Interface is by using the name of the interface, such as Buyable.salePercentage(). Line n2 and Line n4 cause compilation error.\n\n\n\nAs far as public static final variable of interface is concerned, even through the correct way to access static variable is by using the name of the interface, such as Buyable.salePercentage but it can also be accessed by using following:\n\nReference variable of the interface: Buyable obj1 = null; System.out.println(obj1.salePercentage);\n\nName of the implementer class: System.out.println(Book.salePercentage);\n\nReference variable of the implementer class: Book obj2 = null; System.out.println(obj2.salePercentage);\n\nHence, Line n1 and Line n3 compile successfully."},{"id":6,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        String text = \"RISE \";\n        text = text + (text = \"ABOVE \");\n        System.out.println(text);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"RISE RISE ABOVE","B":"ABOVE ABOVE","C":"RISE ABOVE","D":"RISE ABOVE RISE","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Initially text refers to \"RISE \".\n\nGiven statement:\n\ntext = text + (text = \"ABOVE \");\n\ntext = \"RISE \" + (text = \"ABOVE \"); //Left operand of + operator is evaluated first, text --> \"RISE \"\n\ntext = \"RISE \" + \"ABOVE \"; //Right operand of + operator is evaluated next, text --> \"ABOVE \"\n\ntext = \"RISE ABOVE \"; //text --> \"RISE ABOVE \"\n\n\n\nHence `System.out.println(text);` prints 'RISE ABOVE ' on to the console."},{"id":7,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface Blogger {\n    default void blog() throws Exception {\n        System.out.println(\"GENERIC\");\n    }\n}\n \nclass TravelBlogger implements Blogger {\n    public void blog() {\n        System.out.println(\"TRAVEL\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Blogger blogger = new TravelBlogger(); //Line n1\n        ((TravelBlogger)blogger).blog(); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error in TravelBlogger class","B":"An exception is thrown at runtime","C":"Compilation error in Test class","D":"TRAVEL is printed on to the console and program terminates successfully","E":"GENERIC is printed on to the console and program terminates successfully","F":"","G":"","H":"","I":"","J":""},"explanation":"According to overriding rules, if super class / interface method declares to throw a checked exception, then overriding method of sub class / implementer class has following options:\n\n1. May not declare to throw any checked exception.\n\n2. May declare to throw the same checked exception thrown by super class / interface method.\n\n3. May declare to throw the sub class of the exception thrown by super class / interface method.\n\n4. Cannot declare to throw the super class of the exception thrown by super class / interface method.\n\n5. Cannot declare to throw unrelated checked exception.\n\n6. May declare to throw any RuntimeException or Error.\n\n\n\ndefault methods were added in Java 8 and TravelBlogger class correctly overrides the default method blog() of Blogger interface. Blogger interface compiles successfully.\n\n\n\nAt Line n1, 'blogger' is of Blogger type (supertype) and it refers to an instance of TravelBlogger class (subtype), this is polymorphism and allowed in Java. Line n1 compiles successfully.\n\nAt Line n2, blog() method is being invoked on typecasting 'blogger' to TravelBlogger and as TravelBlogger class doesn't declare to throw any checked exception, hence Line n2 compiles successfully.\n\n\n\nAs instance is of TravelBlogger type, therefore on execution, Line n2 invokes blog() method of TravelBlogger instance, which prints TRAVEL on to the console."},{"id":8,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String arr1 [], arr2, arr3 = null; //Line n1\n        arr1 = new String[2];\n        arr1[0] = \"A\";\n        arr1[1] = \"B\";\n        arr2 = arr3 = arr1; //Line n2\n        log(arr2); //Line n3\n    }\n    \n    private static void log(String... vals) {\n        for(String s : vals)\n            System.out.print(s);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"It executes successfully and prints BA on to the console","B":"It executes successfully and prints A on to the console","C":"It executes successfully and prints AB on to the console","D":"Line n2 causes compilation error","E":"Line n1 causes compilation error","F":"It executes successfully and prints B on to the console","G":"Line n3 causes compilation error","H":"","I":"","J":""},"explanation":"arr1 is of String[] type, where as arr2 and arr3 are of String type. As all three arr1, arr2 and arr3 are of reference type, hence null can be assigned to all these variables. Line n1 compiles successfully.\n\n\n\nStatement at Line n2: arr2 = arr3 = arr1;\n\n=> arr2 = (arr3 = arr1); //assignment operator is right to left associative.\n\narr3 is of String type and arr1 is of String [] type, hence (arr3 = arr1) causes compilation error.\n\n\n\nThough you had to select one correct option, hence no need to look further but I am providing explanation for Line n3 as well.\n\nlog(String...) method can be called using a String [] or a String instance or mutliple String instances:\n\nlog(new String[] {\"A\", \"B\"});\n\nlog(\"A\");\n\nlog(\"A\", \"B\");\n\n\n\nAs arr2 is of String type, hence `log(arr2);` (Line n3) compiles successfully."},{"id":9,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass MyClass {\n    MyClass() {\n        System.out.println(101);\n    }\n}\n \nclass MySubClass extends MyClass {\n    final MySubClass() {\n        System.out.println(202);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(new MySubClass());\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error","B":"202\n101\n<Some text containing @ symbol>","C":"101\n<Some text containing @ symbol>","D":"202\n<Some text containing @ symbol>","E":"101\n202\n<Some text containing @ symbol>","F":"","G":"","H":"","I":"","J":""},"explanation":"Constructors cannot use final, abstract or static modifiers. As no-argument constructor of MySubClass uses final modifier, therefore it causes compilation error."},{"id":10,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Super {\n    final int NUM = -1; //Line n1\n}\n \nclass Sub extends Super {\n    /*INSERT*/\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Sub obj = new Sub();\n        obj.NUM = 200; //Line n2\n        System.out.println(obj.NUM); //Line n3\n    }\n}\n\n\nAbove code causes compilation error, which modifications, done independently, enable the code to compile and on execution print 200 on to the console?\n\nSelect 4 options.","type":"Multiple Choice","answer":"B,D,F,H","answers":{"A":"Replace /*INSERT*/ with double NUM;","B":"Replace /*INSERT*/ with short NUM;","C":"Replace /*INSERT*/ with float NUM;","D":"Remove final modifier from Line n1","E":"Replace /*INSERT*/ with byte NUM;","F":"Replace /*INSERT*/ with Object NUM;","G":"Replace /*INSERT*/ with boolean NUM;","H":"Replace /*INSERT*/ with int NUM;","I":"","J":""},"explanation":"Variable NUM is declared in Super class and class Sub extends Super, hence NUM can be accessed by using obj.NUM.\n\nBut as NUM Is final, hence it cannot be reassigned, therefore Line n2 causes compilation error. Let's check all the options one by one:\n\n\n\nRemove final modifier from Line n1 => ✓ Valid option and in this case output is 200.\n\nReplace /*INSERT*/ with byte NUM; => ✗ In this case, class Sub hides the variable NUM of Super class but Line n2 will still not compile as byte range is from -128 to 127 and 200 is out of range value.\n\nReplace /*INSERT*/ with short NUM; => ✓ In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to short type. In this case output is 200.\n\nReplace /*INSERT*/ with int NUM; => In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to int type. In this case output is 200.\n\nReplace /*INSERT*/ with float NUM; => ✗ In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to float type. But output in this case will be 200.0 and not 200.\n\nReplace /*INSERT*/ with double NUM; => ✗ In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to double type. But output in this case will be 200.0 and not 200.\n\nReplace /*INSERT*/ with boolean NUM; => ✗ In this case, class Sub hides the variable NUM of Super class but Line n2 will still not compile as boolean type in java allows 2 values true and false. 200 is not compatible with boolean type.\n\nReplace /*INSERT*/ with Object NUM; => ✓ In this case, class Sub hides the variable NUM of Super class and at Line n2, value 200 is boxed to Integer, which is then assigned to obj.NUM. So, obj.NUM refers to an instance of Integer class. Line n3 invokes toString() method of Integer class and hence 200 is printed on to the console."},{"id":11,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Paper {\n    static String getType() { //Line n1\n        return \"GENERIC\";\n    }\n}\n \nclass RuledPaper extends Paper {\n    String getType() { //Line n2\n        return \"RULED\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Paper paper = new RuledPaper(); //Line n3\n        System.out.println(paper.getType()); //Line n4\n    }\n}\n\n\nWhich of the following statements is true for above code?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error in RuledPaper class","B":"Code compiles successfully and on execution prints GENERIC on to the console","C":"Compilation error in Test class","D":"Code compiles successfully and on execution prints RULED on to the console","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Instance method of subclass cannot override the static method of superclass.\n\n\n\nInstance method at Line n2 tries to override the static method at Line n1 and hence Line n2 causes compilation error.\n\n\n\nThere is no issue with Line n3 as reference variable of superclass can refer to an instance of subclass.\n\n\n\nAt Line n4, paper.getType() doesn't cause compilation error but as this syntax creates confusion, so it is not a good practice to access the static variables or static methods using reference variable, instead class name should be used. Paper.getType() is the preferred syntax."},{"id":12,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below codes of 4 java files:\n\n//I1.java\npackage com.udayankhattry.oca;\n \npublic interface I1 {\n    int i = 10;\n}\n\n\n//I2.java\npackage com.udayankhattry.oca;\n \npublic interface I2 {\n    int i = 20;\n}\n\n\n//I3.java\npackage com.udayankhattry.oca;\n \npublic interface I3 extends I1, I2 { //Line n1\n \n}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(I1.i); //Line n2\n        System.out.println(I2.i); //Line n3\n        System.out.println(I3.i); //Line n4\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"D","answers":{"A":"Line n1 causes compilation error","B":"Line n3 causes compilation error","C":"Line n2 causes compilation error","D":"Line n4 causes compilation error","E":"There is no compilation error","F":"","G":"","H":"","I":"","J":""},"explanation":"Variable 'i' declared inside interface I1 is implicitly public, static and final and similarly variable i declared inside interface I2 is implicitly public, static and final as well.\n\nIn Java a class can extend from only one class but an interface can extend from multiple interfaces. static variables are not inherited and hence there is no issue with Line n1.\n\n\n\nI1.i points to variable 'i' of interface I1.\n\nI2.i points to variable 'i' of interface I2.\n\nI3.i is an ambiguous call as compiler is not sure whether to point to I1.i or I2.i and therefore, Line n4 causes compilation error."},{"id":13,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass X {\n    void A() {\n        System.out.print(\"A\");\n    }\n}\n \nclass Y extends X {\n    void A() {\n        System.out.print(\"A-\");\n    }\n    \n    void B() {\n        System.out.print(\"B-\");\n    }\n    \n    void C() {\n        System.out.print(\"C-\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        X obj = new Y(); //Line n1\n        obj.A(); //Line n2\n        obj.B(); //Line n3\n        obj.C(); //Line n4\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"B","answers":{"A":"Compilation error in class Y","B":"Compilation error in class Test","C":"AB-C-","D":"A-B-C-","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Class Y correctly extends class X and it overrides method A() and provides two new methods B() and C().\n\nAt Line n1, obj is of X type and therefore obj.B(); and obj.C(); cause compilation error as these methods are not defined in class X."},{"id":14,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int var = 3;\n        String [][] arr = new String[--var][var++]; //Line n1\n        arr[1][1] = \"X\"; //Line n2\n        arr[1][2] = \"Y\"; //Line n3\n        for(String [] arr1 : arr) {\n            for(String s : arr1) {\n                if(s != null) \n                    System.out.print(s);\n            }\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"It prints XY on to the console and program terminates abruptly","B":"It causes compilation error at multiple statements","C":"It causes compilation error at single statement","D":"It prints XY on to the console and program terminates successfully","E":"It throws an exception at runtime","F":"","G":"","H":"","I":"","J":""},"explanation":"Line n1:\n\nString [][] arr = new String[--var][var++]; //var = 3\n\nAccess array element operator [] is left to right associative.\n\n=> String [][] arr = new String[2][var++]; //var = 2, var is decremented first and then used in the expression.\n\n=> String [][] arr = new String[2][2]; //var = 3, value of var is used first and then it is incremented by 1\n\n\n\nHence, arr refers to 2-dimensional String array object {{null, null}, {null, null}}.\n\n\n\nAt Line n2, arr[1][1] = \"X\"; assigns \"X\" to element at index [1][1], therefore arr --> {{null, null}, {null, \"X\"}}\n\n\n\nAt Line n3, arr[1][2] = \"Y\"; causes ArrayIndexOutOfBoundsException as 2nd index 2 is out of range.\n\n\n\nAs Line n3 throws Exception at runtime, hence for loop will not be executed."},{"id":15,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Base {\n    String msg = \"INHALE\"; //Line n1\n}\n \nclass Derived extends Base {\n    Object msg = \"EXHALE\"; //Line n2\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base obj1 = new Base(); //Line n3\n        Base obj2 = new Derived(); //Line n4\n        Derived obj3 = (Derived) obj2; //Line n5\n        String text = obj1.msg + \"-\" + obj2.msg + \"-\" + obj3.msg; //Line n6\n        System.out.println(text); //Line n7\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"G","answers":{"A":"None of the other options","B":"Line n5 throws Exception at runtime","C":"Line n2 causes compilation error","D":"It executes successfully and prints INHALE-INHALE-INHALE","E":"It executes successfully and prints INHALE-EXHALE-EXHALE","F":"Line n6 causes compilation error","G":"It executes successfully and prints INHALE-INHALE-EXHALE","H":"","I":"","J":""},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n2 hides the variable created at Line n1, there is no rules related to hiding (type and access modifier can be changed).\n\n\n\nAt Line n3, obj1 is of Base type and refers to an instance of Base class.\n\n\n\nAt Line n4, obj2 is of Base type and refers to an instance of Derived class.\n\n\n\nAt Line n5, as obj2 refers to an instance of Derived class, hence typecasting it to Derived type doesn't cause any Exception. obj3 is of Derived type and refers to an instance of Derived class.\n\n\n\nLet's check the expression of Line n6:\n\nobj1.msg + \"-\" + obj2.msg + \"-\" + obj3.msg;\n\n=> (obj1.msg + \"-\") + obj2.msg + \"-\" + obj3.msg; //+ operator is left to right associative and behaves as concatenation operator as one of the operand is of String type.\n\n=> ((obj1.msg + \"-\") + obj2.msg) + \"-\" + obj3.msg;\n\n=> (((obj1.msg + \"-\") + obj2.msg) + \"-\") + obj3.msg;\n\nLet's solve the expression now:\n\n=> (((\"INHALE\" + \"-\") + obj2.msg) + \"-\") + obj3.msg; //obj1 is of Base type, hence obj1.msg refers to \"INHALE\"\n\n=> ((\"INHALE-\" + obj2.msg) + \"-\") + obj3.msg;\n\n=> ((\"INHALE-\" + \"INHALE\") + \"-\") + obj3.msg; //obj2 is of Base type, hence obj2.msg refers to \"INHALE\"\n\n=> (\"INHALE-INHALE\" + \"-\") + obj3.msg;\n\n=> \"INHALE-INHALE-\" + obj3.msg;\n\nIn above expression, left operand is of String type and right operand is of Object type, so toString() method is invoked. So, given expression is evaluated as:\n\n=> \"INHALE-INHALE-\" + obj3.msg.toString();\n\n=> \"INHALE-INHALE-\" + \"EXHALE\"; //As obj3.msg is of Object type and refers to an instance of String type, hence toString() method on \"EXHALE\" instance is invoked and this returns \"EXHALE\".\n\n=> \"INHALE-INHALE-EXHALE\";\n\n\n\nLine n7 prints INHALE-INHALE-EXHALE on to the console."},{"id":16,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below codes of 2 java files:\n\n//GetSetGo.java\npackage com.udayankhattry.oca;\n \npublic interface GetSetGo {\n    int count = 1; //Line n1\n}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        GetSetGo [] arr = new GetSetGo[5]; //Line n2\n        for(GetSetGo obj : arr) {\n            obj.count++; //Line n3\n        }\n        System.out.println(GetSetGo.count); //Line n4\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"F","answers":{"A":"Test class compiles successfully and on execution prints 5 on to the console","B":"Test class compiles successfully and on execution prints 6 on to the console","C":"Line n1 causes compilation error","D":"Line n4 causes compilation error","E":"Line n2 causes compilation error","F":"Line n3 causes compilation error","G":"","H":"","I":"","J":""},"explanation":"Variable 'count' declared inside interface GetSetGo is implicitly public, static and final. Line n1 compiles successfully.\n\nLine n2 creates one dimensional array of 5 elements of GetSetGo type and all 5 elements are initialized to null. Line n2 compiles successfully.\n\nThough correct way to refer static variable is by using the type name, such as GetSetGo.count but it can also be invoked by using GetSetGo reference variable. Hence, obj.count at Line n3 correctly points to the count variable at Line n1. But as variable 'count' is implicitly final, therefore obj.count++ causes compilation error. Line n3 fails to compile.\n\nLine n4 compiles successfully as variable 'count' is implicitly static and GetSetGo.count is the correct syntax to point to 'count' variable of interface GetSetGo."},{"id":17,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"PANIC\";\n        StringBuilder sb = new StringBuilder(\"THET\");\n        System.out.println(str.replace(\"N\", sb)); //Line n1\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"PANIC","B":"Line n1 causes compilation error","C":"PATHETIC","D":"Line n1 throws error at runtime","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"String class has following two overloaded replace methods:\n\n1. public String replace(char oldChar, char newChar) {}:\n\nReturns a string resulting from replacing all occurrences of oldChar in this string with newChar. If no replacement is done, then source String object is returned. e.g.\n\n\"Java\".replace('a', 'A') --> returns new String object \"JAvA\".\n\n\"Java\".replace('a', 'a') --> returns the source String object \"Java\" (no change).\n\n\"Java\".replace('m', 'M') --> returns the source String object \"Java\" (no change).\n\n\n\n2. public String replace(CharSequence target, CharSequence replacement) {}:\n\nReturns a new String object after replacing each substring of this string that matches the literal target sequence with the specified literal replacement sequence. e.g.\n\n\"Java\".replace(\"a\", \"A\") --> returns new String object \"JAvA\".\n\n\"Java\".replace(\"a\", \"a\") --> returns new String object \"Java\" (it replaces \"a\" with \"a\").\n\n\"Java\".replace(\"m\", \"M\") --> returns the source String object \"Java\" (no change).\n\n\n\nAs String, StringBuilder and StringBuffer all implement CharSequence, hence instances of these classes can be passed to replace method. Line n1 compiles successfully and on execution replaces \"N\" with \"THET\", and hence Line n1 prints PATHETIC on to the console."},{"id":18,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int score = 30; // Line n1\n        char grade = 'F'; // Line n2\n        if (50 <= score < 60) // Line n3\n            grade = 'D';\n        else if (60 <= score < 70) // Line n4\n            grade = 'C';\n        else if (70 <= score < 80) // Line n5\n            grade = 'B';\n        else if (score >= 80)\n            grade = 'A';\n        System.out.println(grade);\n    }\n}\n\n\nWhat is the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"B","B":"Compilation error","C":"A","D":"D","E":"F","F":"C","G":"","H":"","I":"","J":""},"explanation":"Line n1 and Line n2 compile successfully.\n\n\n\nLet's check the boolean expression of Line n3:\n\n50 <= score < 60\n\nAs multiple operators are available, so let's group the operators first on the basis of precedence and associativity.\n\nRelational operators (<, >, <= and >=) are at same level and left to right associative, hence given expression can be grouped as:\n\n(50 <= score) < 60\n\n< is a binary operator with two operands: (50 <= score) on the left is of boolean type and 60 on the right is of int type. But < operator is not defined for boolean, int type and hence Line n3 causes compilation error. Line n4 and Line n5 cause compilation error for the same reason."},{"id":19,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    static String str = \"KEEP IT \"; //Line n1\n    public static void main(String[] args) {\n        String str = str + \"SIMPLE\"; //Line n2\n        System.out.println(str);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error","B":"KEEP IT","C":"SIMPLE","D":"KEEP IT SIMPLE","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"At Line n2, local variable 'str' shadows the static variable 'str' created at Line n1. Hence, for the expression `str + \"SIMPLE\"`, Java compiler complains as local variable 'str' is not initialized."},{"id":20,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Super {\n    public String num = \"10\"; //Line n1\n}\n \nclass Sub extends Super {\n    protected int num = 20; //Line n2\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Super obj = new Sub();\n        System.out.println(obj.num += 2); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"D","answers":{"A":"It executes successfully and prints 12 on to the console","B":"Compilation error at Line n3","C":"It executes successfully and prints 22 on to the console","D":"It executes successfully and prints 102 on to the console","E":"It executes successfully and prints 202 on to the console","F":"Compilation error at Line n2","G":"","H":"","I":"","J":""},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n2 hides the variable created at Line n1, there is no rules related to hiding (type and access modifier can be changed).\n\n\n\n'obj' is of Super type, hence obj.num refers to num variable at Line n1, which is of String type.\n\nExpression at Line n3:\n\nobj.num += 2\n\n=> obj.num = obj.num + 2\n\n=> obj.num = \"10\" + 2\n\n=> obj.num = \"102\"\n\n\n\nobj.num refers to \"102\" and same is printed on to the console."},{"id":21,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Base {\n    int id = 1000; //Line n1\n \n    Base() {\n        Base(); //Line n2\n    }\n \n    void Base() { //Line n3\n        System.out.println(++id); //Line n4\n    }\n}\n \nclass Derived extends Base {\n    int id = 2000; //Line n5\n \n    Derived() {} //Line n6\n \n    void Base() { //Line n7\n        System.out.println(--id); //Line n8\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base base = new Derived(); //Line n9\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"J","answers":{"A":"999","B":"An exception is thrown","C":"1000","D":"Compilation error","E":"0","F":"2001","G":"1999","H":"2000","I":"1001","J":"-1"},"explanation":"Method can have same name as that of the Class. Hence, void Base() is a valid method declaration in Base class.\n\n\n\nLine n2 invokes the Base() method and not the constructor.\n\n\n\nSubclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n5 hides the variable created at Line n1, there is no rules related to hiding (type and access modifier can be changed).\n\n\n\nLine n7 correctly overrides the Base() method of class Base.\n\n\n\nCompiler adds super(); as the 1st statement inside the no-argument constructor of Base class and Derived class.\n\n\n\nThere is no compilation error, so let's check the execution.\n\n\n\nnew Derived() at Line n9 invokes the constructor of Derived class, at this point instance variable id is declared and 0 is assigned to it. In fact, instance variable id of Base class is also declared and 0 is assigned to it. Compiler added super(); as the first statement inside this constructor, hence control goes to the no-argument constructor of Base class.\n\n\n\nCompiler added super(); as the first statement inside this constructor as well, hence it invokes the no-argument constructor of the Object class. No-argument constructor of Object class finishes its execution and control goes back to the constructor of Base class. Before it starts executing remaining statements inside the constructor, instance variable assignment statement (if available) are executed. This means 1000 is assigned to variable id of Base class.\n\n\n\nLine n2 is executed next, Base() method defined in Derived class is executed. Which overriding method to invoke, is decided at runtime based on the instance. Instance is of Derived class (because of Line n9), hence control starts executing Base() method of Derived class.\n\nLine n8 is executed next, Derived class hides the id variable of Base class and that is why at Line n8, id points to variable created at Line n5. This id variable still stores the value 0 as Base class's constructor has not finishes its execution.\n\n\n\nvalue of id is decremented by 1, so id becomes -1 and -1 is printed on to the console. Base() method finishes its execution and control goes back to Line n2. No-argument constructor of Base class finishes its execution and control goes back to the constructor of Derived class. Before it starts executing remaining statements inside the constructor, instance variable assignment statement (if available) are executed. This means 2000 is assigned to variable id of Derived class.\n\n\n\nNo-argument constructor of Derived class finishes its execution and control goes back to Line n9. main(String []) method finishes its execution and program terminates successfully.\n\n\n\nHence, output is -1."},{"id":22,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Calculator {\n    int calculate(int i1, int i2) {\n        return i1 + i2;\n    }\n    \n    double calculate(byte b1, byte b2) {\n        return b1 % b2;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        byte b = 100;\n        int i = 20;\n        System.out.println(new Calculator().calculate(b, i));\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"An exception is thrown at runtime","B":"Compilation error","C":"120","D":"5.0","E":"120.0","F":"5","G":"","H":"","I":"","J":""},"explanation":"calculate method is correctly overloaded as both the methods have different signature: calculate(int, int) and calculate(byte, byte). Please note that there is no rule regarding return type for overloaded methods, return type can be same or different.\n\n\n\n`new Calculator().calculate(b, i)` tags to `calculate(int, int)` as byte value is implicitly casted to int type.\n\n\n\nGiven code compiles successfully and on execution prints 120 on to the console."},{"id":23,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"_________ modifier is most restrictive and __________ modifier is least restrictive.\n\n\n\nWhich of the following options (in below specified order) can be filled in above blank spaces?","type":"Single Choice","answer":"A","answers":{"A":"private, public","B":"public, private","C":"protected, public","D":"default (with no access modifier specified), protected","E":"default (with no access modifier specified), public","F":"","G":"","H":"","I":"","J":""},"explanation":"'private' is most restrictive, then comes 'default (with no access modifier specified)', after that 'protected' and finally 'public' is least restrictive."},{"id":24,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        for(int x = 10, y = 11, z = 12; y > x && z > y; y++, z -= 2) {\n            System.out.println(x + y + z);\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error","B":"32","C":"34","D":"33","E":"33\n32","F":"","G":"","H":"","I":"","J":""},"explanation":"Basic/Regular for loop has following form:\n\nfor ( [ForInit] ; [Expression] ; [ForUpdate] ) {...}\n\n[ForInit] can be local variable initialization or the following expressions:\n\nAssignment\n\nPreIncrementExpression\n\nPreDecrementExpression\n\nPostIncrementExpression\n\nPostDecrementExpression\n\nMethodInvocation\n\nClassInstanceCreationExpression\n\n\n\n[ForUpdate] can be following expressions:\n\nAssignment\n\nPreIncrementExpression\n\nPreDecrementExpression\n\nPostIncrementExpression\n\nPostDecrementExpression\n\nMethodInvocation\n\nClassInstanceCreationExpression\n\n\n\nThe [Expression] must have type boolean or Boolean, or a compile-time error occurs. If [Expression] is left blank, it evaluates to true.\n\n\n\nAll the expressions can be left blank; for(;;) is a valid for loop and it is an infinite loop as [Expression] is blank and evaluates to true.\n\n\n\nMultiple comma separated statements are allowed for [ForInit] and [ForUpdate] expressions, where as [Expression] must be single expression which results in boolean or Boolean.\n\n\n\nIn the given for loop:\n\n[ForInit] = int x = 10, y = 11, z = 12: It is allowed. 3 variables are declared and initialized. x = 10, y = 11 & z = 12.\n\n[Expression] = y > x && z > y = (y > x) && (z > y) [Relational operator has higher precedence than logical AND]. This expression is valid and results in boolean value.\n\n[ForUpdate] = y++, z -= 2. It is allowed. y is incremented by 1 and z is decremented by 2.\n\n\n\nLet's check the loop's iteration:\n\n1st iteration: x = 10, y = 11, z = 12. (y > x) && (z > y) = (11 > 10) && (12 > 11) = true && true = true. Loop's body is executed and prints x + y + z = 10 + 11 + 12 = 33 on to the console.\n\n2nd iteration: [ForUpdate] is executed. y = 12, z = 10. (y > x) && (z > y) = (12 > 10) && (10 > 12) = true && false = false.\n\nControl goes out of for loop and program terminates successfully.\n\n\n\nLoop's body executes once and prints 33 on to the console."},{"id":25,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Super {\n    Super() {\n        System.out.print(\"Reach\");\n    }\n}\n \nclass Sub extends Super {\n    Sub() {\n        Super();\n        System.out.print(\"Out\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        new Sub();\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"E","answers":{"A":"Compilation Error in Test class","B":"It prints OutReach on to the console","C":"It prints ReachOut on to the console","D":"Compilation Error in Super class","E":"Compilation Error in Sub class","F":"","G":"","H":"","I":"","J":""},"explanation":"Parent (Super) class constructor is invoked by `super();` (all letters in lowercase) from within the constructor of subclass.\n\nFirst statement inside no-argument constructor of Sub class is: `Super();` (Letter 'S' is in uppercase) and hence it causes compilation error."},{"id":26,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.io.FileNotFoundException;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            System.out.println(args[1].length());\n        } catch (RuntimeException ex) {\n            System.out.println(\"ONE\");\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"TWO\");\n        }\n        System.out.println(\"THREE\");\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error","B":"None of the System.out.println statements is executed","C":"TWO\nTHREE","D":"THREE","E":"ONE\nTHREE","F":"","G":"","H":"","I":"","J":""},"explanation":"java.io.FileNotFoundException exception is a checked exception.\n\n\n\nJava doesn't allow to catch specific checked exceptions if these are not thrown by the statements inside try block. catch(FileNotFoundException ex) {} causes compilation error in this case as System.out.println(1); will never throw FileNotFoundException.\n\n\n\nNOTE: Java allows to catch Exception type. catch(Exception ex) {} will never cause compilation error."},{"id":27,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Base {\n    public void log() throws NullPointerException {\n        System.out.println(\"Base: log()\");\n    }\n}\n \nclass Derived extends Base {\n    public void log() throws RuntimeException {\n        System.out.println(\"Derived: log()\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base obj = new Derived();\n        obj.log();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"Compilation error in Derived class","B":"Derived: log()","C":"Base: log()","D":"Compilation error in Test class","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"NullPointerException extends RuntimeException. Overriding method may or may not throw any RuntimeException. Only thing to remember is that if overridden method throws any unchecked exception or Error, then overriding method must not throw any checked exceptions.\n\nSo, method log() in Derived class correctly overrides Base class's method.\n\nRest is simple polymorphism. 'obj' refers to an instance of Derived class and hence obj.log(); invokes method log() of Derived class, which prints \"Derived: log()\" on to the console."},{"id":28,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Currency {\n    String notation = \"-\"; //Line n1\n \n    String getNotation() { //Line n2\n        return notation;\n    }\n}\n \nclass USDollar extends Currency {\n    String notation = \"$\"; //Line n3\n \n    String getNotation() { //Line n4\n        return notation;\n    }\n}\n \nclass Euro extends Currency {\n    protected String notation = \"€\"; //Line n5\n \n    protected String getNotation() { //Line n6\n        return notation;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Currency c1 = new USDollar();\n        System.out.println(c1.notation + \":\" + c1.getNotation());\n        \n        Currency c2 = new Euro();\n        System.out.println(c2.notation + \":\" + c2.getNotation());\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"B","answers":{"A":"Compilation error in Euro class","B":"-:$\n-:€","C":"-:-\n-:-","D":"$:$\n€:€","E":"Compilation error in USDollar class","F":"","G":"","H":"","I":"","J":""},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n3 hides the variable created at Line n1 and Line n4 overrides the getNotation() method of Line n2. There is no compilation error for USDollar class as it correctly overrides getNotation() method.\n\nSimilarly, Line n5 hides the variable created at Line n1 and Line n6 overrides the getNotation() method of Line n2. There is no compilation error for Euro class as it correctly overrides getNotation() method as well.\n\n\n\n'c1' is of Currency type, hence c1.notation refers to \"-\" and c1.getNotation() invokes overriding method of USDollar class and it returns \"$\".\n\nSimilarly, c2.notation refers to \"-\" and c2.getNotation() invokes overriding method of Euro class and it returns \"€\"."},{"id":29,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(new RuntimeException()); //Line n1\n        System.out.println(new RuntimeException(\"HELLO\")); //Line n2\n        System.out.println(new RuntimeException(new RuntimeException(\"HELLO\"))); //Line n3\n    }\n}\n\n\nDoes above code compile successfully?","type":"Single Choice","answer":"A","answers":{"A":"Yes","B":"No","C":"","D":"","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Throwable is the root class of the exception hierarchy and it contains some useful constructors:\n\n\n\n1. public Throwable() {...} : No-argument constructor\n\n2. public Throwable(String message) {...} : Pass the detail message\n\n3. public Throwable(String message, Throwable cause) {...} : Pass the detail message and the cause\n\n4. public Throwable(Throwable cause) {...} : Pass the cause\n\n\n\nException and RuntimeException classes also provide similar constructors.\n\n\n\nHence all 3 statements Line n1, Line n2 and Line n3 compile successfully.\n\n\n\nThrowable class also contains methods, which are inherited by all the subclasses (Exception, RuntimeException etc.)\n\n1. public String getMessage() {...} : Returns the detail message (E.g. detail message set by 2nd and 3rd constructor)\n\n2. public String toString() {} :\n\nReturns a short description of this throwable. The result is the concatenation of:\n\nthe name of the class of this object\n\n\": \" (a colon and a space)\n\nthe result of invoking this object's getLocalizedMessage() method\n\n\n\nIf getLocalizedMessage returns null, then just the class name is returned.\n\n\n\nBecause of the toString() method,\n\nLine n1 prints \"java.lang.RuntimeException\".\n\nLine n2 prints \"java.lang.RuntimeException: HELLO\"\n\nLine n3 prints \"java.lang.Exception: java.lang.RuntimeException: HELLO\""},{"id":30,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Parent {\n    String quote = \"MONEY DOESN'T GROW ON TREES\";\n}\n \nclass Child extends Parent {\n    String quote = \"LIVE LIFE KING SIZE\";\n}\n \nclass GrandChild extends Child {\n    String quote = \"PLAY PLAY PLAY\";\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        GrandChild gc = new GrandChild();\n        System.out.println(/*INSERT*/);\n    }\n}\n\n\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print MONEY DOESN'T GROW ON TREES on to the console?\n\nSelect 2 options.","type":"Multiple Choice","answer":"B,D","answers":{"A":"(Parent)(Child)gc.quote","B":"((Parent)gc).quote","C":"(Parent)gc.quote","D":"((Parent)(Child)gc).quote","E":"gc.quote","F":"","G":"","H":"","I":"","J":""},"explanation":"As instance variables are hidden by subclasses and not overridden, therefore instance variable can be accessed by using explicit casting.\n\nLet's check all the options one by one:\n\ngc.quote => It refers to \"PLAY PLAY PLAY\" as gc is of GrandChild class.\n\n\n\n(Parent)gc.quote => gc.quote will be evaluated first as dot (.) operator has higher precedence than cast. gc.quote refers to String, hence it cannot be casted to Parent type. This would cause compilation error.\n\n\n\n((Parent)gc).quote => Variable 'gc' is casted to Parent type, so this expression refers to \"MONEY DOESN'T GROW ON TREES\". It is one of the correct options.\n\n\n\n((Parent)(Child)gc).quote => 'gc' is of GrandChild type, it is first casted to Child and then to Parent type and finally quote variable is accessed, so this expression refers to \"MONEY DOESN'T GROW ON TREES\". It is also one of the correct options.\n\n\n\n(Parent)(Child)gc.quote => gc.quote will be evaluated first as dot (.) operator has higher precedence than cast. gc.quote refers to String, hence it cannot be casted to Child type. This would cause compilation error."},{"id":31,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\nclass A {\n    public static void main(String [] args) {\n        System.out.println(\"A\");\n    }\n}\n \nclass B { \n    public static void main(String [] args) {\n        System.out.println(\"B\");\n    }\n}\n \nclass C {\n    public static void main(String [] args) {\n        System.out.println(\"C\");\n    }\n}\n \nclass D {\n    public static void main(String [] args) {\n        System.out.println(\"D\");\n    }\n}\n\n\nWhich of the following options is correct?","type":"Single Choice","answer":"E","answers":{"A":"Test.java file will compile successfully but expected output is not possible","B":"To print C on to the console, execute below commands:\njavac C.java\njava C","C":"To print C on to the console, execute below commands:\njavac Test.java\njava Test","D":"Test.java file is not a valid java file as it doesn't contain code for class Test","E":"To print C on to the console, execute below commands:\njavac Test.java\njava C","F":"","G":"","H":"","I":"","J":""},"explanation":"Test.java is a valid java file. As none of the classes in Test.java file are public, hence file name can use any valid Java identifier.\n\nAs file name is Test.java, hence to compile the code below command is used:\n\njavac Test.java\n\n\n\nExecution of above command creates 4 class files: A.class, B.class, C.class & D.class.\n\nTo print C on to the console, class C must be executed. To execute C class, command is:\n\njava C"},{"id":32,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"B\"); //Line n1\n        sb.append(sb.append(\"A\")); //Line n2\n        System.out.println(sb); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"B","B":"BA","C":"BABA","D":"ABA","E":"ABBA","F":"ABAB","G":"AB","H":"Compilation error at Line n2","I":"BAB","J":""},"explanation":"At Line n1:\n\nsb --> {\"B\"}\n\n\n\nappend(...) method in StringBuilder class is overloaded to accept various arguments and 2 such arguments are String and CharSequence. It's return type is StringBuilder and as StringBuilder class implements CharSequence interface, hence 'sb.append(\"A\")' can easily be passed as and argument to sb.append(...) method. Line n2 compiles successfully.\n\nAt Line n2:\n\nsb.append(sb.append(\"A\")); //sb --> {\"B\"}\n\nsb.append({\"BA\"}); //sb --> {\"BA\"}\n\n{\"BABA\"}\n\n\n\nHence, Line n3 prints BABA"},{"id":33,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of TestMessage.java file:\n\npackage com.udayankhattry.oca;\n \nclass Message {\n    String msg = \"LET IT GO!\";\n    \n    public void print() {\n        System.out.println(msg);\n    }\n}\n \npublic class TestMessage {\n    public static void change(Message m) { //Line n5\n        m.msg = \"NEVER LOOK BACK!\"; //Line n6\n    }\n    \n    public static void main(String[] args) {\n        Message obj = new Message(); //Line n1\n        obj.print(); //Line n2\n        change(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}\n\n\nWhat will be the result of compiling and executing TestMessage class?","type":"Single Choice","answer":"F","answers":{"A":"Compilation error","B":"null\nNEVER LOOK BACK!","C":"null\nnull","D":"LET IT GO!\nLET IT GO!","E":"NEVER LOOK BACK!\nNEVER LOOK BACK!","F":"LET IT GO!\nNEVER LOOK BACK!","G":"","H":"","I":"","J":""},"explanation":"Message class doesn't specify any constructor, hence Java compiler adds below default constructor:\n\nMessage() {super();}\n\n\n\nLine n1 creates an instance of Message class and initializes instance variable 'msg' to \"LET IT GO!\". Variable 'obj' refers to this instance.\n\nLine n2 prints LET IT GO! on to the console.\n\nLine n3 invokes change(Message) method, as it is a static method defined in TestMessage class, hence `change(obj);` is the correct syntax to invoke it. Line n3 compiles successfully. On invocation parameter variable 'm' copies the content of variable 'obj' (which stores the address to Message instance created at Line n1). 'm' also refers to the same instance referred by 'obj'.\n\n\n\nLine n6, assigns \"NEVER LOOK BACK!\" to the 'msg' variable of the instance referred by 'm'. As 'obj' and 'm' refer to the same instance, hence obj.msg also refers to \"NEVER LOOK BACK!\". change(Message) method finishes its execution and control goes back to main(String[]) method.\n\n\n\nLine n4 is executed next, print() method is invoked on the 'obj' reference and as obj.msg refers to \"NEVER LOOK BACK!\", so this statement prints NEVER LOOK BACK! on to the console.\n\n\n\nHence in the output, you get:\n\nLET IT GO!\n\nNEVER LOOK BACK!"},{"id":34,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface Document {\n    default String getType() {\n        return \"TEXT\";\n    }\n}\n \ninterface WordDocument extends Document {\n    String getType();\n}\n \nclass Word implements WordDocument {}\n \npublic class Test {\n    public static void main(String[] args) {\n        Document doc = new Word(); //Line n1\n        System.out.println(doc.getType()); //Line n2\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"D","answers":{"A":"Interface Document causes compilation error","B":"Interface WordDocument causes compilation error","C":"Test class compiles successfully and on execution prints TEXT on to the console","D":"Class Word causes compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"As per Java 8, default methods were added in the interface. Interface Document defines default method getType(), there is no compilation error in interface Document. Method getType() is implicitly public in Document.\n\n\n\ninterface WordDocument extends Document and it overrides the default method getType() of Document, overriding method in WordDocument is implicitly abstract and public. An interface in java can override the default method of super type with abstract modifier. interface WordDocument compiles successfully.\n\n\n\nclass Word implements WordDocument and as WordDocument interface has abstract method getType(), and as class Word doesn't implement the getType() method hence it causes compilation failure."},{"id":35,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int ctr = 100;\n        one: for (int i = 0; i < 10; i++) {\n            two: for (int j = 0; j < 7; j++) {\n                three: while (true) {\n                    ctr++;\n                    if (i > j) {\n                        break one;\n                    } else if (i == j) {\n                        break two;\n                    } else {\n                        break three;\n                    }\n                }\n            }\n        }\n        System.out.println(ctr);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"103","B":"106","C":"102","D":"104","E":"105","F":"Compilation error","G":"101","H":"100","I":"","J":""},"explanation":"For the 1st loop variable 'i' infers to int type, so no issues for 1st loop and for the 2nd loop variable 'j' infers to int type, so no issues for 2nd loop as well.\n\nLet's check the iteration:\n\n1st iteration of loop one: i = 0\n\n    1st iteration of loop two: j = 0\n\n        1st iteration of loop three: ctr = 101. As `i == j` evaluates to true, hence `break two;` gets executed, which takes the control out of loop two and hence to the increment expression (i++) of loop one.\n\n2nd iteration of loop one; i = 1\n\n    1st iteration of loop two: j = 0\n\n        1st iteration of loop three; ctr = 102. As `i > j` evaluates to true, hence `break one;` gets executed, which takes the control out of the loop one.\n\n\n\n`System.out.println(ctr);` prints 102 on to the console."},{"id":36,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider incomplete code of M.java file\n\nclass M {\n}\n \n________ class N {\n}\n\n\nFollowing options are available to fill the above blank:\n\n1. public\n\n2. private\n\n3. protected\n\n4. final\n\n5. abstract\n\n\n\nHow many above options can be used to fill above blank (separately and not together) such that there is no compilation error?","type":"Single Choice","answer":"C","answers":{"A":"Only four options","B":"Only one option","C":"Only two options","D":"Only three options","E":"All five options","F":"","G":"","H":"","I":"","J":""},"explanation":"Top-level class can use only two access modifiers [public and default(don't specify anything)]. private and protected cannot be used.\n\nAs file name is M.java, hence class N cannot be public.\n\nTop-level class can be final, hence it is a correct option.\n\nTop-level class can be abstract and hence it is also a correct option."},{"id":37,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = {\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\"};\n        String place = \"faraway\";\n        System.out.println(arr[place.indexOf(\"a\", 3)]); //Line n1\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"An exception is raised by Line n1","B":"2nd","C":"3rd","D":"4th","E":"5th","F":"1st","G":"","H":"","I":"","J":""},"explanation":"`int indexOf​(String str, int fromIndex)` method of String class returns the index within this string of the first occurrence of the specified substring, starting at the specified index. e.g.\n\n\"alaska\".indexOf(\"a\", 1) returns 2\n\n\"alaska\".indexOf(\"a\", 2) returns 2\n\n\"alaska\".indexOf(\"a\", 3) returns 5\n\n\n\nIn the given question, 'arr' refers to a String array of size 5. Element at index 0 refers to \"1st\", element at index 1 refers to \"2nd\" and so on.\n\n\n\nLet's solve the given expression of Line n1:\n\narr[place.indexOf(\"a\", 3)]\n\n= arr[\"faraway\".indexOf(\"a\", 3)] //Starts looking for \"a\" from index 3 of the given String \"faraway\" and \"a\" is found at index 3.\n\n= arr[3]\n\n= \"4th\" //Array element at index 3 refers to \"4th\".\n\n\n\nHence, 4th is printed on to the console."},{"id":38,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        boolean b1 = 0;\n        boolean b2 = 1;\n        System.out.println(b1 + b2);\n    }\n}\n\n\nWhat is the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"0","B":"true","C":"false","D":"Compilation error","E":"1","F":"","G":"","H":"","I":"","J":""},"explanation":"In Java language, boolean type can store only two values: true and false and these values are not compatible with int type.\n\nAlso + operator is not defined for boolean types. Hence, all the 3 statements inside main method causes compilation error."},{"id":39,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code snippet:\n\n\n\nint i = 10;\nSystem.out.println(i > 3 != false);\n\n\nWhat is the result?","type":"Single Choice","answer":"B","answers":{"A":"null","B":"true","C":"false","D":"Compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Given Expression:\n\ni > 3 != false\n\nIt has 2 operators > and !=. > has higher precedence over !=, hence given expression can be written as:\n\n(i > 3) != false\n\nLet's solve above expression:\n\ntrue != false\n\ntrue\n\n\n\nHence true is printed on to the console."},{"id":40,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n \nclass Base {\n    Base() throws IOException {\n        System.out.print(1);\n    }\n}\n \nclass Derived extends Base {\n    Derived() throws FileNotFoundException {\n        System.out.print(2);\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) throws Exception {\n        new Derived();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Compilation error in both Base and Derived classes","B":"Compilation error only in Base class","C":"Compilation error only in Derived class","D":"Test class executes successfully and prints 12 on to the console","E":"Test class executes successfully and prints 21 on to the console","F":"","G":"","H":"","I":"","J":""},"explanation":"It is legal for the constructors to have throws clause.\n\nConstructors are not inherited by the Derived class so there is no method overriding rules related to the constructors but as one constructor invokes other constructors implicitly or explicitly by using this(...) or super(...), hence exception handling becomes interesting.\n\n\n\nJava compiler adds super(); as the first statement inside Derived class's constructor:\n\nDerived() throws FileNotFoundException {\n\n    super(); //added by the compiler\n\n    System.out.print(2);\n\n}\n\n\n\nAs super(); invokes the constructor of Base class (which declares to throw IOException), compiler complains as Derived class no-argument constructor doesn't declare to throw IOException. It declares to throw FileNotFoundException (subclass of IOException), which is not enough for the instances of IOException."},{"id":41,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface Perishable1 {\n    default int maxDays() {\n        return 1;\n    }\n}\n \ninterface Perishable2 extends Perishable1 {\n    default int maxDays() {\n        return 2;\n    }\n}\n \nclass Milk implements Perishable2, Perishable1 {}\n \npublic class Test {\n    public static void main(String[] args) {\n        Perishable1 obj = new Milk();\n        System.out.println(obj.maxDays());\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"B","answers":{"A":"Interface Perishable2 causes compilation error","B":"Given code compiles successfully and on execution Test class prints 2 on to the console","C":"Given code compiles successfully and on execution Test class prints 1 on to the console","D":"Class Milk causes compilation error","E":"Class Test causes compilation error","F":"","G":"","H":"","I":"","J":""},"explanation":"As per Java 8, default methods were added in the interface. Interface Perishable1 defines default method maxDays(), there is no compilation error in interface Perishable1. Method maxDays() is implicitly public in Perishable1.\n\n\n\ninterface Perishable2 extends Perishable1 and it overrides the default method maxDays() of Document, overriding method in Perishable2 is implicitly public. Interface Perishable2 compiles successfully.\n\n\n\nClass Milk implements Perishable2 and Perishable1. Although it is redundant for Milk class to implement Preishable1 as Perishable2 already extends Perishable1.\n\nThere is no conflict in Milk class as it inherits the default method maxDays() of Perishable2 interface. Milk class compiles successfully.\n\n\n\n`Perishable1 obj = new Milk();` It compiles fine as Perishable1 is supertype and Milk is subtype.\n\n`obj.maxDays()` executes the default maxDays() method of Perishable2 interface and it returns 2. `System.out.println(obj.maxDays());` prints 2 on to the console."},{"id":42,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Counter {\n    static int ctr = 0;\n    int count = 0;\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Counter ctr1 = new Counter();\n        Counter ctr2 = new Counter();\n        Counter ctr3 = new Counter();\n        \n        for(int i = 1; i <= 5; i++ ) {\n            ctr1.ctr++;\n            ctr1.count++;\n            ctr2.ctr++;\n            ctr2.count++;\n            ctr3.ctr++;\n            ctr3.count++;\n        }\n        \n        System.out.println(ctr3.ctr + \":\" + ctr3.count);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"15:5 is printed on to the console","B":"Compilation error","C":"15:15 is printed on to the console","D":"5:5 is printed on to the console","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Each instance of the class contains separate copies of instance variable and share one copy of static variable.\n\nThere are 3 instances of Counter class created by main method and these are referred by ctr1, ctr2 and ctr3.\n\nAs 'ctr' is a static variable of Counter class, hence ctr1.ctr, ctr2.ctr and ctr3.ctr refer to the same variable. In fact, 'Counter.ctr' is the preferred way to refer the static variable 'ctr' but ctr1.ctr, ctr2.ctr and ctr3.ctr are also allowed.\n\n\n\nAs 'count' is an instance variable, so there are 3 separate copies: ctr1.count, ctr2.count, ctr3.count.\n\n\n\nOn the completion of for loop: ctr1.count = 5, ctr2.count = 5 and ctr3.count = 5 and Counter.ctr = 15.\n\n\n\n15:5 is printed on to the console."},{"id":43,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void getReport() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            throw null; //Line 10\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            getReport(); //Line 16\n        } catch(SQLException e) {\n            System.out.println(\"REPORT ERROR\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Line 10 causes compilation failure","B":"Line 16 causes compilation failure","C":"REPORT ERROR is printed on to the console and program terminates successfully","D":"Program ends abruptly","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Classes in Exception framework are normal java classes, hence null can be used wherever instances of Exception classes are used, so Line 10 compiles successfully.\n\nNo issues with Line 16 as method getReport() declares to throw SQLException and main(String []) method code correctly handles it.\n\n\n\nProgram compiles successfully but on execution, NullPointerException is thrown, stack trace is printed on to the console and program ends abruptly.\n\n\n\nIf you debug the code, you would find that internal routine for throwing null exception causes NullPointerException."},{"id":44,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nabstract class Log {\n    abstract long count(); //Line n1\n    abstract Object get(); //Line n2\n}\n \nclass CommunicationLog extends Log {\n    int count() { //Line n3\n        return 100;\n    }\n    \n    String get() { //Line n4\n        return \"COM-LOG\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Log log = new CommunicationLog(); //Line n5\n        System.out.print(log.count());\n        System.out.print(log.get());\n    }\n}\n\n\nWhich of the following statement is correct?","type":"Single Choice","answer":"B","answers":{"A":"Line n5 causes compilation error","B":"Line n3 causes compilation error","C":"Line n4 causes compilation error","D":"Given code compiles successfully and on execution prints 100COM-LOG on to the console","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"CommunicationLog class overrides count() and get() methods of Log class.\n\nThere are 2 rules related to return types:\n\n1. If return type of overridden method is of primitive type, then overriding method should use same primitive type.\n\n2. If return type of overridden method is of reference type, then overriding method can use same reference type or its sub-type (also known as covariant return type).\n\n\n\ncount() method at Line n1 returns long but overriding method at Line n3 returns int and that is why Line n3 causes compilation error.\n\nget() method at Line n2 returns Object but overriding method at Line n4 returns String. String is a subclass of Object, so it is a case of covariant return type and hence allowed. Line n4 compiles successfully."},{"id":45,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        char c1 = 'a'; //ASCII code of 'a' is 97\n        int i1 = c1; //Line n1\n        System.out.println(i1); //Line n2\n    }\n}\n\n\nWhat is the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Line n1 causes runtime error","B":"Line n1 causes compilation failure","C":"97","D":"a","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Range of char data type is from 0 to 65535 and hence it can be easily assigned to int type. println() method is overloaded to accept char type and int type both. If char type value is passed, it prints char value and if int type value is passed, it prints int value.\n\nAs i1 is of int type, hence corresponding int value, which is 97, is printed on to the console."},{"id":46,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"2020-08-31\");\n        System.out.println(date.plusMonths(-6));\n    }\n}\n\n\nWhat is the result?","type":"Single Choice","answer":"C","answers":{"A":"2020-02-31","B":"An exception is thrown at runtime","C":"2/29/2020","D":"2020-02-28","E":"Compilation error","F":"2020-02-30","G":"","H":"","I":"","J":""},"explanation":"plusMonths(long) method of LocalDate class returns a copy of this LocalDate with the specified number of months added. Negative argument will subtract the passed month(s), hence date.plusMonths(-6) doesn't cause any compilation error.\n\nThis method adds the specified amount to the months field in three steps:\n\n    Add the input months to the month-of-year field\n\n    Check if the resulting date would be invalid\n\n    Adjust the day-of-month to the last valid day if necessary\n\n\n\nFor the given code,\n\n2020-08-31 plus -6 months would subtract 6 months from the given date and would result in the invalid date 2020-02-31. Instead of returning an invalid result, the last valid day of the month, 2020-02-29, is returned.\n\nPlease note, 2020 is leap year and hence last day of February is 29 and not 28."},{"id":47,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface Rideable {\n    void ride(String name);\n}\n \nclass Animal {}\n \nclass Horse extends Animal implements Rideable {\n    public void ride(String name) {\n        System.out.println(name.toUpperCase() + \" IS RIDING THE HORSE\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Animal horse = new Horse();\n        /*INSERT*/\n    }\n}\n\n\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print EMMA IS RIDING THE HORSE on to the console?\n\nSelect 4 options.","type":"Multiple Choice","answer":"A,D,G,H","answers":{"A":"((Rideable)(Horse)horse).ride(\"EMMA\");","B":"(Horse)(Rideable)horse.ride(\"EMMA\");","C":"horse.ride(\"EMMA\");","D":"((Horse)horse).ride(\"Emma\");","E":"(Horse)horse.ride(\"EMMA\");","F":"(Rideable)horse.ride(\"emma\");","G":"((Horse)(Rideable)horse).ride(\"emma\");","H":"((Rideable)horse).ride(\"emma\");","I":"(Rideable)(Horse)horse.ride(\"EMMA\");","J":""},"explanation":"Let's check all the options one by one:\n\nhorse.ride(\"EMMA\"); ✗ Variable 'horse' is of Animal type and ride(String) method is not defined in Animal class, therefore it causes compilation error.\n\n\n\n(Horse)horse.ride(\"EMMA\"); ✗ horse.ride(\"EMMA\") will be evaluated first as dot (.) operator has higher precedence than cast. horse.ride(\"EMMA\") returns void, hence it cannot be casted to Horse type. This would cause compilation error.\n\n\n\n((Horse)horse).ride(\"Emma\"); ✓ Variable 'horse' refers to an instance of Horse type and variable 'horse' is casted to Horse type. Horse class has ride(String) method, hence no compilation error. ride(String) method of Horse class will get invoked at runtime and will print the expected output. As, name.toUpperCase() method is invoked, hence it doesn't matter in what case you pass the name, in the output name will always be displayed in the upper case.\n\n\n\n(Rideable)horse.ride(\"emma\"); ✗ horse.ride(\"EMMA\") will be evaluated first as dot (.) operator has higher precedence than cast. horse.ride(\"EMMA\") returns void, hence it cannot be casted to Rideable type. This would cause compilation error.\n\n\n\n((Rideable)horse).ride(\"emma\"); ✓ Variable 'horse' refers to an instance of Horse type and variable 'horse' is casted to Rideable type (super type of Horse). Rideable interface has ride(String) method, hence no compilation error. ride(String) method of Horse class will get invoked at runtime and will print the expected output.\n\n\n\n(Rideable)(Horse)horse.ride(\"EMMA\"); ✗ horse.ride(\"EMMA\") will be evaluated first as dot (.) operator has higher precedence than cast. horse.ride(\"EMMA\") returns void, hence it cannot be casted to Horse type. This would cause compilation error.\n\n\n\n(Horse)(Rideable)horse.ride(\"EMMA\"); ✗ horse.ride(\"EMMA\") will be evaluated first as dot (.) operator has higher precedence than cast. horse.ride(\"EMMA\") returns void, hence it cannot be casted to Rideable type. This would cause compilation error.\n\n\n\n((Rideable)(Horse)horse).ride(\"EMMA\"); ✓ Variable 'horse' refers to an instance of Horse type, it is first casted to Horse type and then casted to Rideable type. Rideable interface has ride(String) method, hence no compilation error. ride(String) method of Horse class will get invoked at runtime and will print the expected output.\n\n\n\n((Horse)(Rideable)horse).ride(\"emma\"); ✓ Variable 'horse' refers to an instance of Horse type, it is first casted to Rideable type and then casted to Horse type. Horse class has ride(String) method, hence no compilation error. ride(String) method of Horse class will get invoked at runtime and will print the expected output."},{"id":48,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int num = 10;\n        if(num++ == num++) {\n            System.out.println(\"EQUAL \" + num);\n        } else {\n            System.out.println(\"NOT EQUAL \" + num);\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"EQUAL 12","B":"NOT EQUAL 12","C":"NOT EQUAL 11","D":"EQUAL 11","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Given boolean expression:\n\n(num++ == num++) //num=10\n\n(10 == num++) //Left side operand is evaluated first, value 10 is used in the expression and variable num is incremented by 1, so num=11\n\n(10 == 11) //Right side operand is evaluated next, value 11 is used in the expression and variable num is incremented by 1, so num = 12\n\nAbove expression evaluates to false, hence else block is executed and NOT EQUAL 12 is printed on to the console."},{"id":49,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.io.IOException;\n \nclass Super {\n    Super() throws RuntimeException {\n        System.out.print(\"CARPE \");\n    }\n}\n \nclass Sub extends Super {\n    Sub() throws IOException {\n        System.out.print(\"DIEM \");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) throws Exception {\n        new Sub();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"Test class executes successfully and prints DIEM CARPE on to the console","B":"Compilation error in both Super and Sub classes","C":"Compilation error only in Super class","D":"Compilation error only in Sub class","E":"Test class executes successfully and prints CARPE DIEM on to the console","F":"","G":"","H":"","I":"","J":""},"explanation":"It is legal for the constructors to have throws clause.\n\nConstructors are not inherited by the Sub class so there is no method overriding rules related to the constructors but as one constructor invokes other constructors implicitly or explicitly by using this(...) or super(...), hence exception handling becomes interesting.\n\n\n\nJava compiler adds super(); as the first statement inside Sub class's constructor:\n\nSub() throws IOException {\n\n    super(); //added by the compiler\n\n    System.out.println(\"DIEM\");\n\n}\n\n\n\nsuper(); invokes the constructor of Super class (which declares to throw RuntimeException), as RuntimeException is unchecked exception, therefore no handling is necessary in the constructor of Sub class.\n\nSub class's constructor declares to throw IOException but main(String []) method handles it.\n\n\n\nThere is no compilation error and output is: CARPE DIEM"},{"id":50,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npublic class Test {\n    public static void main(String [] args) {\n        System.out.println(\"String\");\n    }\n    \n    public static void main(Integer [] args) {\n        System.out.println(\"Integer\");\n    }\n    \n    public static void main(byte [] args) {\n        System.out.println(\"byte\");\n    }\n}\n\n\nAnd the commands:\n\njavac Test.java\n\njava Test 10\n\n\n\nWhat is the result?","type":"Single Choice","answer":"D","answers":{"A":"An Exception is thrown at runtime","B":"byte","C":"Compilation error","D":"String","E":"Integer","F":"","G":"","H":"","I":"","J":""},"explanation":"Like any other method, main method can also be overloaded. But main method called by JVM is always with String [] parameter. Don't get confused with 10 as it is passed as \"10\".\n\nExecute above class with any command line arguments or 0 command line argument, output will always be \"String\"."},{"id":51,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    private static void div(int i, int j) {\n        try {\n            System.out.println(i / j);\n        } catch(ArithmeticException e) {\n            throw (RuntimeException)e;\n        }\n    }\n    \n    public static void main(String[] args) {\n        try {\n            div(5, 0);\n        } catch(ArithmeticException e) {\n            System.out.println(\"AE\");\n        } catch(RuntimeException e) {\n            System.out.println(\"RE\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"AE is printed on to the console and program terminates successfully","B":"RE is printed on to the console and program terminates successfully","C":"Program ends abruptly","D":"Compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Any RuntimeException can be thrown without any need it to be declared in throws clause of surrounding method.\n\n\n\n`throw (RuntimeException)e;` doesn't cause any compilation error.\n\n\n\nEven though variable 'e' is type casted to RuntimeException but exception object is still of ArithmeticException, which is caught in main method and 'AE' is printed to the console."},{"id":52,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            play();\n            return;\n        } catch(Exception ex) {\n            System.out.println(ex.getMessage());\n            return;\n        } finally {\n            System.out.println(\"MATCH ABANDONED\");\n        }\n        System.out.println(\"DONE\");\n    }\n \n    static void play() throws Exception {\n        throw new Exception(\"INJURED\");\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error","B":"INJURED\nMATCH ABANDONED","C":"MATCH ABANDONED","D":"INJURED\nDONE","E":"INJURED\nMATCH ABANDONED\nDONE","F":"MATCH ABANDONED\nDONE","G":"INJURED","H":"","I":"","J":""},"explanation":"Both try and catch blocks have return; statement, which means either of the return statements will definitely get executed. Hence, compiler tags `System.out.println(\"DONE\");` as unreachable and this causes compilation error."},{"id":53,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void getData() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            e = new SQLException();\n            throw e;\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            getData();\n        } catch(SQLException e) {\n            System.out.println(\"SQL\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Program ends abruptly","B":"SQL is printed on to the console and program terminates successfully","C":"Method main(String []) causes compilation error","D":"Method getData() causes compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"If you don't initialize variable e inside catch block using `e = new SQLException();` and simply throw e, then code would compile successfully as compiler is certain that 'e' would refer to an instance of SQLException only.\n\n\n\nBut the moment compiler finds `e = new SQLException();`, `throw e;` causes compilation error as at runtime 'e' may refer to any Exception type."},{"id":54,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code fragment:\n\n\n\nString place = \"MISSS\";\nSystem.out.println(place.replace(\"SS\", \"T\"));\n\n\nWhat is the output?","type":"Single Choice","answer":"C","answers":{"A":"MIT","B":"MISSS","C":"MITS","D":"MIST","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"According to Javadoc, replace(CharSequence target, CharSequence replacement) method of String class returns a new String object after replacing each substring of this string that matches the literal target sequence with the specified literal replacement sequence. The replacement proceeds from the beginning of the string to the end, for example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in \"ba\" rather than \"ab\".\n\n\n\n\"MISSS\".replace(\"SS\", \"T\"); returns \"MITS\"."},{"id":55,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> list;\n        list = new ArrayList<>(); //Line n1\n        list.add(\"A\");\n        list.add(\"E\");\n        list.add(\"I\");\n        list.add(\"O\");\n        list.add(\"U\");\n        list.addAll(list.subList(0, 4)); //Line n2\n        System.out.println(list);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"[A, E, I, O, U, A, E, I, O, U]","B":"[A, E, I, O, U, A, E, I, O]","C":"Line n2 causes compilation error","D":"An exception is thrown at runtime by Line n2","E":"Line n1 causes compilation error","F":"[A, E, I, O, U]","G":"","H":"","I":"","J":""},"explanation":"Starting with JDK 7, Java allows to not specify type while initializing the ArrayList. As variable list is of List<String> type, therefore type of ArrayList is considered as String. Line n1 compiles successfully.\n\n\n\nsublist method is declared in List interface:\n\nList<E> subList(int fromIndex, int toIndex)\n\nfromIndex is inclusive and toIndex is exclusive\n\nIt returns a view of the portion of this list between the specified fromIndex and toIndex. The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list and vice-versa.\n\nIf returned list (or view) is structurally modified, then modification are reflected in this list as well but if this list is structurally modified, then the semantics of the list returned by this method become undefined.\n\nIf fromIndex == toIndex, then returned list is empty.\n\nIf fromIndex < 0 OR toIndex > size of the list OR fromIndex > toIndex, then IndexOutOfBoundsException is thrown.\n\n\n\nAt Line n2, list.subList(0, 4) --> [A, E, I, O] (toIndex is Exclusive, therefore start index is 0 and end index is 3].\n\n\n\nlist.addAll(list.subList(0, 4)); is almost equal to list.addAll(5, [A, E, I, O]); => Inserts A at index 5, E takes index 6, I takes index 7 and O is placed at index 8. list --> [A, E, I, O, U, A, E, I, O]\n\n\n\nLast statement inside main(String []) method prints [A, E, I, O, U, A, E, I, O] on to the console."},{"id":56,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Predicate;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> words = new ArrayList<>();\n        words.add(\"A\");\n        words.add(\"an\");\n        words.add(\"the\");\n        words.add(\"when\");\n        words.add(\"what\");\n        words.add(\"Where\");\n        words.add(\"whether\");\n \n        processStringArray(words, /*INSERT*/);\n    }\n \n    private static void processStringArray(List<String> list, Predicate<String> predicate) {\n        for(String str : list) {\n            if(predicate.test(str)) {\n                System.out.println(str);\n            }\n        }\n    }\n}\n\n\nWhich of the following options can replace /*INSERT*/ such that on executing Test class all the list elements are displayed in the output?\n\nSelect 4 options.","type":"Multiple Choice","answer":"C,D,F,G","answers":{"A":"p -> p.length() < 7","B":"String p -> p.length() > 0","C":"p -> p.length() >= 1","D":"(String p) -> p.length() < 100","E":"p -> !!false","F":"p -> true","G":"p -> !!!!true","H":"","I":"","J":""},"explanation":"Interface java.util.function.Predicate<T> declares below non-overriding abstract method:\n\nboolean test(T t);\n\n\n\nLet's check all the options one by one:\n\np -> true ✓ Means test method returns true for the passed String. It will print all the elements of the List.\n\np -> !!!!true ✓ !!!!true => !!!false => !!true => !false => true, means test method returns true for the passed String. It will print all the elements of the List.\n\np -> !!false ✗ !!false => !true => false, means test method returns false for the passed String. It will not print even a single element of the list.\n\np -> p.length() >= 1 ✓ Means test method returns true if passed String's length is greater than or equal to 1 and this is true for all the list elements. \n\np -> p.length() < 7 ✗ Means test method returns true if passed String's length is less than 7 and this is not true for \"whether\". \"whether\" will not be displayed in the output. \n\n(String p) -> p.length() < 100 ✓ Means test method returns true if passed String's length is less than 100 and this is true for all the list elements.\n\nString p -> p.length() > 0 ✗ Round brackets or parenthesis are missing around 'String p'. This causes compilation error."},{"id":57,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface M {\n    public static void log() {\n        System.out.println(\"M\");\n    }\n}\n \nabstract class A {\n    public static void log() { \n        System.out.println(\"N\");\n    }\n}\n \nclass MyClass extends A implements M {}\n \npublic class Test {\n    public static void main(String[] args) {\n        M obj1 = new MyClass();\n        obj1.log(); //Line n1\n        \n        A obj2 = new MyClass();\n        obj2.log(); //Line n2\n        \n        MyClass obj3 = new MyClass();\n        obj3.log(); //Line n3\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"F","answers":{"A":"Given code compiles successfully","B":"There is a compilation error in class A","C":"There is a compilation error in interface M","D":"Line n2 causes compilation error","E":"Line n3 causes compilation error","F":"Line n1 causes compilation error","G":"","H":"","I":"","J":""},"explanation":"As per Java 8, default and static methods were added in the interface. Interface M defines static method log(), there is no compilation error in interface M.\n\nAlso the scope of static log() method of M is limited to interface M and it can be invoked by using Interface name only, M.log().\n\n\n\nAbstract class A also defines the static log() method. Abstract class can have 0 or more abstract methods. Hence, no compilation error in class A as well.\n\n\n\nSuper type reference variable can refer to an instance of Sub type, therefore the statement `M obj1 = new MyClass();` compiles successfully.\n\nobj1 is of M type, hence `obj1.log();` tries to tag the static method of M but static log() method of M can only be invoked by using M.log();.\n\nTherefore, Line n1 causes compilation error.\n\n\n\nScope of static log() method of A is not limited to class A only but MyClass also gets A.log() method in its scope.\n\nThere are different ways in which static method of an abstract class can be accessed:\n\n1. By using the name of the abstract class: A.log(); //Preferred way\n\n2. By using the reference variable of abstract class: A o1 = null; o1.log();\n\n3. By using the name of the subclass: MyClass.log();\n\n4. By using the reference variable of the subclass: MyClass o2 = null; o2.log();\n\nHence, Line n2 and Line n3 compile successfully."},{"id":58,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code fragment:\n\nprivate void emp() {}\n\n\n\nAnd the statements:\n\n1. Given code compiles successfully if it is used inside the class named 'emp'\n\n2. Given code compiles successfully if it is used inside the class named 'Emp'\n\n3. Given code compiles successfully if it is used inside the class named 'employee'\n\n4. Given code compiles successfully if it is used inside the class named 'Employee'\n\n5. Given code compiles successfully if it is used inside the class named 'Student'\n\n6. Given code compiles successfully if it is used inside the class named '_emp_'\n\n\n\nHow many statements are true?","type":"Single Choice","answer":"C","answers":{"A":"Only one statement","B":"Three statements","C":"All six statements","D":"Five statements","E":"Four statements","F":"Two statements","G":"","H":"","I":"","J":""},"explanation":"`private void emp() {}` is a valid method declaration.\n\nClass name and method name can be same and that is why given method can be declared in any of the given classes: 'emp', 'Emp', 'employee', 'Employee', 'Student' and '_emp_'.\n\n'_emp_' is also a valid Java identifier."},{"id":59,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void convert(String s)\n            throws IllegalArgumentException, RuntimeException, Exception {\n        if(s.length() == 0) {\n            throw new RuntimeException(\"LENGTH SHOULD BE GREATER THAN 0\");\n        }\n    }\n    public static void main(String [] args) {\n        try {\n            convert(\"\");\n        }\n        catch(IllegalArgumentException | RuntimeException | Exception e) { //Line 14\n            System.out.println(e.getMessage()); //Line 15\n        } //Line 16\n        catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\nLine 14 causes compilation error. Which of the following changes enables to code to print LENGTH SHOULD BE GREATER THAN 0?","type":"Single Choice","answer":"A","answers":{"A":"Replace Line 14 with 'catch(RuntimeException e) {'","B":"Comment out Line 14, Line 15 and Line 16","C":"Replace Line 14 with 'catch(IllegalArgumentException | Exception e) {'","D":"Replace Line 14 with 'catch(RuntimeException | Exception e) {'","E":"Replace Line 14 with 'catch(IllegalArgumentException | RuntimeException e) {'","F":"","G":"","H":"","I":"","J":""},"explanation":"Throwable is the root class of the exception hierarchy and it contains some useful constructors:\n\n\n\n1. public Throwable() {...} : No-argument constructor\n\n2. public Throwable(String message) {...} : Pass the detail message\n\n3. public Throwable(String message, Throwable cause) {...} : Pass the detail message and the cause\n\n4. public Throwable(Throwable cause) {...} : Pass the cause\n\n\n\nException and RuntimeException classes also provide similar constructors.\n\n\n\nThrowable class also contains methods, which are inherited by all the subclasses (Exception, RuntimeException etc.)\n\n1. public String getMessage() {...} : Returns the detail message (E.g. detail message set by 2nd and 3rd constructor)\n\n2. public String toString() {} :\n\nReturns a short description of this throwable. The result is the concatenation of:\n\nthe name of the class of this object\n\n\": \" (a colon and a space)\n\nthe result of invoking this object's getLocalizedMessage() method\n\n\n\nIf getLocalizedMessage() returns null, then just the class name is returned.\n\n\n\n\n\nIn multi-catch statement, classes with multi-level hierarchical relationship can't be used.\n\nRuntimeException is subclass of Exception, IllegalArgumentException is indirect subclass of Exception and IllegalArgumentException is subclass of RuntimeException, hence these pairs can't be used in multi-catch statement.\n\n\n\nOnly one option is left to replace Line 14 with 'catch(RuntimeException e) {'.\n\n\n\nCommenting out Line 14, Line 15 and Line 16 will resolve the compilation error but it will print the whole stack trace rather than just printing the message."},{"id":60,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int [] arr = {10, 20, 30}; //Line n1\n        int i = 0;\n        arr[i++] = arr[++i] = 40; //Line n2\n        for(int x : arr)\n            System.out.println(x);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"F","answers":{"A":"An exception is thrown by Line n2","B":"10\n40\n30","C":"10\n20\n30","D":"10\n40\n40","E":"40\n40\n30","F":"40\n20\n40","G":"Compilation error at Line n2","H":"","I":"","J":""},"explanation":"At Line n1, an int [] object of three elements is created and 'arr' refers to this array object.\n\narr[0] = 10, arr[1] = 20 and arr[2] = 30;\n\n\n\nGiven expression at Line n2:\n\narr[i++] = arr[++i] = 40;\n\nMultiple assignment operators are available, so lets group it first.\n\n=> arr[i++] = (arr[++i] = 40); //Assignment operator is right to left associative\n\nAbove expression is valid, hence Line n2 compiles successfully.\n\nLet's solve the expression now. Left operand is 'arr[i++]' and right operand is '(arr[++i] = 40)'. Left operand is evaluated first.\n\n=> arr[0] = (arr[++i] = 40); //i = 1\n\nRight hand operand is evaluated next.\n\n=> arr[0] = (arr[2] = 40); //i = 2\n\n=> arr[0] = 40; //i = 2, arr[2] = 40.\n\nHence after Line n2, arr refers to int [] object {40, 20, 40}.\n\n\n\nGiven loop prints below on to the console:\n\n40\n\n20\n\n40"},{"id":61,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int elements = 0;\n        Object [] arr = {\"A\", \"E\", \"I\", new Object(), \"O\", \"U\"}; //Line n1\n        for(Object obj : arr) { //Line n2\n            if(obj instanceof String) {\n                continue;\n            } else {\n                break;\n            }\n            elements++; //Line n3\n        }\n        System.out.println(elements); //Line n4\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"F","answers":{"A":"Compilation error at Line n2","B":"Compilation error at Line n4","C":"0","D":"5","E":"3","F":"Compilation error at Line n3","G":"Compilation error at Line n1","H":"1","I":"6","J":""},"explanation":"Line n1 and Line n2 don't cause any compilation error.\n\n\n\nif-else block uses break; and continue; statements. break; will exit the loop and will take the control to Line n4 on the other hand continue; will take the control to Line n2. In both the cases Line n3 will never be executed.\n\nAs Compiler knows about it, hence it tags Line n3 as unreachable, which causes compilation error."},{"id":62,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"Game on\"; //Line n1\n        StringBuilder sb = new StringBuilder(str); //Line n2\n        \n        System.out.println(str.contentEquals(sb)); //Line n3\n        System.out.println(sb.contentEquals(str)); //Line n4\n        System.out.println(sb.equals(str)); //Line n5\n        System.out.println(str.equals(sb)); //Line n6\n    }\n}\nWhich of the following statements is correct?","type":"Single Choice","answer":"B","answers":{"A":"Two statements cause compilation error","B":"Only one statement causes compilation error","C":"Three statements cause compilation error","D":"No compilation error","E":"Four statements cause compilation error","F":"","G":"","H":"","I":"","J":""},"explanation":"There are no issues with Line n1 and Line n2, both the statements compile successfully.\n\n\n\nString class contains contentEquals(CharSequence) method. Please note that String, StringBuilder and StringBuffer classes implement CharSequence interface, hence contentEquals(CharSequence) method defined in String class cab be invoked with the argument of either String or StringBuilder or StringBuffer.\n\nAt Line n3, `str.contentEquals(sb)` is invoked with StringBuilder argument and hence it compiles fine. On execution it would compare the contents of String object and the passed StringBuilder object. As both the String object and StringBuilder object contains same content \"Game on\", hence on execution, Line n3 will print true.\n\n\n\ncontentEquals method is not available in StringBuilder class and hence Line n4 causes compilation error.\n\n\n\nequals method declared in Object class has the declaration: `public boolean equals(Object)`. Generally, equals method is used to compare different instances of same class but if you pass any other object, there is no compilation error. Parameter type is Object so it can accept any Java object.\n\n\n\n`str.equals(sb)` => It compiles fine, String class overrides equals(Object) method but as 'sb' is of StringBuilder type so `str.equals(sb)` would return false at runtime.\n\n\n\n`sb.equals(str)` => It also compiles fine, StringBuilder class doesn't override equals(Object) method. So Object version is invoked which uses == operator, hence `sb.equals(str)` would return false as well at runtime."},{"id":63,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    private static void test() throws Exception {\n        throw new Exception();\n    }\n    \n    public static void main(String [] args) {\n        try {\n            test();\n        } finally {\n            System.out.println(\"GAME ON\");\n        }\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"GAME ON is printed to the console, stack trace is printed and then program ends normally","B":"GAME ON is printed to the console and program ends normally","C":"GAME ON is printed to the console, stack trace is printed and then program ends abruptly","D":"Compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Method test() throws Exception (checked) and it declares to throw it, so no issues with method test().\n\nBut main(String []) method neither provides catch handler nor throws clause and hence main(String []) method causes compilation error.\n\nHandle or Declare rule should be followed for checked exception if you are not re-throwing it."},{"id":64,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        outer: for(int i = 0; i < 3; System.out.print(i)) {\n            i++;\n            inner: for(int j = 0; j < 3; System.out.print(j)) {\n                if(i > ++j) {\n                    break outer;\n                }\n            }\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"F","answers":{"A":"Program terminates successfully after printing 121 on to the console","B":"Program terminates successfully after printing 1 on to the console","C":"Program terminates successfully after printing 123 on to the console","D":"Compilation error","E":"Program terminates successfully after printing 0120 on to the console","F":"Program terminates successfully after printing 1231 on to the console","G":"Program terminates successfully after printing 12 on to the console","H":"Program terminates successfully but nothing is printed on to the console","I":"","J":""},"explanation":"Basic/Regular for loop has following form:\n\nfor ( [ForInit] ; [Expression] ; [ForUpdate] ) {...}\n\n[ForInit] can be local variable initialization or the following expressions:\n\nAssignment\n\nPreIncrementExpression\n\nPreDecrementExpression\n\nPostIncrementExpression\n\nPostDecrementExpression\n\nMethodInvocation\n\nClassInstanceCreationExpression\n\n\n\n[ForUpdate] can be following expressions:\n\nAssignment\n\nPreIncrementExpression\n\nPreDecrementExpression\n\nPostIncrementExpression\n\nPostDecrementExpression\n\nMethodInvocation\n\nClassInstanceCreationExpression\n\n\n\nThe [Expression] must have type boolean or Boolean, or a compile-time error occurs. If [Expression] is left blank, it evaluates to true.\n\n\n\nAll the expressions can be left blank; for(;;) is a valid for loop and it is an infinite loop as [Expression] is blank and evaluates to true.\n\n\n\nIn the given code, for both the loops, `System.out.print(...)` is used as [ForUpdate] expression, which is a MethodInvocation expression and hence a valid statement.\n\nGiven code compiles successfully.\n\n\n\nLet's check the iterations:\n\n1st iteration of outer: i = 0. i < 3 evaluates to true.\n\n    i = 1.\n\n    1st iteration of inner: j = 0. j < 3 evaluates to true as j = 0. Boolean expression `i > ++j` = `1 > 1` evaluates to false. j = 1.\n\n    2nd iteration of inner: `System.out.print(j)` prints 1 to the console. j < 3 evaluates to true as j = 1. Boolean expression `i > ++j` = `1 > 2` evaluates to false. j = 2.\n\n    3rd iteration of inner: `System.out.print(j)` prints 2 to the console. j < 3 evaluates to true as j = 2. Boolean expression `i > ++j` = `1 > 3` evaluates to false. j = 3.\n\n    4th iteration of inner: `System.out.print(j)` prints 3 to the console. j < 3 evaluates to false as j = 3. Control goes out of inner for loop and to the [ForUpdate] expression of outer loop.\n\n2nd iteration of outer: `System.out.print(i)` prints 1 to the console. i < 3 evaluates to true as i = 1.\n\n    i = 2.\n\n    1st iteration of inner: j = 0. j < 3 evaluates to true as j = 0. Boolean expression `i > ++j` = `2 > 1` evaluates to true. j = 1. ` break outer;` takes the control out of the outer for loop.\n\n\n\nProgram terminates successfully after printing 1231 on to the console."},{"id":65,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code fragment:\n\nimport java.util.*;\n \nclass A{}\nclass B extends A{}\n \nabstract class Super {\n    abstract List<A> get() throws IndexOutOfBoundsException;\n}\n \nabstract class Sub extends Super {\n    /*INSERT*/\n}\n\n\nWhich of the following options replaces /*INSERT*/ such that there is no compilation error?","type":"Single Choice","answer":"B","answers":{"A":"abstract List<B> get();","B":"abstract List<A> get() throws ArrayIndexOutOfBoundsException;","C":"abstract ArrayList<B> get();","D":"abstract ArrayList<A> get() throws Exception;","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Few things to keep in mind:\n\n1.\n\nThere are 2 rules related to return types of overriding method:\n\nA. If return type of overridden method is of primitive type, then overriding method should use same primitive type.\n\nB. If return type of overridden method is of reference type, then overriding method can use same reference type or its sub-type (also known as covariant return type).\n\n\n\n2.\n\nIn case of overriding, if overridden method declares to throw any RuntimeException or Error, overriding method may or may not throw any RuntimeException but overriding method must not throw any checked exceptions.\n\n\n\n3.\n\nIn generics syntax, Parameterized types are not polymorphic, this means even if B is subtype of A, List<B> is not subtype of List<A>. Remember this point. So below syntaxes are NOT allowed: \n\nList<A> list = new ArrayList<B>(); OR ArrayList<A> list = new ArrayList<B>();\n\n\n\n\n\nLet's check all the options one by one:\n\nabstract List<A> get() throws ArrayIndexOutOfBoundsException; => ✓ It returns the same return type 'List<A>' and it is allowed to throw any RuntimeException (ArrayIndexOutOfBoundsException is RuntimeException)\n\n\n\nabstract List<B> get(); => ✗ List<B> is not subtype of List<A>, it is not covariant return type.\n\n\n\nabstract ArrayList<A> get() throws Exception; => ✗ As overridden method declares to throw IndexOutOfBoundsException, which is a Runtime Exception, overriding method is not allowed to declare to throw any checked Exception. Class Exception and its subclasses are checked exceptions.\n\n\n\nabstract ArrayList<B> get(); => ✗ ArrayList<B> is not subtype of List<A>, it is not covariant return type."},{"id":66,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        String text = \"ONE \";\n        System.out.println(text.concat(text.concat(\"ELEVEN \")).trim());\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"ONE ONE ELEVEN","B":"ONE ELEVEN ONE","C":"ONE ELEVEN","D":"ONE ELEVEN ONE ELEVEN","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Given statement:\n\nSystem.out.println(text.concat(text.concat(\"ELEVEN \")).trim()); //'text' refers to \"ONE \"\n\nSystem.out.println(text.concat(\"ONE ELEVEN \").trim()); //As String is immutable, hence there is no change in the String object referred by 'text', 'text' still refers to \"ONE \"\n\nSystem.out.println((\"ONE ONE ELEVEN \").trim()); //'text' still refers to \"ONE \"\n\nSystem.out.println(\"ONE ONE ELEVEN\"); //trim() method removes the trailing space in this case\n\nONE ONE ELEVEN is printed on to the console."},{"id":67,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int x = 10; //Line n1\n        if (false)\n            System.out.println(x); //Line n2\n        System.out.println(\"HELLO\"); //Line n3\n    }\n}\n\n\nWhat is the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error at Line n1","B":"Compilation error at Line n3","C":"10\nHELLO","D":"HELLO","E":"Compilation error at Line n2","F":"","G":"","H":"","I":"","J":""},"explanation":"Even though compiler is aware that Line n2 will never execute, but it doesn't tag it as unreachable code. Reason for this odd behavior is explained in the Java Language specification:\n\nhttps://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.21\n\nFollowing statement results in a compile-time error:\n\nwhile (false) { x=3; }\n\nbecause the statement x=3; is not reachable; but the superficially similar case:\n\nif (false) { x=3; }\n\ndoes not result in a compile-time error. An optimizing compiler may realize that the statement x=3; will never be executed and may choose to omit the code for that statement from the generated class file, but the statement x=3; is not regarded as \"unreachable\" in the technical sense specified here.\n\n\n\nThe rationale for this differing treatment is to allow programmers to define \"flag\" variables such as:\n\n\n\nstatic final boolean DEBUG = false;\n\nand then write code such as:\n\n\n\nif (DEBUG) { x=3; }\n\nThe idea is that it should be possible to change the value of DEBUG from false to true or from true to false and then compile the code correctly with no other changes to the program text.\n\n\n\nLine n2 is not executed but Line n3 executes successfully and prints HELLO on to the console."},{"id":68,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    int i1 = 10;\n    static int i2 = 20;\n    \n    private void change1(int val) {\n        i1 = ++val; //Line n1\n        i2 = val++; //Line n2\n    }\n    \n    private static void change2(int val) {\n        i1 = --val; //Line n3\n        i2 = val--; //Line n4\n    }\n    \n    public static void main(String[] args) {\n        change1(5); //Line n5\n        change2(5); //Line n6\n        System.out.println(i1 + i2); //Line n7\n    }\n}\n\n\nWhich of the following statements are correct regarding above code?\n\nSelect 3 options.","type":"Multiple Choice","answer":"A,D,J","answers":{"A":"Line n5 causes compilation error","B":"Above code prints 30 on execution","C":"Line n1 causes compilation error","D":"Line n3 causes compilation error","E":"Above code prints 8 on execution","F":"Line n6 causes compilation error","G":"Above code compiles successfully","H":"Line n2 causes compilation error","I":"Line n4 causes compilation error","J":"Line n7 causes compilation error"},"explanation":"i1 is an instance variable and i2 is a static variable.\n\nInstance method can access both instance and static members. Hence, Line n1 and Line n2 compile successfully.\n\nStatic method can access only static members. Hence, Line n3 [accessing instance variable i1], Line n5 [accessing instance method change1(int)] and Line n7 [accessing instance variable i1] cause compilation error."},{"id":69,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Thought.java file:\n\npublic class Thought {\n    /*INSERT*/ {\n        System.out.println(\"All is well\");\n    }\n}\n\n\nWhich 3 options, if used to replace /*INSERT*/, will compile successfully and on execution will print \"All is well\" on to the console?","type":"Multiple Choice","answer":"D,F,H","answers":{"A":"protected static void main(String [] args)","B":"public void main(String... args)","C":"public void static main(String [] args)","D":"static public void main(String [] args)","E":"public static Void main(String [] args)","F":"public static void main(String... a)","G":"static public void Main(String [] args)","H":"public static void main(String [] a)","I":"","J":""},"explanation":"As System.out.println needs to be executed on executing the Test class, this means special main method should replace /*INSERT*/.\n\nSpecial main method's name should be \"main\" (all characters in lower case), should be static, should have public access specifier and it accepts argument of String [] type (Varargs syntax String... can also be used). String [] argument can use any identifier name, even though in most of the cases you will see \"args\" is used. Position of static and public can be changed but return type 'void' must come just before the method name.\n\n\n\nLet's check all the given options one by one:\n\npublic void static main(String [] args): Compilation error as return type 'void' must come just before the method name 'main'.\n\nprotected static void main(String [] args): Compiles successfully but as this method is not public, hence an Error regarding missing main method is thrown on execution.\n\npublic void main(String... args): Compiles successfully but as this method is not static, hence an Error regarding non-static main method is thrown on execution.\n\nstatic public void Main(String [] args): Compiles successfully but as 'M' is capital in method 'Main', hence it is not special main method. An Error regarding missing main method is thrown on execution.\n\nstatic public void main(String [] args): Valid definition, it compiles successfully and on execution prints \"All is well\" on to the console.\n\npublic static void main(String [] a): Valid definition, it compiles successfully and on execution prints \"All is well\" on to the console.\n\npublic static Void main(String [] args): Compilation error as Void is a final class in Java and in this case compiler expects main method to return a value of Void type. If you add `return null;` to the main method code will compile successfully but on execution an Error will be thrown mentioning that return type must be 'void' ('v' in lower-case).\n\npublic static void main(String... a): Valid definition, it compiles successfully and on execution prints \"All is well\" on to the console."},{"id":70,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Below is the code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> places = new ArrayList<>();\n        places.add(\"Austin\");\n        places.add(\"Okinawa\");\n        places.add(\"Giza\");\n        places.add(\"Manila\");\n        places.add(\"Batam\");\n        places.add(\"Giza\");\n        \n        if(places.remove(\"Giza\"))\n            places.remove(\"Austin\");\n        \n        System.out.println(places);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"Compilation error","B":"[Austin, Okinawa, Manila, Batam]","C":"An exception is thrown at runtime","D":"[Austin, Okinawa, Giza, Manila, Batam, Giza]","E":"[Okinawa, Manila, Batam, Giza]","F":"[Okinawa, Giza, Manila, Batam]","G":"[Austin, Okinawa, Manila, Batam, Giza]","H":"[Okinawa, Manila, Batam]","I":"","J":""},"explanation":"remove(Object) method of List interface removes the first occurrence of the specified element from the list, if it is present. If this list does not contain the element, it is unchanged. remove(Object) method returns true, if removal was successful otherwise false. Initially list has: [Austin, Okinawa, Giza, Manila, Batam, Giza]. places.remove(\"Giza\") removes the first occurrence of \"Giza\" and after the successful removal, list has: [Austin, Okinawa, Manila, Batam, Giza]. places.remove(\"Giza\") returns true, control goes inside if block and executes places.remove(\"Austin\"); places list contains \"Austin\", so after the removal list has: [Okinawa, Manila, Batam, Giza]."},{"id":71,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        try { //outer\n            try { //inner\n                System.out.println(1/0);\n            } catch(ArithmeticException e) {\n                System.out.println(\"INNER\");\n            } finally {\n                System.out.println(\"FINALLY 1\");\n            }\n        } catch(ArithmeticException e) {\n            System.out.println(\"OUTER\");\n        } finally {\n            System.out.println(\"FINALLY 2\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"INNER\nFINALLY 2","B":"INNER\nFINALLY 1\nFINALLY 2","C":"INNER\nFINALLY 1","D":"OUTER\nFINALLY 2","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"`System.out.println(1/0);` throws ArithmeticException, handler is available in inner catch-block, it executes and prints \"INNER\" to the console.\n\n\n\nOnce an exception is handled, no other catch block will get executed unless the exception is re-thrown.\n\n\n\nInner finally-block gets executed and prints \"FINALLY 1\" to the console.\n\n\n\nRule is finally-block always gets executed, so outer finally-block gets executed and prints \"FINALLY 2\" to the console."},{"id":72,"trainingUnit":"OCA","trainingContent":"Exam 6 (Bonus exam)","question":"Consider below codes of 2 java files:\n\n//Flyable.java\npackage com.udayankhattry.oca;\n \npublic interface Flyable {\n    static int horizontalDegree() { //Line n1\n        return 20;\n    }\n \n    default void fly() {\n        System.out.println(\"Flying at \" + horizontalDegree() + \" degrees.\"); //Line n2\n    }\n \n    void land();\n}\n\n\n//Aeroplane.java\npackage com.udayankhattry.oca;\n \npublic class Aeroplane implements Flyable {\n    public void land() {\n        System.out.println(\"Landing at \" + -Flyable.horizontalDegree() + \" degrees.\"); //Line n3\n    }\n \n    public static void main(String[] args) {\n        new Aeroplane().fly();\n        new Aeroplane().land();\n    }\n}\n\n\nWhat will be the result of compiling and executing Aeroplane class?","type":"Single Choice","answer":"B","answers":{"A":"Compilation error at Line n3","B":"Given code compiles successfully and on execution prints below in the output:\nFlying at 20 degrees.\nLanding at -20 degrees.","C":"Compilation error at Line n1","D":"Compilation error at Line n2","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"As per Java 8, default and static methods were added in the interface and default methods can invoke static method as well. Hence, there is no issue with the Flyable interface.\n\n\n\nclass Aeroplane implements Flyable interface, hence it inherits the default method fly() and static method horizontalDegree() can be accessed using Flyable.horizontalDegree(). It also provides the implementation of land() method. There is no issue with Aeroplane class as well.\n\n\n\nOn execution below text is printed on to the console:\n\nFlying at 20 degrees.\n\nLanding at -20 degrees."}]