[{"id":1,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"package com.github.oca;\n \nclass TestException extends Exception {\n    public TestException() {\n        super();\n    }\n    \n    public TestException(String s) {\n        super(s);\n    }\n}\n \npublic class Test {\n    public void m1() throws __________ {\n        throw new TestException();\n    }\n}\nFor the above code, fill in the blank with one option.","type":"Single Choice","answer":"A","answers":{"A":"Exception","B":"Object","C":"RuntimeException","D":"Error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Method m1() throws an instance of TestException, which is a checked exception as it extends Exception class.\n\nSo in throws clause we must provide:\n\n1. Checked exception.\n\n2. Exception of TestException type or it's super types (Exception, Throwable), Object cannot be used in throws clause."},{"id":2,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"public class Test {\n    private static int [] arr;\n    public static void main(String [] args) {\n        if(arr.length > 0 && arr != null) {\n            System.out.println(arr[0]);\n        }\n    }\n}\nPredict Output, if the above code is run with given command?\njava Test","type":"Single Choice","answer":"C","answers":{"A":"Compilation error","B":"No Output","C":"NullPointerException is thrown at runtime","D":"ArrayIndexOutOfBoundsException is thrown at runtime","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Variable arr is a class variable of int [] type, so by default it is initialized to null.\n\nIn if block, arr.length > 0 is checked first. Accessing length property on null reference throws NullPointerException.\n\n\n\nCorrect logical if block declaration should be:\n\nif(arr != null && arr.length > 0)\n\n\n\nFirst check for null and then access properties/methods."},{"id":3,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing the following program?\n\npackage com.github.oca;\n \nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n \nabstract class Super {\n    public abstract void m1() throws IOException;\n}\n \nclass Sub extends Super {\n    @Override\n    public void m1() throws IOException {\n        throw new FileNotFoundException();\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Super s = new Sub();\n        try {\n            s.m1();\n        } catch (IOException e) {\n            System.out.print(\"A\");\n        } catch(FileNotFoundException e) {\n            System.out.print(\"B\");\n        } finally {\n            System.out.print(\"C\");\n        }\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"AC","B":"BC","C":"class Sub gives compilation error","D":"class Test gives compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"FileNotFoundException extends IOException and hence catch block of FileNotFoundException should appear before the catch block of IOException.\n\nTherefore, class Test causes compilation error."},{"id":4,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n \nabstract class Super {\n    public abstract void m1() throws IOException;\n}\n \nclass Sub extends Super {\n    @Override\n    public void m1() throws IOException {\n        throw new FileNotFoundException();\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Super s = new Sub();\n        try {\n            s.m1();\n        } catch (FileNotFoundException e) {\n            System.out.print(\"X\");\n        } catch (IOException e) {\n            System.out.print(\"Y\");\n        } finally {\n            System.out.print(\"Z\");\n        }\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"XZ","B":"YZ","C":"XYZ","D":"Compilation Error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Even though method m1() declares to throw IOException but at runtime an instance of FileNotFoundException is thrown.\n\nA catch handler for FileNotFoundException is available and hence X is printed on to the console.\n\nAfter that finally block is executed, which prints Z to the console."},{"id":5,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n \nabstract class Super {\n    public abstract void m1() throws IOException;\n}\n \nclass Sub extends Super {\n    @Override\n    public void m1() throws IOException {\n        throw new FileNotFoundException();\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Super s = new Sub();\n        try {\n            s.m1();\n        } catch (FileNotFoundException e) {\n            System.out.print(\"M\");\n        } finally {\n            System.out.print(\"N\");\n        }\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"MN","B":"N","C":"Compilation error","D":"Program ends abruptly","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Even though an instance of FileNotFoundException is thrown by method m1() at runtime, but method m1() declares to throw IOException.\n\nReference variable s is of Super type and hence for compiler, call to s.m1(); is to method m1() of Super, which throws IOException.\n\nAnd as IOException is checked exception hence calling code should handle it.\n\n\n\nAs calling code doesn't handle IOException or its super type, so s.m1(); causes compilation error."},{"id":6,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    private static void m1() {\n        System.out.println(1/0);\n    }\n    \n    public static void main(String[] args) {\n        try {\n            m1();\n        } finally {\n            System.out.println(\"A\");\n        }\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"A is printed to the console and program ends normally.","B":"A is printed to the console, stack trace is printed and then program ends normally.","C":"A is printed to the console, stack trace is printed and then program ends abruptly.","D":"Compilation error.","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Method m1() throws an instance of ArithmeticException and method m1() doesn't handle it, so it forwards the exception to calling method main.\n\nMethod main doesn't handle ArithmeticException so it forwards it to JVM, but just before that finally block is executed. This prints A on to the console.\n\nAfter that JVM prints the stack trace and terminates the program abruptly."},{"id":7,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Which of the following keywords is used to manually throw an exception?","type":"Single Choice","answer":"A","answers":{"A":"throw","B":"throws","C":"thrown","D":"catch","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"catch is for catching the exception and not throwing it.\n\nthrown is not a java keyword.\n\nthrows is used to declare the exceptions a method can throw.\n\nTo manually throw an exception, throw keyword is used. e.g., throw new Exception();"},{"id":8,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    private static void m1() throws Exception {\n        throw new Exception();\n    }\n    \n    public static void main(String[] args) {\n        try {\n            m1();\n        } finally {\n            System.out.println(\"A\");\n        }\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"A is printed to the console and program ends normally.","B":"A is printed to the console, stack trace is printed and then program ends normally.","C":"A is printed to the console, stack trace is printed and then program ends abruptly.","D":"Compilation error.","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Method m1() throws Exception (checked) and it declares to throw it, so no issues with method m1().\n\nBut main() method neither provides catch handler nor throws clause and hence main method causes Compilation error.\n\nHandle or Declare rule should be followed for checked exception if you are not re-throwing it."},{"id":9,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Which of the following is a checked Exception?","type":"Single Choice","answer":"B","answers":{"A":"ClassCastException","B":"FileNotFoundException","C":"ExceptionInInitializerError","D":"RuntimeException","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"ClassCastException extends RuntimeException (unchecked exception),\n\nFileNotFoundException extends IOException, IOException extends Exception (checked exception),\n\nExceptionInInitializerError is from Error family and is thrown by an static initializer block,\n\nRuntimeException and all its sub classes are unchecked exceptions."},{"id":10,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    private static String s;\n    public static void main(String[] args) {\n        try {\n            System.out.println(s.length());\n        } catch(NullPointerException | RuntimeException ex) {\n            System.out.println(\"DONE\");\n        }\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"DONE","B":"Executes successfully but no output","C":"Compilation error","D":"None of the above","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"NullPointerException extends RuntimeException and in multi-catch syntax we can't specify multiple Exceptions related to each other in multilevel inheritance."},{"id":11,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \nclass Base {\n    public void m1() throws NullPointerException {\n        System.out.println(\"Base: m1()\");\n    }\n}\n \nclass Derived extends Base {\n    public void m1() throws RuntimeException {\n        System.out.println(\"Derived: m1()\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base obj = new Derived();\n        obj.m1();\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"Base: m1()","B":"Derived: m1()","C":"Compilation error in Derived class","D":"Compilation error in Test class","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"NullPointerException extends RuntimeException, but there are no overriding rules related to unchecked exceptions.\n\nSo, method m1() in Derived class correctly overrides Base class method.\n\nRest is simple polymorphism. obj refers to an instance of Derived class and hence obj.m1(); invokes method m1() of Derived class, which prints \"Derived: m1()\" to the console."},{"id":12,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider the following interface declaration:\n\npublic interface I1 {\n    void m1() throws java.io.IOException;\n}\nWhich of the following incorrectly implements interface I1?","type":"Single Choice","answer":"D","answers":{"A":"public class C1 implements I1 {\n     public void m1() {}\n }","B":"public class C2 implements I1 {\n     public void m1() throws java.io.FileNotFoundException{}\n }","C":"public class C3 implements I1 {\n     public void m1() throws java.io.IOException{}\n }","D":"public class C4 implements I1 {\n     public void m1() throws Exception{}\n }","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"NOTE: Question is asking for \"incorrect\" implementation and not \"correct\" implementation.\n\n\n\nAccording to overriding rules, if super class / interface method declares to throw a checked exception, then overriding method of sub class / implementer class has following options:\n\n1. May not declare to throw any checked exception,\n\n2. May declare to throw the same checked exception thrown by super class / interface method,\n\n3. May declare to throw the sub class of the exception thrown by super class / interface method,\n\n4. Cannot declare to throw the super class of the exception thrown by super class / interface method"},{"id":13,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Which of the following are Java Exception classes? Select 3 options.","type":"Multiple Choice","answer":"A,C,D","answers":{"A":"ClassCastException","B":"NullException","C":"NumberFormatException","D":"IllegalArgumentException","E":"ArrayIndexException","F":"","G":"","H":"","I":"","J":""},"explanation":"ClassCastException, NumberFormatException and IllegalArgumentException are Runtime exceptions.\n\nThere are no exception classes in java with the names: NullException and ArrayIndexException."},{"id":14,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given Code:\n\npackage com.github.oca;\n \nimport java.io.*;\n \nclass ReadTheFile {\n    static void print() { //Line 4\n        throw new IOException(); //Line 5\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) { //Line 10\n        ReadTheFile.print(); //Line 11\n        //Line 12\n    }\n}\nWhich 2 changes are necessary so that code compiles successfully?","type":"Multiple Choice","answer":"A,F","answers":{"A":"Replace Line 4 with static void print() throws Exception {","B":"Replace Line 4 with static void print() throws Throwable {","C":"Replace Line 10 with public static void main(String[] args) throws IOException {","D":"Surround Line 11 with below try-catch block:\n try {\n     ReadTheFile.print();\n } catch(IOException e) {\n     e.printStackTrace();\n }","E":"Surround Line 11 with below try-catch block:\n try {\n     ReadTheFile.print();\n } catch(IOException | Exception e) {\n     e.printStackTrace();\n }","F":"Surround Line 11 with below try-catch block:\n try {\n     ReadTheFile.print();\n } catch(Exception e) {\n     e.printStackTrace();\n }","G":"","H":"","I":"","J":""},"explanation":"This question is tricky as 2 changes are related and not independent. Let's first check the reason for compilation error.\n\nLine 5 throws a checked exception, IOException but it is not declared in the throws clause. So, print method should have throws clause for IOException or the classes in top hierarchy such as Exception or Throwable.\n\nBased on this deduction, Line 4 can be replaced with either \"static void print() throws Exception {\" or \"static void print() throws Throwable\" but we will have to select one out of these as after replacing Line 4, Line 11 will start giving error as we are not handling the checked exception at Line 11.\n\nThis part is easy, do we have other options, which mention \"Throwable\"? NO. Then mark the first option as \"Replace Line 4 with static void print() throws Exception {\".\n\nAs, print() method throws Exception, so main method should handle Exception or its super type and not it's subtype. Two options working only with IOException can be ruled out.\n\nMulti-catch statement \"catch(IOException | Exception e)\" gives compilation error as IOException and Exception are related to each other in multilevel inheritance. So you are left with only one option to pair with our 1st choice:\n\nSurround Line 11 with below try-catch block:\n\ntry {\n    ReadTheFile.print();\n} catch(Exception e) {\n    e.printStackTrace();\n}"},{"id":15,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            main(args);\n        } catch (Exception ex) {\n            System.out.println(\"CATCH-\");\n        }\n        System.out.println(\"OUT\");\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"CATCH-OUT","B":"OUT","C":"None of the System.out.println statement is executed","D":"Compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"main(args) method is invoked recursively without specifying any exit condition, so this code ultimately throws java.lang.StackOverflowError. StackOverflowError is a subclass of Error type and not Exception type, hence it is not handled. Stack trace is printed to the console and program ends abruptly.\n\n\n\nJava doesn't allow to catch specific checked exceptions if these are not thrown by the statements inside try block.\n\ncatch(java.io.FileNotFoundException ex) {} will cause compilation error in this case as main(args); will never throw FileNotFoundException. But Java allows to catch Exception type, hence catch (Exception ex) {} doesn't cause any compilation error."},{"id":16,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        try {\n            for(;;) {\n                sb.append(\"OCA\");\n            }\n        } catch(Exception e) {\n            System.out.println(\"Exception!!!\");\n        }\n        System.out.println(\"Main ends!!!\");\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"\"Main ends!!!\" is printed on to the console and program terminates successfully","B":"\"Exception!!!\" and \"Main ends!!!\" are printed on to the console and program terminates successfully","C":"\"Exception!!!\" is printed on to the console and program terminates successfully","D":"\"Exception!!!\" is printed on to the console and program terminates abruptly","E":"Program terminates abruptly","F":"","G":"","H":"","I":"","J":""},"explanation":"for(;;) is an infinite loop and hence `sb.append(\"OCA\");` causes OutOfMemoryError which is a subclass of Error class.\n\nmain(String []) method throws OutOfMemoryError and program terminates abruptly."},{"id":17,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\n//Test.java\npackage com.github.oca;\n \nimport java.io.FileNotFoundException;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            System.out.println(1);\n        } catch (NullPointerException ex) {\n            System.out.println(\"ONE\");\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"TWO\");\n        }\n        System.out.println(\"THREE\");\n    }\n}","type":"Single Choice","answer":"E","answers":{"A":"ONE\nTHREE","B":"TWO\nTHREE","C":"THREE","D":"None of the System.out.println statements are executed","E":"Compilation error","F":"","G":"","H":"","I":"","J":""},"explanation":"Java doesn't allow to catch specific checked exceptions if these are not thrown by the statements inside try block.\n\ncatch(FileNotFoundException ex) {} causes  compilation error in this case as System.out.println(1); will never throw FileNotFoundException.\n\n\n\nNOTE: Java allows to catch Exception type. catch(Exception ex) {} will never cause compilation error."},{"id":18,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider codes of 3 java files:\n\n//Class1.java\npackage com.github.oca;\n \nimport java.io.FileNotFoundException;\n \npublic class Class1 {\n    public void read() throws FileNotFoundException {}\n}\n//Class2.java\npackage com.github.oca;\n \npublic class Class2 {\n    String Class2;\n    public void Class2() {}\n}\n//Class3.java\npackage com.github.oca;\n \npublic class Class3 {\n    private void print() {\n        private String msg = \"HELLO\";\n        System.out.println(msg);\n    }\n}\nWhich of the following statement is true?","type":"Single Choice","answer":"D","answers":{"A":"Only Class1.java compiles successfully","B":"Only Class2.java compiles successfully","C":"Only Class3.java compiles successfully","D":"Class1.java and Class2.java compile successfully","E":"Class1.java and Class3.java compile successfully","F":"Class2.java and Class3.java compile successfully","G":"","H":"","I":"","J":""},"explanation":"Method declaring checked exception in its throws clause doesn't mean that it should have code to actually throw that type of Exceptions. So even though read() method of Class1 declares to throw FileNotFoundException but its body doesn't actually throw an instance of FileNotFoundException. \n\nVariable and method name can be same as class name, so code of Class2 is also valid. Remember: Though you don't get any compilation error but it is not recommended to use the Class name for variable and method names.\n\nLOCAL variable can be declared with final modifier only. msg variable inside print() method of Class3 is declared private and this causes compilation error."},{"id":19,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        m1(); //Line 3\n    }\n    \n    private static void m1() throws Exception { //Line 6\n        System.out.println(\"NOT THROWING ANY EXCEPTION\"); //Line 7\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"Compilation error at Line 3","B":"Compilation error at Line 6","C":"Compilation error at Line 7","D":"NOT THROWING ANY EXCEPTION","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"If a method declares to throw Exception or its sub-type other than RuntimeException types, then calling method should follow handle or declare rule.\n\nIn this case, as method m1() declares to throw Exception, so main method should either declare the same exception or its super type in its throws clause OR m1(); should be surrounded by try-catch block.\n\nLine 3 in this case causes compilation error."},{"id":20,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code: \n\npackage com.github.oca;\n \npublic class Test {\n    static {\n        System.out.println(1/0);\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"HELLO\");\n    }\n}\nOn execution, does Test class print \"HELLO\" on to the console?","type":"Single Choice","answer":"B","answers":{"A":"Yes, HELLO is printed on to the console","B":"No, HELLO is not printed on the console","C":"","D":"","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"To invoke the special main method, JVM loads the class in the memory.\n\nAt that time, static initializer block is invoked. 1/0 throws a RuntimeException and as a result static initializer block throws an instance of java.lang.ExceptionInInitializerError."},{"id":21,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code: \n\npackage com.github.oca;\n \npublic class Test {\n    static Double d1;\n    static int x = d1.intValue();\n    \n    public static void main(String[] args) {\n        System.out.println(\"HELLO\");\n    }\n}\nOn execution, does Test class print \"HELLO\" on to the console?","type":"Single Choice","answer":"B","answers":{"A":"Yes, HELLO is printed on to the console","B":"No, HELLO is not printed on the console","C":"","D":"","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"To invoke the special main method, JVM loads the class in the memory. At that time, static fields of Test class are initialized. d1 is of Double type so null is assigned to it.\n\nx is also static variable so d1.intValue(); is executed and as d1 is null hence d1.intValue() throws a NullPointerException and as a result an instance of  java.lang.ExceptionInInitializerError is thrown."},{"id":22,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code: \n\npackage com.github.oca;\n \npublic class Test {\n    static Double d1;\n    int x = d1.intValue();\n    \n    public static void main(String[] args) {\n        System.out.println(\"HELLO\");\n    }\n}\nOn execution, does Test class print \"HELLO\" on to the console?","type":"Single Choice","answer":"A","answers":{"A":"Yes, HELLO is printed on to the console","B":"No, HELLO is not printed on the console","C":"","D":"","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"To invoke the special main method, JVM loads the class in the memory. At that time, static fields of Test class are initialized. d1 is of Double type so null is assigned to it.\n\nx is not static variable, so int x = d1.intValue(); is not executed. Class is loaded successfully in the memory and \"HELLO\" is printed on to the console.\n\n\n\nNOTE: new Test() will throw NullPointerException but not ExceptionInInitializerError."},{"id":23,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\n\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Error obj = new Error();\n        boolean flag1 = obj instanceof RuntimeException; //Line n1\n        boolean flag2 = obj instanceof Exception; //Line n2\n        boolean flag3 = obj instanceof Error; //Line n3\n        boolean flag4 = obj instanceof Throwable; //Line n4\n        System.out.println(flag1 + \":\" + flag2 + \":\" + flag3 + \":\" + flag4);\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"Compilation error","B":"false:false:true:true","C":"false:true:true:true","D":"true:true:true:true","E":"false:false:true:false","F":"","G":"","H":"","I":"","J":""},"explanation":"class Error extends Throwable, so `obj instanceof Error;` and `obj instanceof Throwable;` return true.\n\nBut Error class is not related to Exception and RuntimeException classes in multilevel inheritance and that is why Line n1 and Line n2 cause compilation error."},{"id":24,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Fill in the blanks for the definition of java.lang.Error class:\n\npublic class java.lang.Error extends ________________ {...}","type":"Single Choice","answer":"C","answers":{"A":"RuntimeException","B":"Exception","C":"Throwable","D":"","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"An Error is a subclass of Throwable class."},{"id":25,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(new RuntimeException()); //Line n1\n        System.out.println(new RuntimeException(\"HELLO\")); //Line n2\n        System.out.println(new RuntimeException(new RuntimeException(\"HELLO\"))); //Line n3\n    }\n}\n\n\nDoes above code compile successfully?","type":"Single Choice","answer":"A","answers":{"A":"Yes","B":"No","C":"","D":"","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Throwable is the root class of the exception hierarchy and it contains some useful constructors:\n\n\n\n1. public Throwable() {...} : No-argument constructor\n\n2. public Throwable(String message) {...} : Pass the detail message\n\n3. public Throwable(String message, Throwable cause) {...} : Pass the detail message and the cause\n\n4. public Throwable(Throwable cause) {...} : Pass the cause\n\n\n\nException and RuntimeException classes also provide similar constructors.\n\n\n\nHence all 3 statements Line n1, Line n2 and Line n3 compile successfully.\n\n\n\nThrowable class also contains methods, which are inherited by all the subclasses (Exception, RuntimeException etc.)\n\n1. public String getMessage() {...} : Returns the detail message (E.g. detail message set by 2nd and 3rd constructor)\n\n2. public String toString() {} :\n\nReturns a short description of this throwable. The result is the concatenation of:\n\nthe name of the class of this object\n\n\": \" (a colon and a space)\n\nthe result of invoking this object's getLocalizedMessage() method\n\n\n\nIf getLocalizedMessage returns null, then just the class name is returned.\n\n\n\nBecause of the toString() method,\n\nLine n1 prints \"java.lang.RuntimeException\".\n\nLine n2 prints \"java.lang.RuntimeException: HELLO\"\n\nLine n3 prints \"java.lang.Exception: java.lang.RuntimeException: HELLO\""},{"id":26,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \ninterface ILogger {\n    void log();\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        ILogger [] loggers = new ILogger[2]; //Line n1\n        for(ILogger logger : loggers)\n            logger.log(); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Line n1 causes compilation error","B":"Line n2 causes compilation error","C":"An exception is thrown at runtime","D":"No output is displayed but program terminates successfully","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Line n1 creates an array instance of ILogger containing 2 elements. null is assigned to both the array elements. Line n1 compiles successfully.\n\n\n\nAs, log() method is declared in ILogger interface, hence statement at Line n2: logger.log(); doesn't cause any compilation error. Compiler is happy to see that log() method is invoked on the reference variable of ILogger type.\n\n\n\n1st iteration:\n\nlogger --> null, logger.log(); throws NullPointerException as method log() is invoked on null reference."},{"id":27,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.io.FileNotFoundException;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            System.out.println(args[1].length());\n        } catch (RuntimeException ex) {\n            System.out.println(\"ONE\");\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"TWO\");\n        }\n        System.out.println(\"THREE\");\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"ONE\nTHREE","B":"TWO\nTHREE","C":"THREE","D":"None of the System.out.println statements is executed","E":"Compilation error","F":"","G":"","H":"","I":"","J":""},"explanation":"java.io.FileNotFoundException exception is a checked exception.\n\n\n\nJava doesn't allow to catch specific checked exceptions if these are not thrown by the statements inside try block. catch(FileNotFoundException ex) {} causes compilation error in this case as System.out.println(1); will never throw FileNotFoundException.\n\n\n\nNOTE: Java allows to catch Exception type. catch(Exception ex) {} will never cause compilation error."},{"id":28,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    private static void div() {\n        System.out.println(1/0);\n    }\n \n    public static void main(String[] args) {\n        try {\n            div();\n        } finally {\n            System.out.println(\"FINALLY\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"FINALLY is printed to the console and program ends normally","B":"FINALLY is printed to the console, stack trace is printed and then program ends normally","C":"FINALLY is printed to the console, stack trace is printed and then program ends abruptly","D":"Compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"As method div() doesn't declare to throw any Checked Exception, hence main(String []) method is not suppose to handle it, try-finally without catch is valid here. There is no compilation error in the code.\n\n\n\nMethod div() throws an instance of ArithmeticException and method div() doesn't handle it, so it forwards the exception to calling method main(String []).\n\nMethod main(String []) doesn't handle ArithmeticException so it forwards it to JVM, but just before that, finally block is executed. This prints FINALLY on to the console.\n\nAfter that JVM prints the stack trace and terminates the program abruptly."},{"id":29,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    private static void test() throws Exception {\n        throw new Exception();\n    }\n    \n    public static void main(String [] args) {\n        try {\n            test();\n        } finally {\n            System.out.println(\"GAME ON\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"GAME ON is printed to the console and program ends normally","B":"GAME ON is printed to the console, stack trace is printed and then program ends normally","C":"GAME ON is printed to the console, stack trace is printed and then program ends abruptly","D":"Compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Method test() throws Exception (checked) and it declares to throw it, so no issues with method test().\n\nBut main(String []) method neither provides catch handler nor throws clause and hence main(String []) method causes compilation error.\n\nHandle or Declare rule should be followed for checked exception if you are not re-throwing it."},{"id":30,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.io.IOException;\nimport java.sql.SQLException;\n \npublic class Test {\n    public static void main(String[] args) {\n        /*INSERT*/\n    }\n \n    private static void save() throws IOException {}\n \n    private static void log() throws SQLException {}\n}\n\n\nWhich of the block of codes can be used to replace /*INSERT*/ such that there is no compilation error?\n\nSelect 3 options.","type":"Multiple Choice","answer":"A,B,F","answers":{"A":"try {\n    save();\n    log();\n} catch(IOException | SQLException ex) {}","B":"try {\n    save();\n    log();\n} catch(SQLException | IOException ex) {}","C":"try {\n    save();\n    log();\n} catch(IOException | Exception ex) {}","D":"try {\n    save();\n    log();\n} catch(SQLException | Exception ex) {}","E":"try {\n    save();\n    log();\n} catch(Exception | RuntimeException ex) {}","F":"try {\n    save();\n    log();\n} catch(Exception ex) {}","G":"","H":"","I":"","J":""},"explanation":"save() method throws IOException (which is a Checked Exception) and log() method throws SQLException (which is also a Checked Exception).\n\n\n\nLet's check all the options one by one (I am just using the catch-block as try-block of all the options are same):\n\ncatch(IOException | SQLException ex) {}: ✓ As IOException and SQLException are not related to each other in multi-level inheritance, hence this multi-catch syntax is valid.\n\n\n\ncatch(SQLException | IOException ex) {}: ✓ Same as above, order of exceptions in multi-catch syntax doesn't matter.\n\n\n\ncatch(IOException | Exception ex) {}: ✗ Causes compilation error as IOException extends Exception.\n\n\n\ncatch(SQLException | Exception ex) {}: ✗ Causes compilation error as SQLException extends Exception.\n\n\n\ncatch(Exception | RuntimeException ex) {}: ✗ Causes compilation error as RuntimeException extends Exception.\n\n\n\ncatch(Exception ex) {}: ✓ As Exception is the super class of both IOException and SQLException, hence it can handle both the exceptions."},{"id":31,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        try { //outer\n            try { //inner\n                System.out.println(1/0);\n            } catch(ArithmeticException e) {\n                System.out.println(\"INNER\");\n            } finally {\n                System.out.println(\"FINALLY 1\");\n            }\n        } catch(ArithmeticException e) {\n            System.out.println(\"OUTER\");\n        } finally {\n            System.out.println(\"FINALLY 2\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"INNER\nFINALLY 1","B":"OUTER\nFINALLY 2","C":"INNER\nFINALLY 2","D":"INNER\nFINALLY 1\nFINALLY 2","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"'`System.out.println(1/0);` throws ArithmeticException, handler is available in inner catch-block, it executes and prints \"INNER\" to the console.\n\n\n\nOnce an exception is handled, no other catch block will get executed unless the exception is re-thrown.\n\n\n\nInner finally-block gets executed and prints \"FINALLY 1\" to the console.\n\n\n\nRule is finally-block always gets executed, so outer finally-block gets executed and prints \"FINALLY 2\" to the console."},{"id":32,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            try {\n                System.out.println(args[1]); //Line n1\n            } catch(RuntimeException e) {\n                System.out.print(\"INHALE-\"); //Line n2\n                throw e; //Line n3\n            } finally {\n                System.out.print(\"EXHALE-\"); //Line n4\n            }\n        } catch(RuntimeException e) {\n            System.out.print(\"INHALE-\"); //Line n5\n        } finally {\n            System.out.print(\"EXHALE\"); //Line n6\n        }\n    }\n}\n\n\nAnd the commands:\n\njavac Test.java\n\njava Test\n\n\n\nWhat is the result?","type":"Single Choice","answer":"E","answers":{"A":"INHALE-EXHALE","B":"INHALE-EXHALE-","C":"INHALE-EXHALE-INHALE-","D":"INHALE-EXHALE-EXHALE","E":"INHALE-EXHALE-INHALE-EXHALE","F":"","G":"","H":"","I":"","J":""},"explanation":"As command-line argument is not passed, hence Line n1 throws ArrayIndexOutOfBoundsException (subclass of RuntimeException), handler is available in inner catch block, it executes Line n1 and prints INHALE- on to the console. \n\nthrow e; re-throws the exception. \n\n\n\nBut before exception instance is forwarded to outer catch-block, inner finally-block gets executed and prints EXHALE- on to the console. \n\nIn outer try-catch block, handler for RuntimeException is available, so outer catch-block gets executed and prints INHALE- on to the console.\n\nAfter that outer finally-block gets executed and prints EXHALE- on to the console.\n\n\n\nHence, the output is: INHALE-EXHALE-INHALE-EXHALE"},{"id":33,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void convert(String s)\n            throws IllegalArgumentException, RuntimeException, Exception {\n        if(s.length() == 0) {\n            throw new RuntimeException(\"LENGTH SHOULD BE GREATER THAN 0\");\n        }\n    }\n    public static void main(String [] args) {\n        try {\n            convert(\"\");\n        }\n        catch(IllegalArgumentException | RuntimeException | Exception e) { //Line 14\n            System.out.println(e.getMessage()); //Line 15\n        } //Line 16\n        catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\nLine 14 causes compilation error. Which of the following changes enables to code to print LENGTH SHOULD BE GREATER THAN 0?","type":"Single Choice","answer":"D","answers":{"A":"Replace Line 14 with 'catch(RuntimeException | Exception e) {'","B":"Replace Line 14 with 'catch(IllegalArgumentException | Exception e) {'","C":"Replace Line 14 with 'catch(IllegalArgumentException | RuntimeException e) {'","D":"Replace Line 14 with 'catch(RuntimeException e) {'","E":"Comment out Line 14, Line 15 and Line 16","F":"","G":"","H":"","I":"","J":""},"explanation":"Throwable is the root class of the exception hierarchy and it contains some useful constructors:\n\n\n\n1. public Throwable() {...} : No-argument constructor\n\n2. public Throwable(String message) {...} : Pass the detail message\n\n3. public Throwable(String message, Throwable cause) {...} : Pass the detail message and the cause\n\n4. public Throwable(Throwable cause) {...} : Pass the cause\n\n\n\nException and RuntimeException classes also provide similar constructors.\n\n\n\nThrowable class also contains methods, which are inherited by all the subclasses (Exception, RuntimeException etc.)\n\n1. public String getMessage() {...} : Returns the detail message (E.g. detail message set by 2nd and 3rd constructor)\n\n2. public String toString() {} :\n\nReturns a short description of this throwable. The result is the concatenation of:\n\nthe name of the class of this object\n\n\": \" (a colon and a space)\n\nthe result of invoking this object's getLocalizedMessage() method\n\n\n\nIf getLocalizedMessage() returns null, then just the class name is returned.\n\n\n\n\n\nIn multi-catch statement, classes with multi-level hierarchical relationship can't be used.\n\nRuntimeException is subclass of Exception, IllegalArgumentException is indirect subclass of Exception and IllegalArgumentException is subclass of RuntimeException, hence these pairs can't be used in multi-catch statement.\n\n\n\nOnly one option is left to replace Line 14 with 'catch(RuntimeException e) {'.\n\n\n\nCommenting out Line 14, Line 15 and Line 16 will resolve the compilation error but it will print the whole stack trace rather than just printing the message."},{"id":34,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    private static void div(int i, int j) {\n        try {\n            System.out.println(i / j);\n        } catch(ArithmeticException e) {\n            Exception ex = new Exception(e);\n            throw ex;\n        }\n    }\n    public static void main(String[] args) {\n        try {\n            div(5, 0);\n        } catch(Exception e) {\n            System.out.println(\"END\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error","B":"END is printed and program terminates successfully","C":"END is printed and program terminates abruptly","D":"END is not printed and program terminates abruptly","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"throw ex; causes compilation error as div method doesn't declare to throw Exception (checked) type."},{"id":35,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    private static void div(int i, int j) {\n        try {\n            System.out.println(i / j);\n        } catch(ArithmeticException e) {\n            throw (RuntimeException)e;\n        }\n    }\n    \n    public static void main(String[] args) {\n        try {\n            div(5, 0);\n        } catch(ArithmeticException e) {\n            System.out.println(\"AE\");\n        } catch(RuntimeException e) {\n            System.out.println(\"RE\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Compilation error","B":"Program ends abruptly","C":"AE is printed on to the console and program terminates successfully","D":"RE is printed on to the console and program terminates successfully","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Any RuntimeException can be thrown without any need it to be declared in throws clause of surrounding method.\n\n\n\n`throw (RuntimeException)e;` doesn't cause any compilation error.\n\n\n\nEven though variable 'e' is type casted to RuntimeException but exception object is still of ArithmeticException, which is caught in main method and 'AE' is printed to the console."},{"id":36,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void m() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            throw e;\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            m();\n        } catch(SQLException e) {\n            System.out.println(\"CAUGHT SUCCESSFULLY\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Method m() causes compilation error","B":"Method main(String []) causes compilation error","C":"CAUGHT SUCCESSFULLY is printed on to the console and program terminates successfully","D":"Program ends abruptly","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Even though it seems like method m() will not compile successfully, but starting with JDK 7, it is allowed to use super class reference variable in throw statement referring to sub class Exception object.\n\n\n\nIn this case, method m() throws SQLException and compiler knows that variable e (Exception type) refers to an instance of SQLException only and hence allows it.\n\n\n\nProgram executes successfully and prints CAUGHT SUCCESSFULLY on to the console."},{"id":37,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void getData() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            e = new SQLException();\n            throw e;\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            getData();\n        } catch(SQLException e) {\n            System.out.println(\"SQL\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Method getData() causes compilation error","B":"Method main(String []) causes compilation error","C":"SQL is printed on to the console and program terminates successfully","D":"Program ends abruptly","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"If you don't initialize variable e inside catch block using `e = new SQLException();` and simply throw e, then code would compile successfully as compiler is certain that 'e' would refer to an instance of SQLException only.\n\n\n\nBut the moment compiler finds `e = new SQLException();`, `throw e;` causes compilation error as at runtime 'e' may refer to any Exception type."},{"id":38,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void checkData() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            e = null; //Line 10\n            throw e; //Line 11\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            checkData(); //Line 17\n        } catch(SQLException e) {\n            System.out.println(\"NOT AVAILABLE\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"NOT AVAILABLE is printed on to the console and program terminates successfully","B":"Program ends abruptly","C":"Line 10 causes compilation failure","D":"Line 11 causes compilation failure","E":"Line 17 causes compilation failure","F":"","G":"","H":"","I":"","J":""},"explanation":"Exception is a java class, so `e = null;` is a valid statement and compiles successfully.\n\n\n\nIf you comment Line 10, and simply throw e, then code would compile successfully as compiler is certain that 'e' would refer to an instance of SQLException only.\n\n\n\nBut the moment compiler finds `e = null;`, `throw e;` (Line 11) causes compilation error as at runtime 'e' may refer to any Exception type.\n\n\n\nNOTE: No issues with Line 17 as method checkData() declares to throw SQLException and main(String []) method code correctly handles it."},{"id":39,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void getReport() throws SQLException {\n        try {\n            throw new SQLException();\n        } catch (Exception e) {\n            throw null; //Line 10\n        }\n    }\n \n    public static void main(String[] args) {\n        try {\n            getReport(); //Line 16\n        } catch(SQLException e) {\n            System.out.println(\"REPORT ERROR\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"REPORT ERROR is printed on to the console and program terminates successfully","B":"Program ends abruptly","C":"Line 10 causes compilation failure","D":"Line 16 causes compilation failure","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Classes in Exception framework are normal java classes, hence null can be used wherever instances of Exception classes are used, so Line 10 compiles successfully.\n\nNo issues with Line 16 as method getReport() declares to throw SQLException and main(String []) method code correctly handles it.\n\n\n\nProgram compiles successfully but on execution, NullPointerException is thrown, stack trace is printed on to the console and program ends abruptly.\n\n\n\nIf you debug the code, you would find that internal routine for throwing null exception causes NullPointerException."},{"id":40,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.SQLException;\n \npublic class Test {\n    private static void availableSeats() throws SQLException {\n        throw null; //Line 7\n    }\n \n    public static void main(String[] args) {\n        try {\n            availableSeats(); //Line 12\n        } catch(SQLException e) {\n            System.out.println(\"SEATS NOT AVAILABLE\");\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"SEATS NOT AVAILABLE is printed on to the console and program terminates successfully","B":"Program ends abruptly","C":"Line 7 causes compilation failure","D":"Line 12 causes compilation failure","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Classes in Exception framework are normal java classes, hence null can be used wherever instances of Exception classes are used, so Line 7 compiles successfully.\n\nNo issues with Line 12 as method availableSeats() declares to throw SQLException and main(String []) method code correctly handles it.\n\n\n\nProgram compiles successfully but on execution, NullPointerException is thrown, stack trace is printed on to the console and program ends abruptly.\n\n\n\nIf you debug the code, you would find that internal routine for throwing null exception causes NullPointerException."},{"id":41,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        try {\n            play();\n            return;\n        } catch(Exception ex) {\n            System.out.println(ex.getMessage());\n            return;\n        } finally {\n            System.out.println(\"MATCH ABANDONED\");\n        }\n        System.out.println(\"DONE\");\n    }\n \n    static void play() throws Exception {\n        throw new Exception(\"INJURED\");\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"G","answers":{"A":"INJURED\nMATCH ABANDONED","B":"INJURED\nMATCH ABANDONED\nDONE","C":"MATCH ABANDONED","D":"INJURED","E":"INJURED\nDONE","F":"MATCH ABANDONED\nDONE","G":"Compilation error","H":"","I":"","J":""},"explanation":"Both try and catch blocks have return; statement, which means either of the return statements will definitely get executed. Hence, compiler tags `System.out.println(\"DONE\");` as unreachable and this causes compilation error."},{"id":42,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nclass Base {\n    public void log() throws NullPointerException {\n        System.out.println(\"Base: log()\");\n    }\n}\n \nclass Derived extends Base {\n    public void log() throws RuntimeException {\n        System.out.println(\"Derived: log()\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base obj = new Derived();\n        obj.log();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"Base: log()","B":"Derived: log()","C":"Compilation error in Derived class","D":"Compilation error in Test class","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"NullPointerException extends RuntimeException. Overriding method may or may not throw any RuntimeException. Only thing to remember is that if overridden method throws any unchecked exception or Error, then overriding method must not throw any checked exceptions.\n\nSo, method log() in Derived class correctly overrides Base class's method.\n\nRest is simple polymorphism. 'obj' refers to an instance of Derived class and hence obj.log(); invokes method log() of Derived class, which prints \"Derived: log()\" on to the console."},{"id":43,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.io.FileNotFoundException;\n \npublic class Test {\n    static String [] names = {\"Williamson.pdf\", \"Finch.pdf\", \"Kohli.pdf\", \"Morgan.pdf\"};\n    public static void main(String[] args) {\n        try {\n            if (search(\"virat.pdf\"))\n                System.out.println(\"FOUND\");\n \n        } catch(FileNotFoundException ex) {\n            System.out.println(\"NOT FOUND\");\n        }\n    }\n \n    private static boolean search(String name) throws FileNotFoundException {\n        for(int i = 0; i <= 4; i++) {\n            if (names[i].equalsIgnoreCase(name)) {\n                return true;\n            }\n        }\n        throw new FileNotFoundException();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"FOUND","B":"NOT FOUND","C":"Compilation error","D":"None of the other options","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"search(String) method declares to throw FileNotFoundException, which is a checked exception. It returns true if match is found otherwise it throws an instance of FileNotFoundException.\n\n\n\nmain(String[]) provides try-catch block around `search(\"virat.pdf\")` and catch handler checks for FileNotFoundException. Given code compiles successfully.\n\n\n\nThere are 4 elements in 'names' array, so starting index is 0 and end index is 3, but given for loop goes till index number 4.\n\nAs search string is \"virat.pdf\" (not present in names array), hence for loop will execute for i = 0, 1, 2, 3, 4.\n\nFor i = 4, `names[i].equalsIgnoreCase(name)` throws ArrayIndexOutOfBoundsException (it is a RuntimeException). main(String []) method doesn't provide handler for ArrayIndexOutOfBoundsException and therefore stack trace is printed on to the console and program terminates abruptly."},{"id":44,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"java.sql.SQLException extends java.lang.Exception\n\nand\n\njava.sql.SQLWarning extends java.sql.SQLException\n\n\n\nGiven code of Test.java file:\n\npackage com.github.oca;\n \nimport java.sql.*;\n \ninterface Multiplier {\n    void multiply(int... x) throws SQLException;\n}\n \nclass Calculator implements Multiplier {\n    public void multiply(int... x) throws /*INSERT*/ {\n \n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            Multiplier obj = new Calculator(); //Line n1\n            obj.multiply(1, 2, 3);\n        } catch(SQLException e) {\n            System.out.println(e);\n        }\n    }\n}\n\n\nWhich of the options can be used to replace /*INSERT*/ such that there is no compilation error?\n\nSelect 5 options.","type":"Multiple Choice","answer":"B,C,E,F,H","answers":{"A":"java.io.IOException","B":"SQLException","C":"SQLWarning","D":"Throwable","E":"RuntimeException","F":"Error","G":"Exception","H":"NullPointerException","I":"","J":""},"explanation":"At Line n1, reference variable 'obj' is of Multiplier type (supertype) and it refers to an instance of Calculator class (subtype). This is polymorphism and allowed in Java.\n\nmultiply(int...) method declared in Multiplier interface declares to throw SQLException, hence the catch handler for Line n1 should provide handler for SQLException or its supertype. As catch-handler for SQLException is available, therefore Test class compiles successfully.\n\n\n\nAccording to overriding rules, if super class / interface method declares to throw a checked exception, then overriding method of sub class / implementer class has following options:\n\n1. May not declare to throw any checked exception\n\n2. May declare to throw the same checked exception thrown by super class / interface method: SQLException is a valid option.\n\n3. May declare to throw the sub class of the exception thrown by super class / interface method: SQLWarning is a valid option.\n\n4. Cannot declare to throw the super class of the exception thrown by super class / interface method: Exception, Throwable are not valid options.\n\n5. Cannot declare to throw unrelated checked exception: java.io.IOException is not a valid option as it is not related java.sql.SQLException in multi-level inheritance.\n\n6. May declare to throw any RuntimeException or Error: RuntimeException, NullPointerException and Error are valid options.\n\n\n\nTherefore 5 options can successfully replace /*INSERT*/: SQLException, SQLWarning, RuntimeException, Error and NullPointerException"},{"id":45,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \ninterface Blogger {\n    default void blog() throws Exception {\n        System.out.println(\"GENERIC\");\n    }\n}\n \nclass TravelBlogger implements Blogger {\n    public void blog() {\n        System.out.println(\"TRAVEL\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Blogger blogger = new TravelBlogger(); //Line n1\n        ((TravelBlogger)blogger).blog(); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error in TravelBlogger class","B":"Compilation error in Test class","C":"GENERIC is printed on to the console and program terminates successfully","D":"TRAVEL is printed on to the console and program terminates successfully","E":"An exception is thrown at runtime","F":"","G":"","H":"","I":"","J":""},"explanation":"According to overriding rules, if super class / interface method declares to throw a checked exception, then overriding method of sub class / implementer class has following options:\n\n1. May not declare to throw any checked exception.\n\n2. May declare to throw the same checked exception thrown by super class / interface method.\n\n3. May declare to throw the sub class of the exception thrown by super class / interface method.\n\n4. Cannot declare to throw the super class of the exception thrown by super class / interface method.\n\n5. Cannot declare to throw unrelated checked exception.\n\n6. May declare to throw any RuntimeException or Error.\n\n\n\ndefault methods were added in Java 8 and TravelBlogger class correctly overrides the default method blog() of Blogger interface. Blogger interface compiles successfully.\n\n\n\nAt Line n1, 'blogger' is of Blogger type (supertype) and it refers to an instance of TravelBlogger class (subtype), this is polymorphism and allowed in Java. Line n1 compiles successfully.\n\nAt Line n2, blog() method is being invoked on typecasting 'blogger' to TravelBlogger and as TravelBlogger class doesn't declare to throw any checked exception, hence Line n2 compiles successfully.\n\n\n\nAs instance is of TravelBlogger type, therefore on execution, Line n2 invokes blog() method of TravelBlogger instance, which prints TRAVEL on to the console."},{"id":46,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nabstract class Animal {\n    abstract void jump() throws RuntimeException;\n}\n \nclass Deer extends Animal {\n    void jump() { //Line n1\n        System.out.println(\"DEER JUMPS\");\n    }\n \n    void jump(int i) {\n        System.out.println(\"DEER JUMPS TO \" + i + \" FEET\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Animal animal = new Deer();\n        ((Deer)animal).jump(); //Line n2\n        ((Deer)animal).jump(5); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"Line n1 causes compilation error","B":"Line n2 causes compilation error","C":"Line n3 causes compilation error","D":"An exception is thrown at runtime","E":"Test class executes successfully and prints:\nDEER JUMPS\nDEER JUMPS TO 5 FEET","F":"","G":"","H":"","I":"","J":""},"explanation":"Method jump() in Animal class declares to throw RuntimeException.\n\nOverriding method may or may not throw any RuntimeException. Only thing to remember is that if overridden method throws any unchecked exception or Error, then overriding method must not throw any checked exceptions. Line n1 compiles successfully as it correctly overrides the jump() method of Animal class.\n\nClass Deer also provides overloaded jump(int) method.\n\n\n\nInside main(String []) method, reference variable 'animal' is of Animal class (supertype) and it refers to an instance of Deer class (subtype), this is polymorphism and allowed in Java.\n\n\n\nAs instance is of Deer class, hence 'animal' reference can easily be casted to Deer type. Line n2 and Line n3 compiles successfully and on execution prints below on to the console:\n\nDEER JUMPS\n\nDEER JUMPS TO 5 FEET"},{"id":47,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code fragment:\n\nimport java.util.*;\n \nclass A{}\nclass B extends A{}\n \nabstract class Super {\n    abstract List<A> get() throws IndexOutOfBoundsException;\n}\n \nabstract class Sub extends Super {\n    /*INSERT*/\n}\n\n\nWhich of the following options replaces /*INSERT*/ such that there is no compilation error?","type":"Single Choice","answer":"A","answers":{"A":"abstract List<A> get() throws ArrayIndexOutOfBoundsException;","B":"abstract List<B> get();","C":"abstract ArrayList<A> get() throws Exception;","D":"abstract ArrayList<B> get();","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Few things to keep in mind:\n\n1.\n\nThere are 2 rules related to return types of overriding method:\n\nA. If return type of overridden method is of primitive type, then overriding method should use same primitive type.\n\nB. If return type of overridden method is of reference type, then overriding method can use same reference type or its sub-type (also known as covariant return type).\n\n\n\n2.\n\nIn case of overriding, if overridden method declares to throw any RuntimeException or Error, overriding method may or may not throw any RuntimeException but overriding method must not throw any checked exceptions.\n\n\n\n3.\n\nIn generics syntax, Parameterized types are not polymorphic, this means even if B is subtype of A, List<B> is not subtype of List<A>. Remember this point. So below syntaxes are NOT allowed: \n\nList<A> list = new ArrayList<B>(); OR ArrayList<A> list = new ArrayList<B>();\n\n\n\n\n\nLet's check all the options one by one:\n\nabstract List<A> get() throws ArrayIndexOutOfBoundsException; => ✓ It returns the same return type 'List<A>' and it is allowed to throw any RuntimeException (ArrayIndexOutOfBoundsException is RuntimeException)\n\n\n\nabstract List<B> get(); => ✗ List<B> is not subtype of List<A>, it is not covariant return type.\n\n\n\nabstract ArrayList<A> get() throws Exception; => ✗ As overridden method declares to throw IndexOutOfBoundsException, which is a Runtime Exception, overriding method is not allowed to declare to throw any checked Exception. Class Exception and its subclasses are checked exceptions.\n\n\n\nabstract ArrayList<B> get(); => ✗ ArrayList<B> is not subtype of List<A>, it is not covariant return type."},{"id":48,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code snippets available in the same package:\n\n\n\nabstract class Traveller {\n    void travel(String place){}\n}\n\n\nabstract class BeachTraveller extends Traveller {\n    /*INSERT*/\n}\n\n\nWhich of the following declarations/definitions can replace /*INSERT*/ such that there is no compilation error?\n\nSelect 5 options.","type":"Multiple Choice","answer":"A,B,C,D,G","answers":{"A":"abstract void travel();","B":"abstract void travel(String beach);","C":"public abstract void travel();","D":"public void travel() throws RuntimeException {}","E":"public void travel(String beach) throws Exception {}","F":"void travel(String beach) throws java.io.IOException {}","G":"public void travel(Object obj) {}","H":"","I":"","J":""},"explanation":"Both Traveller and BeachTraveller are abstract classes and BeachTraveller extends Traveller. It is possible to have abstract class without any abstract method. Code as is compiles successfully as BeachTraveller inherits travel(String) method of Traveller class.\n\nBut as per the question, /*INSERT*/ must be replaced such that there is no compilation error.\n\n\n\nLet's check all the options one by one:\n\nabstract void travel(); ✓ This is method overloading. BeachTraveller has 2 methods: `void travel(String){}` and `abstract void travel()`.\n\nabstract void travel(String beach); ✓ As BeachTraveller is abstract, hence travel(String) method can be declared abstract.\n\npublic abstract void travel(); ✓ This is method overloading. BeachTraveller has 2 methods: `void travel(String){}` and `abstract void travel()`.\n\npublic void travel() throws RuntimeException {}: ✓ This is method overloading. BeachTraveller has 2 methods: `void travel(String){}` and `public void travel() throws RuntimeException {}`.\n\npublic void travel(String beach) throws Exception {}: ✗ As overridden method doesn't declare to throw any checked Exception hence overriding method is not allowed to declare to throw Exception.\n\nvoid travel(String beach) throws java.io.IOException {} ✗ As overridden method doesn't declare to throw any checked Exception hence overriding method is not allowed to declare to throw java.io.IOException.\n\npublic void travel(Object obj) {} ✓ This is method overloading. BeachTraveller has 2 methods: `void travel(String){}` and `public void travel(Object){}`."},{"id":49,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n \nclass Base {\n    Base() throws IOException {\n        System.out.print(1);\n    }\n}\n \nclass Derived extends Base {\n    Derived() throws FileNotFoundException {\n        System.out.print(2);\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) throws Exception {\n        new Derived();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Compilation error in both Base and Derived classes","B":"Compilation error only in Base class","C":"Compilation error only in Derived class","D":"Test class executes successfully and prints 12 on to the console","E":"Test class executes successfully and prints 21 on to the console","F":"","G":"","H":"","I":"","J":""},"explanation":"It is legal for the constructors to have throws clause.\n\nConstructors are not inherited by the Derived class so there is no method overriding rules related to the constructors but as one constructor invokes other constructors implicitly or explicitly by using this(...) or super(...), hence exception handling becomes interesting.\n\n\n\nJava compiler adds super(); as the first statement inside Derived class's constructor:\n\nDerived() throws FileNotFoundException {\n\n    super(); //added by the compiler\n\n    System.out.print(2);\n\n}\n\n\n\nAs super(); invokes the constructor of Base class (which declares to throw IOException), compiler complains as Derived class no-argument constructor doesn't declare to throw IOException. It declares to throw FileNotFoundException (subclass of IOException), which is not enough for the instances of IOException."},{"id":51,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Given code of Test.java file:\n\npackage com.github.oca;\n \nimport java.io.IOException;\n \nclass Super {\n    Super() throws RuntimeException {\n        System.out.print(\"CARPE \");\n    }\n}\n \nclass Sub extends Super {\n    Sub() throws IOException {\n        System.out.print(\"DIEM \");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) throws Exception {\n        new Sub();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error in both Super and Sub classes","B":"Compilation error only in Super class","C":"Compilation error only in Sub class","D":"Test class executes successfully and prints CARPE DIEM  on to the console","E":"Test class executes successfully and prints DIEM CARPE  on to the console","F":"","G":"","H":"","I":"","J":""},"explanation":"It is legal for the constructors to have throws clause.\n\nConstructors are not inherited by the Sub class so there is no method overriding rules related to the constructors but as one constructor invokes other constructors implicitly or explicitly by using this(...) or super(...), hence exception handling becomes interesting.\n\n\n\nJava compiler adds super(); as the first statement inside Sub class's constructor:\n\nSub() throws IOException {\n\n    super(); //added by the compiler\n\n    System.out.println(\"DIEM\");\n\n}\n\n\n\nsuper(); invokes the constructor of Super class (which declares to throw RuntimeException), as RuntimeException is unchecked exception, therefore no handling is necessary in the constructor of Sub class.\n\nSub class's constructor declares to throw IOException but main(String []) method handles it.\n\n\n\nThere is no compilation error and output is: CARPE DIEM"},{"id":52,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"Java Rocks!\";\n        System.out.println(str.length() + \" : \" + str.charAt(10));\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"11 : !","B":"An exception is thrown at runtime.","C":"11 : s","D":"Compilation error.","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"String class has length() method, which returns number of characters in the String. So length() method returns 11.\n\nString class has charAt(int index) method, which returns character at passed index. str.charAt(10) looks for character at index 10. index starts with 0. ! sign is at index 10.\n\nHence output is: 11 : !"},{"id":53,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String s1 = \"OcA\";\n        String s2 = \"oCa\";\n        System.out.println(s1.equals(s2));\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"true","B":"false","C":"Compilation error","D":"None of the other options","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"equals(String str) method of String class matches two String objects and it takes character's case into account while matching.\n\nAlphabet A in upper case and alphabet a in lower case are not equal according to this method. As String objects referred by s1 and s2 have different cases, hence output is false."},{"id":54,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String fName = \"James\";\n        String lName = \"Gosling\";\n        System.out.println(fName = lName);\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"Compilation error","B":"false","C":"true","D":"None of the other options","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Both fName and lName are of reference type. fName refers to \"James\" and lName refers to \"Gosling\".\n\nIn System.out.println() statement, we have used assignment operator (=) and not equality operator (==). So result is never boolean.\n\nfName = lName means copy the contents of lName to fName.\n\nAs lName is referring to \"Gosling\" and so after the assignment, fName starts referring to \"Gosling\" as well.\n\nSystem.out.println() finally prints the String referred by fName, which is \"Gosling\".\n\nThis option is not available, hence correct answer is \"None of the other options\""},{"id":55,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"Good\"; //Line 3\n        change(str); //Line 4\n        System.out.println(str); //Line 5\n    }\n    \n    private static void change(String s) {\n        s.concat(\"_Morning\"); //Line 9\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"Good","B":"_Morning","C":"Good_Morning","D":"None of the other options","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"When change(String) method is called, both variable s and str refers to same String object.\n\nLine 9 doesn't modify the passed object instead creates a new String object \"Good_Morning\".\n\nBut this newly created object is not referred and hence is a candidate for GC.\n\nWhen control goes back to calling method main(String[]), str still refers to \"Good\".\n\nLine 5 prints \"Good\" on to the console."},{"id":56,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Which of the method of String class is used to remove leading and trailing white spaces?","type":"Single Choice","answer":"C","answers":{"A":"ltrim()","B":"rtrim()","C":"trim()","D":"trimBoth()","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"ltrim(), rtrim() and trimBoth() are not defined in String class.\n\ntrim() method is used for removing leading and trailing white spaces."},{"id":57,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"Good\"); //Line 3\n        change(sb); //Line 4\n        System.out.println(sb); //Line 5\n    }\n    \n    private static void change(StringBuilder s) {\n        s.append(\"_Morning\"); //Line 9\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"Good","B":"_Morning","C":"Good_Morning","D":"None of the other options","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"When change method is called, both variable s and sb refers to same StringBuilder object.\n\nLine 9 modifies the passed object and appends \"_Morning\" to it. As a result s now refers to \"Good_Morning\" and sb also refers to \"Good_Morning\" so when control goes back to calling method main(String[]) Line 5 prints \"Good_Morning\" on to the console."},{"id":58,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str1 = new String(\"Core\");\n        String str2 = new String(\"CoRe\");\n        System.out.println(str1 = str2);\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"true","B":"false","C":"Core","D":"CoRe","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"System.out.println(str1 = str2) has assignment(=) operator and not equality(==) operator.\n\nAfter the assignment, str1 refers to \"CoRe\" and System.out.println prints \"CoRe\" to the console."},{"id":58,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str1 = new String(\"Core\");\n        String str2 = new String(\"CoRe\");\n        System.out.println(str1 = str2);\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"true","B":"false","C":"Core","D":"CoRe","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"System.out.println(str1 = str2) has assignment(=) operator and not equality(==) operator.\n\nAfter the assignment, str1 refers to \"CoRe\" and System.out.println prints \"CoRe\" to the console."},{"id":59,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test extends String {\n    @Override\n    public String toString() {\n        return \"TEST\";\n    }\n    \n    public static void main(String[] args) {\n        Test obj = new Test();\n        System.out.println(obj);\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"TEST","B":"Output string contains @ symbol","C":"Exception is thrown at runtime","D":"Compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"String is a final class so it cannot be extended."},{"id":60,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code:\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String s1 = \"OCAJP\";\n        String s2 = \"OCAJP\" + \"\";\n        System.out.println(s1 == s2);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"OCAJP","B":"true","C":"false","D":"Compilation error","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution. Compile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc.\n\n\n\nFor the statement, String s2 = \"OCAJP\" + \"\";, `\"OCAJP\" + \"\"` is a constant expression as both the operands \"OCAJP\" and \"\" are String literals, which means the expression `\"OCAJP\" + \"\"` is computed at compile-time and results in String literal \"OCAJP\".\n\nSo, during compilation, Java compiler translates the statement\n\nString s2 = \"OCAJP\" + \"\";\n\nto\n\nString s2 = \"OCAJP\";\n\n\n\nAs \"OCAJP\" is a String literal, hence at runtime it will be referred by String Pool.\n\n\n\nWhen Test class is executed,\n\ns1 refers to \"OCAJP\" (String Pool object).\n\ns2 also refers to same String pool object \"OCAJP\".\n\ns1 and s2 both refer to the same String object and that is why s1 == s2 returns true.\n\n\n\nPlease note that Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.\n\nFor below code snippet:\n\nString s1 = \"OCAJP\";\nString s2 = s1 + \"\";\nSystem.out.println(s1 == s2);\nOutput is false, as s1 is a variable and `s1 + \"\"` is not a constant expression, therefore this expression is computed only at runtime and a new non-pool String object is created."},{"id":61,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code:\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        final String fName = \"James\";\n        String lName = \"Gosling\";\n        String name1 = fName + lName;\n        String name2 = fName + \"Gosling\";\n        String name3 = \"James\" + \"Gosling\";\n        System.out.println(name1 == name2);\n        System.out.println(name2 == name3);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"true\ntrue","B":"true\nfalse","C":"false\nfalse","D":"false\ntrue","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution. Compile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc.\n\nWhereas, Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.\n\n\n\nfName is a constant variable and lName is a non-constant variable.\n\n\n\n`fName + lName` is not a constant expression and hence the expression will be computed at run-time and the resultant String object \"JamesGosling\" will not be referred by String Pool.\n\n\n\nAs fName is constant variable and \"Gosling\" is String literal, hence the expression `fName + \"Gosling\"` is a constant expression, therefore expression is computed at compile-time and results in String literal \"JamesGosling\".\n\nSo, during compilation, Java compiler translates the statement\n\nString name2 = fName + \"Gosling\";\n\nto\n\nString name2 = \"JamesGosling\";\n\nAs \"JamesGosling\" is a String literal, hence at runtime it will be referred by String Pool.\n\nSo, at runtime name1 and name2 refer to different String object and that is why name1 == name2 returns false.\n\n\n\n`\"James\" + \"Gosling\"` is also a constant expression and hence Java compiler translates the statement\n\nString name3 = \"James\" + \"Gosling\";\n\nto\n\nString name3 = \"JamesGosling\";\n\nThis means at runtime, variable 'name3' will refer to the same String pool object \"JamesGosling\", which is referred by variable 'name3'.\n\nSo, name2 and name3 refer to same String object and that is why name2 == name3 returns true."},{"id":62,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code:\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        final int i1 = 1;\n        final Integer i2 = 1;\n        final String s1 = \":ONE\";\n        \n        String str1 = i1 + s1;\n        String str2 = i2 + s1;\n        \n        System.out.println(str1 == \"1:ONE\");\n        System.out.println(str2 == \"1:ONE\");\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"true\ntrue","B":"true\nfalse","C":"false\nfalse","D":"false\ntrue","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution. Compile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc.\n\nWhereas, Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.\n\n\n\nFor the statement, String str1 = i1 + s1;, i1 is a final variable of int type and s1 is a final variable of String type. Hence, `i1 + s1` is a constant expression which is computed at compile-time and results in String literal \"1:ONE\".\n\nThis means during compilation, Java compiler translates the statement\n\nString str1 = i1 + s1;\n\nto\n\nString str1 = \"1:ONE\";\n\n\n\nAs \"1:ONE\" is a String literal, hence at runtime it will be referred by String Pool.\n\n\n\nOn the other hand, for the statement, String str2 = i2 + s1;, `i2 + s1` is not a constant expression because i2 is neither of primitive type nor of String type, hence it is computed at run-time and returns a non-pool String object \"1:ONE\".\n\n\n\nAs, str1 refers to String Pool object \"1:ONE\", hence `str1 == \"1:ONE\"` returns true, whereas str2 refers to non-Pool String object \"1:ONE\" and hence `str2 == \"1:ONE\"` returns false."},{"id":63,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code:\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String javaworld = \"JavaWorld\";\n        String java = \"Java\";\n        String world = \"World\";\n        java += world;\n        System.out.println(java == javaworld);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"JavaWorld","B":"Java","C":"World","D":"true","E":"false","F":"","G":"","H":"","I":"","J":""},"explanation":"Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution. Compile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc.\n\nWhereas, Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.\n\n\n\n`java += world;` is same as `java = java + world;` and `java + world` is not a constant expression and hence is calculated at runtime and returns a non pool String object \"JavaWorld\", which is referred by variable 'java'.\n\n\n\nOn the other hand, variable 'javaworld' refers to String Pool object \"JavaWorld\". As both the variables 'java' and 'javaworld' refer to different String objects, hence `java == javaworld` returns false."},{"id":64,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code:\n\n//Test.java\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(100);\n        System.out.println(sb.length() + \":\" + sb.toString().length());\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"100:100","B":"100:0","C":"16:16","D":"16:0","E":"0:0","F":"","G":"","H":"","I":"","J":""},"explanation":"`new StringBuilder(100);` creates a StringBuilder instance, whose internal char array's length is 100 but length() method of StringBuilder object returns the number of characters stored in the internal array and in this case it is 0. So, `sb.length()` returns 0.\n\nsb.toString() is the String representation of StringBuilder instance and in this case as there are no characters inside the StringBuilder object, hence sb.toString() returns an empty String \"\", so `sb.toString().length()` also returns 0.\n\nOutput is 0:0."},{"id":65,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"Hurrah! I Passed...\");\n        sb.delete(0, 100);\n        System.out.println(sb.length());\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"19","B":"0","C":"16","D":"StringIndexOutOfBoundsException is thrown at runtime","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"'delete' method accepts 2 parameters: delete(int start, int end), where start is inclusive and end is exclusive.\n\nThis method throws StringIndexOutOfBoundsException for following scenarios:\n\nA. start is negative\n\nB. start is greater than sb.length()\n\nC. start is greater than end\n\n\n\nIf end is greater than the length of StringBuilder object, then StringIndexOutOfBoundsException is not thrown and end is set to sb.length().\n\nSo, in this case, `sb.delete(0, 100);` is equivalent to `sb.delete(0, sb.length());` and this deletes all the characters from the StringBuilder object.\n\nHence, System.out.println(sb.length()); prints 0 on to the console."},{"id":66,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(5);\n        sb.append(\"0123456789\");\n        sb.delete(8, 1000);\n        System.out.println(sb);\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"Compilation error","B":"An exception is thrown at runtime","C":"01234567","D":"89","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"`new StringBuilder(5);` creates a StringBuilder instance, whose internal char array's length is 5 but the internal char array's length is adjusted when characters are added/removed from the StringBuilder instance. `sb.append(\"0123456789\");` successfully appends \"0123456789\" to the StringBuilder's instance referred by sb.\n\ndelete method accepts 2 parameters: delete(int start, int end), where start is inclusive and end is exclusive.\n\nThis method throws StringIndexOutOfBoundsException for following scenarios:\n\nA. start is negative\n\nB. start is greater than sb.length()\n\nC. start is greater than end\n\n\n\nIf end is greater than the length of StringBuilder object, then StringIndexOutOfBoundsException is not thrown and end is set to sb.length().\n\nSo, in this case, `sb.delete(8, 1000);` is equivalent to `sb.delete(8, sb.length());` and this deletes characters at 8th index (8) and 9th index (9). So remaining characters are: \"01234567\".\n\n\n\nStringBuilder class overrides toString() method, which prints the text stored in StringBuilder instance. Hence, `System.out.println(sb);` prints 01234567 on to the console."},{"id":67,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        System.out.println(sb.append(\"\").append(\"\").append(\"\").length());\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"0","B":"1","C":"2","D":"3","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"As \"\" is empty string, hence nothing is appended to the StringBuilder instance and length() method returns 0."},{"id":68,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        System.out.println(sb.append(null).length());\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"1","B":"4","C":"Compilation error","D":"NullPointerException is thrown at runtime","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"'append' method is overloaded in StringBuilder class: append(String), append(StringBuffer) and append(char[]) etc.\n\nIn this case compiler gets confused as to which method `append(null)` can be tagged because String, StringBuffer and char[] are not related to each other in multilevel inheritance. Hence `sb.append(null)` causes compilation error."},{"id":69,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        m1(null);\n    }\n    \n    static void m1(CharSequence s) {\n        System.out.println(\"CharSequence\");\n    }\n    \n    static void m1(String s) {\n        System.out.println(\"String\");\n    }\n    \n    static void m1(Object s) {\n        System.out.println(\"Object\");\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"Compilation Error","B":"CharSequence","C":"String","D":"Object","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Method m1 is overloaded to accept 3 different parameters: String, CharSequence and Object.\n\nString implements CharSequence and Object is the super Parent class in Java. There is no conflict among the overloaded methods for the call m1(null) as it is mapped to the class lowest in hierarchy, which is String class. Hence, output will be \"String\".\n\n\n\nNow if you add one more overloaded method, `static void m1(StringBuilder s) {...}` in the Test class, then `m1(null);` would cause compilation error as it would match to both m1(StringBuilder) and m1(String) methods. So m1(null) in that case would be ambiguous call and would cause compilation error.\n\n\n\nFor the same reason, System.out.println(null); causes compilation error as println method is overloaded to accept 3 reference types Object, String and char [] along with primitive types.\n\nSystem.out.println(null); matches to both println(char[]) and println(String), so it is an ambiguous call and hence the compilation error."},{"id":70,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Question 70: Skipped\nWhat will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"SpaceStation\");\n        sb.delete(5, 6).insert(5, \" S\").toString().toUpperCase();\n        System.out.println(sb);\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"SPACE SATION","B":"SPACE STATION","C":"Space Station","D":"Space Sation","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"sb - > \"SpaceStation\"\n\nsb.delete(5, 6) -> \"Spacetation\"\n\nsb.insert(5, \" S\") -> \"Space Station\"\n\nsb.toString() -> Creates a new String object \"Space Station\"\n\n\"Space Station\".toUpperCase() -> Creates another String object \"SPACE STATION\" but the String object is not referred and used.\n\n\n\nMethod invocation on sb modifies the same object, so after insert(5, \" S\") method invocation sb refers to \"Space Station\" and this is printed to the Console."},{"id":71,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"How many String objects are there in the HEAP memory, when control is at Line 9?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String s1 = new String(\"Java\"); //Line 3\n        String s2 = \"JaVa\"; //Line 4\n        String s3 = \"JaVa\"; //Line 5\n        String s4 = \"Java\"; //Line 6\n        String s5 = \"Java\"; //Line 7\n        \n        int i = 1; //Line 9\n        \n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"2","B":"3","C":"4","D":"5","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"String s1 = new String(\"Java\"); -> Creates 2 objects: 1 String Pool and 1 non-pool. s1 refers to non-pool object.\n\nString s2 = \"JaVa\"; -> Creates 1 String pool object and s2 refers to it.\n\nString s3 = \"JaVa\"; -> Doesn't create a new object, s3 refers to same String pool object referred by s2.\n\nString s4 = \"Java\"; -> Doesn't create a new object, s4 refers to String Pool object created at Line 3.\n\nString s5 = \"Java\"; -> Doesn't create a new object, s5 also refers to String Pool object created at Line 3.\n\n\n\nSo, at Line 9, 3 String objects are available in the HEAP memory: 2 String pool and 1 non-pool."},{"id":72,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"A bank's swift code is generally of 11 characters and used in international money transfers. \nAn example of swift code: ICICINBBRT4\nICIC: First 4 letters for bank code\nIN: Next 2 letters for Country code\nBB: Next 2 letters for Location code\nRT4: Next 3 letters for Branch code\n\nWhich of the following code correctly extracts country code from the swift code referred by String reference variable swiftCode?","type":"Single Choice","answer":"A","answers":{"A":"swiftCode.substring(4, 6);","B":"swiftCode.substring(5, 6);","C":"swiftCode.substring(5, 7);","D":"swiftCode.substring(4, 5);","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"substring(int beginIndex, int endIndex) is used to extract the substring. The substring begins at \"beginIndex\" and extends till \"endIndex - 1\". \n\nCountry code information is stored at index 4 and 5, so the correct substring method to extract country code is: swiftCode.substring(4, 6);"},{"id":73,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"X\");\n        list.add(\"Y\");\n        list.add(\"X\");\n        list.add(\"Y\");\n        list.add(\"Z\");\n        list.remove(new String(\"Y\"));\n        System.out.println(list);\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"[X, X, Y, Z]","B":"[X, X, Z]","C":"[X, Z]","D":"[X, Y, Z]","E":"Compilation error","F":"Exception is thrown at runtime","G":"","H":"","I":"","J":""},"explanation":"After all the add statements are executed, list contains: [X, Y, X, Y, Z].\n\nlist.remove(new String(\"Y\")); removes the first occurrence of \"Y\" from the list, which means the 2nd element of the list. After removal list contains: [X, X, Y, Z].\n\nNOTE: String class and all the wrapper classes override equals(Object) method, hence at the time of removal when another instance is passed [new String(\"Y\")], there is no issue in removing the  matching item."},{"id":74,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"java\";\n        StringBuilder sb = new StringBuilder(\"java\");\n        \n        System.out.println(str.equals(sb) + \":\" + sb.equals(str));\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"Compilation error","B":"false:false","C":"false:true","D":"true:false","E":"true:true","F":"","G":"","H":"","I":"","J":""},"explanation":"equals method declared in Object class has the declaration: public boolean equals(Object). Generally, equals method is used to compare different instances of same class but if you pass any other object, there is no compilation error. Parameter type is Object so it can accept any Java object.\n\n\n\nstr.equals(sb) => String class overrides equals(Object) method but as \"sb\" is of StringBuilder type so this returns false.\n\n\n\nStringBuilder class doesn't override equals(Object) method. So Object version is invoked which uses == operator, hence sb.equals(str) returns false as well.\n\nfalse:false is printed on to the console."},{"id":75,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"Java\");\n        String s1 = sb.toString();\n        String s2 = sb.toString();\n        \n        System.out.println(s1 == s2);\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"Compilation error","B":"true","C":"false","D":"An exception is thrown at runtime","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"toString() method defined in StringBuilder class doesn't use String literal rather uses the constructor of String class to create the instance of String class.\n\nSo both s1 and s2 refer to different String instances even though their contents are same. s1 == s2 returns false."},{"id":76,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"Java\");\n        String s1 = sb.toString();\n        String s2 = \"Java\";\n        \n        System.out.println(s1 == s2);\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"Compilation error","B":"true","C":"false","D":"An exception is thrown at runtime","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"toString() method defined in StringBuilder class doesn't use String literal rather uses the constructor of String class to create the instance of String class.\n\nSo both s1 and s2 refer to different String instances even though their contents are same. s1 == s2 returns false."},{"id":77,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"What will be the result of compiling and executing Test class?\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        String str1 = \" \";\n        boolean b1 = str1.isEmpty();\n        System.out.println(b1);\n        str1.trim();\n        b1 = str1.isEmpty();\n        System.out.println(b1);\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"false\ntrue","B":"false\nfalse","C":"true\nfalse","D":"true\ntrue","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"str1 refers to single space character and isEmpty() method of String returns true if no characters are there in the String. As str1 contains single space, hence b1 is false.\n\nfalse is first printed on to the console.\n\n\n\nstr1.trim(); => creates an empty string \"\" but str1 still refers to single space string \" \".\n\nb1 = str1.isEmpty(); assigns false to b1 and last System.out.println statement prints false on to the console.\n\nSo output is:\n\nfalse\n\nfalse"},{"id":78,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code:\n\n//Test.java\npackage com.github.oca;\n \nclass SpecialString {\n    String str;\n    SpecialString(String str) {\n        this.str = str;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Object [] arr = new Object[4];\n        for(int i = 1; i <=3; i++) {\n            switch(i) {\n                case 1: \n                    arr[i] = new String(\"Java\");\n                    break;\n                case 2: \n                    arr[i] = new StringBuilder(\"Java\");\n                    break;\n                case 3: \n                    arr[i] = new SpecialString(\"Java\");\n                    break;\n            }\n        }\n        for(Object obj : arr) {\n            System.out.println(obj);\n        }\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"Java\nJava\nJava","B":"Java\nJava\n<Some text containing @ symbol>","C":"Java\n<Some text containing @ symbol>\n<Some text containing @ symbol>","D":"null\nJava\nJava\nJava","E":"null\nJava\nJava\n<Some text containing @ symbol>","F":"null\nJava\n<Some text containing @ symbol>\n<Some text containing @ symbol>","G":"Java\nJava\nJava\nnull","H":"Java\nJava\n<Some text containing @ symbol>\nnull","I":"Java\n<Some text containing @ symbol>\n<Some text containing @ symbol>\nnull","J":""},"explanation":"Variable 'arr' refers to an Object array of size 4 and null is assigned to all 4 elements of this array.\n\nfor-loop starts with i = 1, which means at 1st index String instance is stored, at 2nd index StringBuiler instance is stored and at 3rd index SpecialString instance is stored. null is stored at 0th index.\n\nSo, first null will be printed on to the console.\n\nString and StringBuilder classes override toString() method, which prints the text stored in these classes. SpecialString class doesn't override toString() method and hence when instance of SpecialString is printed on to the console, you get: <fully qualified name of SpecialString class>@<hexadecimal representation of hashcode>.\n\nTherefore output will be:\n\nnull\n\nJava\n\nJava\n\n<Some text containing @ symbol>"},{"id":79,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String word = \"REBUS\";\n        /* INSERT */\n        System.out.println(word);\n    }\n}\n\n\nFollowing options are available to replace /*INSERT*/:\n\n1. word = word.substring(2);\n\n2. word = word.substring(2, 4);\n\n3. word = word.substring(2, 5);\n\n4. word = word.replace(\"RE\", \"\");\n\n5. word = word.substring(2, 6);\n\n6. word = word.delete(0, 2);\n\n\n\nHow many of the above options can be used to replace /*INSERT*/ (separately and not together) such that given command prints BUS on to the console?","type":"Single Choice","answer":"C","answers":{"A":"One option only","B":"Two options only","C":"Three options only","D":"Four options only","E":"Five options only","F":"All 6 options","G":"","H":"","I":"","J":""},"explanation":"substring(int beginIndex, int endIndex) method of String class extracts the substring, which begins at the specified beginIndex and extends to the character at index endIndex - 1.\n\nThis method throws IndexOutOfBoundsException if the beginIndex is negative, or endIndex is larger than the length of this String object, or beginIndex is larger than endIndex. e.g.\n\n\"freeway\".substring(4, 7) returns \"way\"\n\n\"freeway\".substring(4, 8) throws IndexOutOfBoundsException\n\n\n\nsubstring​(int beginIndex) method of String class extracts the substring, which begins with the character at the specified index and extends to the end of this string.\n\nThis method throws IndexOutOfBoundsException if beginIndex is negative or larger than the length of this String object. e.g.\n\n\"freeway\".substring(4) returns \"way\"\n\n\"freeway\".substring(8) throws IndexOutOfBoundsException\n\n\n\nreplace(CharSequence target, CharSequence replacement) method of String class returns a new String object after replacing each substring of this string that matches the literal target sequence with the specified literal replacement sequence. e.g.\n\n\"Java\".replace(\"a\", \"A\") --> returns new String object \"JAvA\".\n\n\n\nLet's check all the given options:\n\n\"REBUS\".substring(2); [begin = 2, end = 4 (end of the string)], returns \"BUS\" and hence it is a correct option.\n\n\"REBUS\".substring(2, 4); [begin = 2, end = 3 (endIndex - 1)], returns \"BU\" and hence it is incorrect option.\n\n\"REBUS\".substring(2, 5); [begin = 2, end = 4 (endIndex - 1)], returns \"BUS\" and hence it is a correct option.\n\n\"REBUS\".replace(\"RE\", \"\"); It replaces \"RE\" with empty string \"\" and returns \"BUS\", so it is also a correct option.\n\n\"REBUS\".substring(2, 6); Length of \"REBUS\" = 5 and endIndex = 6, which is greater than 5, hence it will thrown IndexOutOfBoundsException at runtime. Incorrect option\n\n\"REBUS\".delete(0, 2); Compilation error as delete(...) method is not available in String class, it is part of StringBuilder class. Incorrect option.\n\n\n\nSo, total 3 options will replace /*INSERT*/ to print BUS on to the console."},{"id":80,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"Game on\"; //Line n1\n        StringBuilder sb = new StringBuilder(str); //Line n2\n        \n        System.out.println(str.contentEquals(sb)); //Line n3\n        System.out.println(sb.contentEquals(str)); //Line n4\n        System.out.println(sb.equals(str)); //Line n5\n        System.out.println(str.equals(sb)); //Line n6\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"A","answers":{"A":"Only one statement causes compilation error","B":"Two statements cause compilation error","C":"Three statements cause compilation error","D":"Four statements cause compilation error","E":"No compilation error","F":"","G":"","H":"","I":"","J":""},"explanation":"There are no issues with Line n1 and Line n2, both the statements compile successfully.\n\n\n\nString class contains contentEquals(CharSequence) method. Please note that String, StringBuilder and StringBuffer classes implement CharSequence interface, hence contentEquals(CharSequence) method defined in String class cab be invoked with the argument of either String or StringBuilder or StringBuffer.\n\nAt Line n3, `str.contentEquals(sb)` is invoked with StringBuilder argument and hence it compiles fine. On execution it would compare the contents of String object and the passed StringBuilder object. As both the String object and StringBuilder object contains same content \"Game on\", hence on execution, Line n3 will print true.\n\n\n\ncontentEquals method is not available in StringBuilder class and hence Line n4 causes compilation error.\n\n\n\nequals method declared in Object class has the declaration: `public boolean equals(Object)`. Generally, equals method is used to compare different instances of same class but if you pass any other object, there is no compilation error. Parameter type is Object so it can accept any Java object.\n\n\n\n`str.equals(sb)` => It compiles fine, String class overrides equals(Object) method but as 'sb' is of StringBuilder type so `str.equals(sb)` would return false at runtime.\n\n\n\n`sb.equals(str)` => It also compiles fine, StringBuilder class doesn't override equals(Object) method. So Object version is invoked which uses == operator, hence `sb.equals(str)` would return false as well at runtime."},{"id":81,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"TOMATO\");\n        System.out.println(sb.reverse().replace(\"O\", \"A\")); //Line n1\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"G","answers":{"A":"TOMATO","B":"TAMATO","C":"TAMATA","D":"OTAMOT","E":"OTAMAT","F":"ATAMAT","G":"Compilation error","H":"","I":"","J":""},"explanation":"sb --> {\"TOMATO\"}\n\nsb.reverse() --> {\"OTAMOT\"}. reverse() method returns a StringBuilder object.\n\nreplace method of StringBuilder class accepts 3 arguments: `replace(int start, int end, String str)`. At Line n1, replace(\"O\", \"A\") method accepts 2 arguments and hence it causes compilation error."},{"id":82,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"B\"); //Line n1\n        sb.append(sb.append(\"A\")); //Line n2\n        System.out.println(sb); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"G","answers":{"A":"B","B":"BA","C":"AB","D":"BAB","E":"ABA","F":"ABAB","G":"BABA","H":"ABBA","I":"Compilation error at Line n2","J":""},"explanation":"At Line n1:\n\nsb --> {\"B\"}\n\n\n\nappend(...) method in StringBuilder class is overloaded to accept various arguments and 2 such arguments are String and CharSequence. It's return type is StringBuilder and as StringBuilder class implements CharSequence interface, hence 'sb.append(\"A\")' can easily be passed as and argument to sb.append(...) method. Line n2 compiles successfully.\n\nAt Line n2:\n\nsb.append(sb.append(\"A\")); //sb --> {\"B\"}\n\nsb.append({\"BA\"}); //sb --> {\"BA\"}\n\n{\"BABA\"}\n\n\n\nHence, Line n3 prints BABA"},{"id":83,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \nclass A {\n    public String toString() {\n        return null;\n    }\n}\n \npublic class Test {\n    public static void main(String [] args) {\n        String text = null;\n        text = text + new A(); //Line n1\n        System.out.println(text.length()); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"F","answers":{"A":"Line n1 causes compilation error","B":"Line n1 causes Runtime error","C":"Line n2 causes Runtime error","D":"0","E":"4","F":"8","G":"","H":"","I":"","J":""},"explanation":"You need to keep in mind an important point related to String Concatenation:\n\nIf only one operand expression is of type String, then string conversion is performed on the other operand to produce a string at run time.\n\nIf one of the operand is null, it is converted to the string \"null\".\n\nIf operand is not null, then the conversion is performed as if by an invocation of the toString method of the referenced object with no arguments; but if the result of invoking the toString method is null, then the string \"null\" is used instead.\n\n\n\nLet's check the expression of Line n1:\n\ntext = text + new A(); --> As text is of String type, hence + operator behaves as concatenation operator.\n\nAs text is null, so \"null\" is used in the Expression.\n\nnew A() represents the object of A class, so toString() method of A class is invoked, but as toString() method of A class returns null, hence \"null\" is used in the given expression.\n\nSo, given expression is written as:\n\ntext = \"null\" + \"null\";\n\ntext = \"nullnull\";\n\n\n\nHence, Line n2 prints 8 on to the console."},{"id":84,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        String text = \"RISE \";\n        text = text + (text = \"ABOVE \");\n        System.out.println(text);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"RISE RISE ABOVE","B":"RISE ABOVE","C":"ABOVE ABOVE","D":"RISE ABOVE RISE","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Initially text refers to \"RISE \".\n\nGiven statement:\n\ntext = text + (text = \"ABOVE \");\n\ntext = \"RISE \" + (text = \"ABOVE \"); //Left operand of + operator is evaluated first, text --> \"RISE \"\n\ntext = \"RISE \" + \"ABOVE \"; //Right operand of + operator is evaluated next, text --> \"ABOVE \"\n\ntext = \"RISE ABOVE \"; //text --> \"RISE ABOVE \"\n\n\n\nHence `System.out.println(text);` prints 'RISE ABOVE ' on to the console."},{"id":85,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String s1 = \"OCP\";\n        String s2 = \"ocp\";\n        System.out.println(/*INSERT*/);\n    }\n}\n\n\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print true on to the console?\n\nSelect 2 options.","type":"Multiple Choice","answer":"D,E","answers":{"A":"s1.equals(s2)","B":"s1.equals(s2.toUpper())","C":"s2.equals(s1.toLower())","D":"s1.length() == s2.length()","E":"s1.equalsIgnoreCase(s2)","F":"s1.contentEquals(s2)","G":"","H":"","I":"","J":""},"explanation":"Let's check all the statements one by one:\n\n\n\ns1.equals(s2): equals(String) method of String class matches two String objects and it takes character's case into account while matching. Alphabet A in upper case and alphabet a in lower case are not equal according to this method. As String objects referred by s1 and s2 have different cases, hence output is false.\n\n\n\ns1.equals(s2.toUpper()): Compilation error as there is no toUpper() method available in String class. Correct method name is: toUpperCase().\n\n\n\ns2.equals(s1.toLower()): Compilation error as there is no toLower() method available in String class. Correct method name is: toLowerCase().\n\n\n\ns1.length() == s2.length(): length() method returns the number of characters in the String object. s1.length() returns 3 and s2.length() also returns 3, hence output is true.\n\n\n\ns1.equalsIgnoreCase(s2): Compares s1 and s2, ignoring case consideration and hence returns true.\n\n\n\ns1.contentEquals(s2): String class contains two methods: contentEquals(StringBuffer) and contentEquals(CharSequence). Please note that String, StringBuilder and StringBuffer classes implement CharSequence interface, hence contentEquals(CharSequence) method defined in String class can be invoked with the argument of either String or StringBuilder or StringBuffer. In this case, it is invoked with String argument and hence it is comparing the contents of two String objects. This method also takes character's case into account while matching. As String objects referred by s1 and s2 have different cases, hence output is false."},{"id":86,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        String text = \"ONE \";\n        System.out.println(text.concat(text.concat(\"ELEVEN \")).trim());\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"ONE ELEVEN","B":"ONE ONE ELEVEN","C":"ONE ELEVEN ONE ELEVEN","D":"ONE ELEVEN ONE","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"Given statement:\n\nSystem.out.println(text.concat(text.concat(\"ELEVEN \")).trim()); //'text' refers to \"ONE \"\n\nSystem.out.println(text.concat(\"ONE ELEVEN \").trim()); //As String is immutable, hence there is no change in the String object referred by 'text', 'text' still refers to \"ONE \"\n\nSystem.out.println((\"ONE ONE ELEVEN \").trim()); //'text' still refers to \"ONE \"\n\nSystem.out.println(\"ONE ONE ELEVEN\"); //trim() method removes the trailing space in this case\n\nONE ONE ELEVEN is printed on to the console."},{"id":87,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        /*INSERT*/ x = 7, y = 200;\n        System.out.println(String.valueOf(x + y).length());\n    }\n}\n\n\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print 3 on to the console?\n\nSelect 3 options.","type":"Multiple Choice","answer":"B,C,D","answers":{"A":"byte","B":"short","C":"int","D":"long","E":"float","F":"double","G":"","H":"","I":"","J":""},"explanation":"Compound declarations are allowed in Java for primitive type and reference type.\n\n\n\nRange of byte data type is from -128 to 127, hence if byte is used to replace /*INSERT*/, then y = 200 would cause compilation error as 200 is out of range value for byte type. Hence, byte cannot be used to replace /*INSERT*/.\n\n\n\nshort, int, long, float & double can replace /*INSERT*/ without causing any error. x + y will evaluate to 207 for short, int and long types whereas, x  + y will evaluate to 207.0 for float and double types.\n\nString class has overloaded valueOf methods for int, char, long, float, double, boolean, char[] and Object types. valueOf method returns the corresponding String object and length() method returns number of characters in the String object.\n\nSo, `String.valueOf(x + y).length()` in case of short, int and long returns 3, on the other hand, in case of float and double it would return 5.\n\n\n\nHence, only 3 options (short, int and long) print expected output on to the console."},{"id":88,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"PANIC\";\n        StringBuilder sb = new StringBuilder(\"THET\");\n        System.out.println(str.replace(\"N\", sb)); //Line n1\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"PANIC","B":"PATHETIC","C":"Line n1 causes compilation error","D":"Line n1 throws error at runtime","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"String class has following two overloaded replace methods:\n\n1. public String replace(char oldChar, char newChar) {}:\n\nReturns a string resulting from replacing all occurrences of oldChar in this string with newChar. If no replacement is done, then source String object is returned. e.g.\n\n\"Java\".replace('a', 'A') --> returns new String object \"JAvA\".\n\n\"Java\".replace('a', 'a') --> returns the source String object \"Java\" (no change).\n\n\"Java\".replace('m', 'M') --> returns the source String object \"Java\" (no change).\n\n\n\n2. public String replace(CharSequence target, CharSequence replacement) {}:\n\nReturns a new String object after replacing each substring of this string that matches the literal target sequence with the specified literal replacement sequence. e.g.\n\n\"Java\".replace(\"a\", \"A\") --> returns new String object \"JAvA\".\n\n\"Java\".replace(\"a\", \"a\") --> returns new String object \"Java\" (it replaces \"a\" with \"a\").\n\n\"Java\".replace(\"m\", \"M\") --> returns the source String object \"Java\" (no change).\n\n\n\nAs String, StringBuilder and StringBuffer all implement CharSequence, hence instances of these classes can be passed to replace method. Line n1 compiles successfully and on execution replaces \"N\" with \"THET\", and hence Line n1 prints PATHETIC on to the console."},{"id":89,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        boolean flag1 = \"Java\" == \"Java\".replace('J', 'J'); //Line n1\n        boolean flag2 = \"Java\" == \"Java\".replace(\"J\", \"J\"); //Line n2\n        System.out.println(flag1 && flag2);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Line n1 causes compilation error","B":"Line n2 causes compilation error","C":"true","D":"false","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"String class has following two overloaded replace methods:\n\n1. public String replace(char oldChar, char newChar) {}:\n\nReturns a string resulting from replacing all occurrences of oldChar in this string with newChar. If no replacement is done, then source String object is returned. e.g.\n\n\"Java\".replace('a', 'A') --> returns new String object \"JAvA\".\n\n\"Java\".replace('a', 'a') --> returns the source String object \"Java\" (no change).\n\n\"Java\".replace('m', 'M') --> returns the source String object \"Java\" (no change).\n\n\n\n2. public String replace(CharSequence target, CharSequence replacement) {}:\n\nReturns a new String object after replacing each substring of this string that matches the literal target sequence with the specified literal replacement sequence. e.g.\n\n\"Java\".replace(\"a\", \"A\") --> returns new String object \"JAvA\".\n\n\"Java\".replace(\"a\", \"a\") --> returns new String object \"Java\" (it replaces \"a\" with \"a\").\n\n\"Java\".replace(\"m\", \"M\") --> returns the source String object \"Java\" (no change).\n\n\n\nFor Line n1, as both oldChar and newChar are same, hence source String (\"Java\") is returned by `\"Java\".replace('J', 'J');` without any change. flag1 stores true.\n\nFor Line n2, even though target and replacement are same but as \"J\" is found in the source String, hence a new String object \"Java\" is returned by `\"Java\".replace(\"J\", \"J\");` after replacing \"J\" with \"J\". flag2 stores false.\n\nflag1 && flag2 evaluates to false."},{"id":90,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code fragment:\n\nString place = \"MISSS\";\nSystem.out.println(place.replace(\"SS\", \"T\"));\n\n\nWhat is the output?","type":"Single Choice","answer":"B","answers":{"A":"MIST","B":"MITS","C":"MISSS","D":"MIT","E":"","F":"","G":"","H":"","I":"","J":""},"explanation":"According to Javadoc, replace(CharSequence target, CharSequence replacement) method of String class returns a new String object after replacing each substring of this string that matches the literal target sequence with the specified literal replacement sequence. The replacement proceeds from the beginning of the string to the end, for example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in \"ba\" rather than \"ab\".\n\n\n\n\"MISSS\".replace(\"SS\", \"T\"); returns \"MITS\"."},{"id":91,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String str = \"ALASKA\";\n        System.out.println(str.charAt(str.indexOf(\"A\") + 1));\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"A","B":"L","C":"S","D":"K","E":"Runtime error","F":"","G":"","H":"","I":"","J":""},"explanation":"`int indexOf(String str)` method of String class returns the index within this string of the first occurrence of the specified substring. e.g. \"Java\".indexOf(\"a\") returns 1.\n\n\n\n`char charAt​(int index)` method of String class returns the char value at the specified index. e.g. \"Java\".charAt(2) returns 'v'.\n\n\n\nLet's check the given expression:\n\nstr.charAt(str.indexOf(\"A\") + 1)\n\n= \"ALASKA\".charAt(\"ALASKA\".indexOf(\"A\") + 1)\n\n= \"ALASKA\".charAt(0 + 1) //\"ALASKA\".indexOf(\"A\") returns 0.\n\n= \"ALASKA\".charAt(1)\n\n= 'L'\n\n\n\nHence, L is printed on to the console."},{"id":92,"trainingUnit":"OCA","trainingContent":"Exception, String & StringBuilder","question":"Consider below code of Test.java file:\n\npackage com.github.oca; \n \npublic class Test {\n    public static void main(String[] args) {\n        String [] arr = {\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\"};\n        String place = \"faraway\";\n        System.out.println(arr[place.indexOf(\"a\", 3)]); //Line n1\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"1st","B":"3rd","C":"5th","D":"2nd","E":"4th","F":"An exception is raised by Line n1","G":"","H":"","I":"","J":""},"explanation":"`int indexOf​(String str, int fromIndex)` method of String class returns the index within this string of the first occurrence of the specified substring, starting at the specified index. e.g.\n\n\"alaska\".indexOf(\"a\", 1) returns 2\n\n\"alaska\".indexOf(\"a\", 2) returns 2\n\n\"alaska\".indexOf(\"a\", 3) returns 5\n\n\n\nIn the given question, 'arr' refers to a String array of size 5. Element at index 0 refers to \"1st\", element at index 1 refers to \"2nd\" and so on.\n\n\n\nLet's solve the given expression of Line n1:\n\narr[place.indexOf(\"a\", 3)]\n\n= arr[\"faraway\".indexOf(\"a\", 3)] //Starts looking for \"a\" from index 3 of the given String \"faraway\" and \"a\" is found at index 3.\n\n= arr[3]\n\n= \"4th\" //Array element at index 3 refers to \"4th\".\n\n\n\nHence, 4th is printed on to the console."}]