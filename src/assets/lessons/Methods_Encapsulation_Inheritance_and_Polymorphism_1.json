[{"id":1,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Which of the following can be used as a constructor for the class given below?\n\npackage com.udayan.oca;\n \npublic class Planet {\n}","type":"Single Choice","answer":"C","answers":{"A":"public void Planet(){} \n","B":"public void Planet(int x){} \n","C":"public Planet(String str) {} \n","D":"None of the other options\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Constructor has the same name as the class, doesn't have return type and can accept parameters."},{"id":2,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Greetings class?\n\npackage com.udayan.oca;\n \npublic class Greetings {\n    String msg = null;\n    \n    public Greetings() {\n        this(\"Good Morning!\");\n    }\n    \n    public Greetings(String str) {\n        msg = str;\n    }\n    \n    public void display() {\n        System.out.println(msg);\n    }\n    \n    public static void main(String [] args) {\n        Greetings g1 = new Greetings();\n        Greetings g2 = new Greetings(\"Good Evening!\");\n        g1.display();\n        g2.display();\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"null\nGood Evening!\n","B":"Good Morning!\nGood Evening!\n","C":"Good Morning!\nNull\n","D":"null\nnull\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Greetings g1 = new Greetings(); invokes no-argument constructor.\n\nNo-argument constructor calls parameterized constructor with the argument \"Good Morning!\"\n\nParameterized constructor assigns \"Good Morning!\" to msg variable of the object referred by g1.\n\nGreetings g2 = new Greetings(\"Good Evening!\"); invokes parameterized constructor, which assigns \"Good Evening!\" to msg variable of the object referred by g2.\n\ng1.display(); prints Good Morning!\n\ng2.display(); prints Good Evening!"},{"id":3,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Greetings class?\n\npackage com.udayan.oca;\n \npublic class Greetings {\n    String msg = null;\n    public Greetings() {\n    }\n    \n    public Greetings(String str) {\n        msg = str;\n    }\n    \n    public void display() {\n        System.out.println(msg);\n    }\n    \n    public static void main(String [] args) {\n        Greetings g1 = new Greetings();\n        Greetings g2 = new Greetings(\"Good Evening!\");\n        g1.display();\n        g1.display();\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"null\nGood Evening!\n","B":"null\nnull\n","C":"Good Evening!\nNull\n","D":"Compilation error\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Greetings g1 = new Greetings(); invokes no-argument constructor. Property msg (of object referred by g1) is assigned to null.\n\nGreetings g2 = new Greetings(\"Good Evening!\"); invokes parameterized constructor, which assigns \"Good Evening!\" to msg of object referred by g2.\n\ng1.display(); prints null\n\nAgain we have same call g1.display(); which prints null.\n\nNOTE: We haven't called display() on object referred by g2."},{"id":4,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    public String name;\n    public void Test() {\n        name = \"James\";\n    }\n    \n    public static void main(String [] args) {\n        Test obj = new Test();\n        System.out.println(obj.name);\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"James\n","B":"Compilation error\n","C":"null\n","D":"None of the above\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"public void Test() is method and not constructor, as return type is void.\n\nmethod can have same name as the class name, so no issues with Test() method declaration.\n\n\n\nAs there are no constructors available for this class, java compiler adds following constructor.\n\npublic Test() {}\n\n\n\nTest obj = new Test(); invokes the default constructor but it doesn't change the value of name property (by default null is assigned to name property)\n\n\n\nSystem.out.println(obj.name); prints null."},{"id":5,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    public static void change(int num) {\n        num++;\n        System.out.println(num);\n    }\n    \n    public static void main(String[] args) {\n        int i1 = 1;\n        Test.change(i1);\n        System.out.println(i1);\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"Compilation Error\n","B":"2\n1\n","C":"2\n2\n","D":"None of the other options\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"There are no compilation errors and main(String[]) method is invoked on executing Test class.\n\ni1 = 1.\n\n`Test.change(i1)` is executed next, contents of i1 (which is 1) is copied to the variable 'num' and method change(int) starts executing.\n\n`num++;` increments the value of num by 1, num = 2. There are no changes to the value of variable 'i1' of main(String[]) method, which still contains 1.\n\n`System.out.println(num);` prints 2 on to the console.\n\nchange(int) method finishes its execution and control goes back to the main(String[]) method.\n\n`System.out.println(i1);` prints 1 on to the console."},{"id":6,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nclass Message {\n    String msg = \"Happy New Year!\";\n    \n    public void print() {\n        System.out.println(msg);\n    }\n}\n \npublic class Test {\n    public static void change(Message m) { //Line n5\n        m.msg = \"Happy Holidays!\"; //Line n6\n    }\n    \n    public static void main(String[] args) {\n        Message obj = new Message(); //Line n1\n        obj.print(); //Line n2\n        change(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"null\nHappy Holidays!\n","B":"Happy Holidays!\nHappy Holidays!\n","C":"null\nnull\n","D":"Happy New Year!\nHappy Holidays!\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Message class doesn't specify any constructor, hence Java compiler adds below default constructor:\n\nMessage() {super();}\n\n\n\nLine n1 creates an instance of Message class and initializes instance variable 'msg' to \"Happy New Year!\". Variable 'obj' refers to this instance.\n\nLine n2 prints Happy New Year! on to the console.\n\nLine n3 invokes change(Message) method, as it is a static method defined in TestMessage class, hence `change(obj);` is the correct syntax to invoke it. Line n3 compiles successfully. On invocation parameter variable 'm' copies the content of variable 'obj' (which stores the address to Message instance created at Line n1). 'm' also refers to the same instance referred by 'obj'.\n\n\n\nLine n6, assigns \"Happy Holidays!\" to the 'msg' variable of the instance referred by 'm'. As 'obj' and 'm' refer to the same instance, hence obj.msg also refers to \"Happy Holidays!\". change(Message) method finishes its execution and control goes back to main(String[]) method.\n\n\n\nLine n4 is executed next, print() method is invoked on the 'obj' reference and as obj.msg refers to \"Happy Holidays!\", so this statement prints Happy Holidays! on to the console.\n\n\n\nHence in the output, you get:\n\nHappy New Year!\n\nHappy Holidays!"},{"id":7,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nclass Message {\n    String msg = \"Happy New Year!\";\n    \n    public void print() {\n        System.out.println(msg);\n    }\n}\n \npublic class Test {\n    public static void change(Message m) { //Line n5\n        m = new Message(); //Line n6\n        m.msg = \"Happy Holidays!\"; //Line n7\n    }\n    \n    public static void main(String[] args) {\n        Message obj = new Message(); //Line n1\n        obj.print(); //Line n2\n        change(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"Happy New Year!\nHappy Holidays!\n","B":"Happy Holidays!\nHappy Holidays!\n","C":"Happy New Year!\nHappy New Year!\n","D":"null\nHappy New Year!\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Message class doesn't specify any constructor, hence Java compiler adds below default constructor:\n\nMessage() {super();}\n\n\n\nLine n1 creates an instance of Message class and initializes instance variable 'msg' to \"Happy New Year!\". Variable 'obj' refers to this instance.\n\nLine n2 prints Happy New Year! on to the console.\n\nLine n3 invokes change(Message) method, as it is a static method defined in Test class, hence `change(obj);` is the correct syntax to invoke it. Line n3 compiles successfully. On invocation, parameter variable 'm' copies the content of variable 'obj' (which stores the address to Message instance created at Line n1). 'm' also refers to the same instance referred by 'obj'.\n\n\n\nOn execution of Line n6, another Message instance is created, its instance variable 'msg' refers to \"Happy New Year!\" and 'm' starts referring to this newly created instance of Message class. Variable 'obj' of main(String[]) method still refers to the Message instance created at Line n1. So, 'obj' and 'm' now refer to different Message instances.\n\n\n\nLine n7, assigns \"Happy Holidays!\" to the 'msg' variable of the instance referred by 'm'. change(Message) method finishes its execution and control goes back to main(String[]) method.\n\n\nLine n4 is executed next, print() method is invoked on the 'obj' reference and as obj.msg still refers to \"Happy New Year!\", so this statement prints Happy New Year! on to the console.\n\n\nHence in the output, you get:\n\nHappy New Year!\n\nHappy New Year!"},{"id":8,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    public static void print() {\n        System.out.println(\"static method\");\n    }\n    \n    public static void main(String[] args) {\n        Test obj = null;\n        obj.print();\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"NullPointerException is thrown\n","B":"Compilation error\n","C":"static method\n","D":"None of the other options\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"print() is static method of class Test. So correct syntax to call method print() is Test.print();\n\nbut static methods can also be invoked using reference variable: obj.print(); Warning is displayed in this case.\n\nEven though obj has null value, we don't get NullPointerException as objects are not needed to call static methods."},{"id":9,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"When does a class get the default constructor?","type":"Single Choice","answer":"C","answers":{"A":"If you define parameterized constructor for the class.\n","B":"You have to define at least one constructor to get the default constructor.\n","C":"If the class does not define any constructors explicitly.\n","D":"All classes in Java get a default constructor.\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Default constructor (which is no-argument constructor) is added by Java compiler, only if there are no constructors in the class."},{"id":10,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Wall class?\n\npackage com.udayan.oca;\n \npublic class Wall {\n    public static void main(String args[]) {\n        double area = 5.7;\n        String color;\n        if (area < 7)\n            color = \"green\";\n        \n        System.out.println(color);\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"green\n","B":"null\n","C":"NullPointerException\n","D":"Compilation error\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"color is LOCAL variable and it must be initialized before it can be used.\n\nAs area is not compile time constant, java compiler doesn't have an idea of the value of variable area.\n\nThere is no else block available as well.\n\n\n\nSo compiler cannot be sure of whether variable color will be initialized or not. So it causes compilation error at System.out.println(color);"},{"id":11,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"For the class Apple, which option, if used to replace /*INSERT*/, will print GREEN on to the console?\n\npackage com.udayan.oca;\n \npublic class Apple {\n    public String color;\n    \n    public Apple(String color) {\n        /*INSERT*/\n    }\n    \n    public static void main(String [] args) {\n        Apple apple = new Apple(\"GREEN\");\n        System.out.println(apple.color);\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"color = color; \n","B":"this.color = color; \n","C":"color = GREEN; \n","D":"this.color = GREEN; \n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Instance variable color is shadowed by the parameter variable color of parameterized constructor. So, color = color will have no effect, because short hand notation within constructor body will always refer to LOCAL variable. To refer to instance variable, this reference is needed. Hence 'this.color = color;' is correct.\n\n'color = GREEN;' and 'this.color = GREEN;' causes compilation error as GREEN is not within double quotes(\"\").\n\nNOTE: 'color = \"GREEN\";' will only assign 'GREEN' to local variable and not instance variable but 'this.color = \"GREEN\";' will assign 'GREEN' to instance variable."},{"id":12,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        double price = 90000;\n        String model;\n        if(price > 100000) {\n            model = \"Tesla Model X\";\n        } else if(price <= 100000) {\n            model = \"Tesla Model S\";\n        }\n        System.out.println(model);\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"Tesla Model X\n\n","B":"Tesla Model S\n","C":"null\n","D":"Compilation Error\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"In this case \"if - else if\" block is used and not \"if - else\" block.\n\n\n\n90000 is assigned to variable 'price' but you can assign parameter value or call some method returning double value, such as:\n\n\n\n'double price = currentTemp();'.\n\n\n\nIn these cases compiler will not know the exact value until runtime, hence Java Compiler is not sure which boolean expression will be evaluated to true and so variable model may not be initialized.\n\n\n\nUsage of LOCAL variable, 'model' without initialization gives compilation error. Hence, System.out.println(model); causes compilation error."},{"id":13,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Following statement in a Java program compiles successfully:\n\nstudent.report(course); \n\nWhat can you say for sure?","type":"Single Choice","answer":"C","answers":{"A":"student is the reference variable name\n\n\n","B":"student is the class name\n","C":"report is the method name\n","D":"course must be of String type\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"It is good practice to have first character of class name in upper case, but it is not mandatory.\n\nstudent can be either class name or reference variable name. \n\n\n\nSyntax to invoke static method is: Class_Name.method_name(<arguments>); OR reference_variable_name.method_name(<arguments>);\n\nSyntax to invoke instance method is: reference_variable_name.method_name(<arguments>);\n\nIf student represents class_name or refernce_variable_name, then report might be the static method of the class.\n\nIf student represents reference_variable_name, then report is the instance method of the class.\n\nIn both the cases, report must be the method name.\n\n\n\nType of argument cannot be found out by looking at above syntax."},{"id":14,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Choose the option that meets the following specification: \nCreate a well encapsulated class Clock with one instance variable model. \nThe value of model should be accessible and modifiable outside Clock.","type":"Single Choice","answer":"C","answers":{"A":" public class Clock {\n     public String model;\n }\n","B":" public class Clock {\n     public String model;\n     public String getModel() { return model; }\n     public void setModel(String val) { model = val; }\n }\n","C":" public class Clock {\n     private String model;\n     public String getModel() { return model; }\n     public void setModel(String val) { model = val; }\n }\n","D":" public class Clock {\n     public String model;\n     private String getModel() { return model; }\n     private void setModel(String val) { model = val; }\n }\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Encapsulation is all about having private instance variable and providing public getter and setter methods."},{"id":15,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider the following class:\n\npackage com.udayan.oca;\n \npublic class Employee {\n    public int passportNo; //line 2\n}\nWhich of the following is the correct way to make the variable 'passportNo' read only for any other class?","type":"Single Choice","answer":"B","answers":{"A":"Make 'passportNo' private.\n","B":"Make 'passportNo' private and provide a public method getPassportNo() which will return its value.\n","C":"Make 'passportNo' static and provide a public static method getPassportNo() which will return its value.\n","D":"Remove 'public' from the 'passportNo' declaration. i.e., change line 2 to int passportNo;\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'passportNo' should be read-only for any other class.\n\nThis means make 'passportNo' private and provide public getter method. Don't provide public setter as then 'passportNo' will be read-write property.\n\nIf passportNo is declared with default scope, then other classes in the same package will be able to access passportNo for read-write operation."},{"id":16,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing following program?\n\npackage com.udayan.oca;\n \nclass Rectangle {\n    private int height;\n    private int width;\n    \n    public Rectangle(int height, int width) {\n        this.height = height;\n        this.width = width;\n    }\n    \n    public int getHeight() {\n        return height;\n    }\n    \n    public int getWidth() {\n        return width;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        private int i = 100;\n        private int j = 200;\n        Rectangle rect = new Rectangle(i, j);\n        System.out.println(rect.getHeight() + \", \" + rect.getWidth());\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"100, 200\n","B":"200, 100\n","C":"Compilation Error\n","D":"0, 0\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"i and j cannot be declared private as i and j are local variables.\n\nOnly final modifier can be used with local variables."},{"id":17,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Which of the following statement declares a constant field in Java?","type":"Single Choice","answer":"C","answers":{"A":"const int x = 10; \n","B":"static int x = 10; \n","C":"final static int x = 10; \n","D":"int x = 10; \n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Fields declared with final are constant fields."},{"id":18,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    private static void m(int x) {\n        System.out.println(\"int version\");\n    }\n    \n    private static void m(char x) {\n        System.out.println(\"char version\");\n    }\n    \n    public static void main(String [] args) {\n        int i = '5';\n        m(i);\n        m('5');\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"int version\nint version\n","B":"char version\nchar version\n","C":"int version\nchar version\n","D":"char version\nint version\n","E":"Compilation error\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Method m is overloaded. Which overloaded method to invoke is decided at compile time.\n\nm(i) is tagged to m(int) as i is of int type and m('5') is tagged to m(char) as '5' is char literal."},{"id":19,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider code of Test.java file:\n\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int [] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        String str = process(arr, 3, 8); //Line 5\n        System.out.println(str);\n    }\n    \n    /*INSERT*/\n}\nLine 5 is giving compilation error as process method is not found. \nWhich of the following method definitions, if used to replace /*INSERT*/, will resolve the compilation error?","type":"Single Choice","answer":"B","answers":{"A":" private static int[] process(int [] arr, int start, int end) {\n     return null;\n }\n","B":" private static String process(int [] arr, int start, int end) {\n     return null;\n }\n","C":" private static int process(int [] arr, int start, int end) {\n     return null;\n }\n","D":" private static String[] process(int [] arr, int start, int end) {\n     return null;\n }\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"It is clear from Line 5 that, method name should be process, it should be static method, it should accept 3 parameters (int[], int, int) and its return type must be String."},{"id":20,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider code of Test.java file:\n\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String [] args) {\n        int [] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        System.out.println(process(arr, 3, 8)); //Line 5\n    }\n    \n    /*INSERT*/\n}\nLine 5 causes compilation error as process method is not found. \nWhich of the following method definitions, if used to replace /*INSERT*/, will resolve the compilation error?\n\nSelect 3 options.","type":"Multiple Choice","answer":"A, B, D","answers":{"A":" private static int[] process(int [] arr, int start, int end) {\n     return null;\n }\n","B":" private static String process(int [] arr, int start, int end) {\n     return null;\n }\n","C":" private static int process(int [] arr, int start, int end) {\n     return null;\n }\n","D":" private static String[] process(int [] arr, int start, int end) {\n     return null;\n }\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"It is clear from Line 5 that, method name should be process, it should be static method, it should accept 3 parameters (int[], int, int).\n\nAs process(arr, 3, 8) is passed as an argument of System.out.println method, hence process method's return type can be anything apart from void. println method is overloaded to accept all primitive types, char [], String type and Object type. int[] are String [] are of Object type.\n\nIn the given options, method specifying int as return type cannot return null as null can't be assigned to primitive type. int process(...) would give compilation error."},{"id":21,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"____________ uses access modifiers to protect variables and hide them within a class.\n\nWhich of the following options accurately fill in the blanks above?","type":"Single Choice","answer":"C","answers":{"A":"Polymorphism\n","B":"Inheritance\n","C":"Encapsulation\n","D":"Abstraction\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Encapsulation is all about having private instance variable and providing public getter and setter methods."},{"id":22,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\n//Test.java\npackage com.udayan.oca;\n \nclass Point {\n    static int x;\n    int y, z;\n    \n    public String toString() {\n        return \"Point(\" + x + \", \" + y + \", \" + z + \")\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Point p1 = new Point();\n        p1.x = 17;\n        p1.y = 35;\n        p1.z = -1;\n        \n        Point p2 = new Point();\n        p2.x = 19;\n        p2.y = 40;\n        p2.z = 0;\n        \n        System.out.println(p1); //Line n1\n        System.out.println(p2); //Line n2\n    }\n}","type":"Single Choice","answer":"B","answers":{"A":"Point(17, 35, -1)\nPoint(19, 40, 0)\n","B":"Point(19, 35, -1)\nPoint(19, 40, 0)\n","C":"Point(17, 35, -1)\nPoint(17, 40, 0)\n","D":"Point(19, 40, 0)\nPoint(19, 40, 0)\n","E":"Point(17, 35, -1)\nPoint(17, 35, -1)\n","F":"Point(19, 35, -1)\nPoint(19, 35, -1)\n","G":"Compilation error\n","H":"\n","I":"\n","J":"\n"},"explanation":"Point class correctly overrides the toString() method. Even though variable x is static, but it can be easily accessed by instance method toString().\n\nVariables x, y and z are declared with default scope, so can be accessed in same package. There is no compilation error in the code.\n\nThere is only one copy of static variable for all the instances of the class. Variable x is shared by p1 and p2 both.\n\np1.x = 17; sets the value of static variable x to 17, p2.x = 19; modifies the value of static variable x to 19. As there is just one copy of x, hence p1.x = 19\n\n\n\nPlease note: p1.x and p2.x don't cause any compilation error but as this syntax creates confusion, so it is not a good practice to access the static variables or static methods using reference variable, instead class name should be used. Point.x is the preferred syntax.\n\n\n\nEach object has its own copy of instance variables, so just before executing Line n1, p1.y = 35 & p1.z = -1 AND p2.y = 40 & p2.z = 0\n\nOutput is:\n\nPoint(19, 35, -1)\n\nPoint(19, 40, 0)"},{"id":23,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\n//Test.java\npackage com.udayan.oca;\n \nclass Point {\n    static int x;\n    private int y;\n    \n    public String toString() {\n        return \"Point(\" + x + \", \" + y + \")\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Point p1 = new Point();\n        p1.x = 100;\n        p1.y = 200;\n        \n        Point p2 = new Point();\n        p2.x = 100;\n        p2.y = 200;\n        \n        System.out.println(p1);\n    }\n}","type":"Single Choice","answer":"G","answers":{"A":"Point(100, 100)\n","B":"Point(100, 200)\n","C":"Point(200, 200)\n","D":"Point(0, 200)\n","E":"Point(100, 0)\n","F":"Point(200, 0)\n","G":"Compilation error\n","H":"\n","I":"\n","J":"\n"},"explanation":"Variable y is private so it cannot be accessed outside the boundary of Point class.\n\np1.y and p2.y used inside Test class, cause the compilation error."},{"id":24,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        short [] args = new short[]{50, 50};\n        args[0] = 5;\n        args[1] = 10;\n        System.out.println(\"[\" + args[0] + \", \" + args[1] + \"]\");\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"Compilation error\n","B":"An exception is thrown at runtime\n","C":"[50, 50]\n","D":"[5, 10]\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"main method's parameter variable name is \"args\" and it is a local to main method.\n\nSo, same name \"args\" can't be used directly within the curly brackets of main method. short [] args = new short[]{50, 50}; causes compilation error for using same name for local variable."},{"id":25,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    static String msg; //Line 2\n    public static void main(String[] args) {\n        String msg; //Line 4\n        if(args.length > 0) {\n            msg = args[0]; //Line 6\n        }\n        System.out.println(msg); //Line 8\n    }\n}","type":"Single Choice","answer":"E","answers":{"A":"null\n","B":"Line 2 causes compilation failure\n","C":"Line 4 causes compilation failure\n","D":"An exception is thrown at runtime by Line 6\n","E":"Line 8 causes compilation failure\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Line 4 code shadows the variable at Line 2. msg variable created at Line 4 is a local variable and should be initialized before it is used.\n\nInitialization code is inside if-block, so compiler is not sure about msg variable's initialization.\n\nHence, Line 8 causes compilation failure."},{"id":26,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code: \n\npackage com.udayan.oca;\n \npublic class Test {\n    \n    private static void add(int i, int j) {\n        System.out.println(\"int version\");\n    }\n    \n    private static void add(Integer i, Integer j) {\n        System.out.println(\"Integer version\");\n    }\n    \n    public static void main(String[] args) {\n        add(10, 20);\n    }\n    \n}\nWhich modifications, done independently, print \"Integer version\" on to the console? \n\nSelect 3 options.","type":"Multiple Choice","answer":"A, B, D","answers":{"A":"Remove add(int i, int j)  method declaration and definition.\n\n\n","B":"Replace add(10, 20);  by add(new Integer(10), new Integer(20)); \n","C":"Replace add(10, 20);  by add(10.0, 20.0); \n","D":"Replace add(10, 20);  by add(null, null); \n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Method add is overloaded in Test class. Which overloaded method is invoked is decided at the compile time. add(10, 20); tags to int version as 10, 20 are int literals and direct match is available. So without any changes, above code prints \"int version\" on to the console.\n\n\n\nTo print \"Integer version\" on to the console, add(Integer, Integer); method needs to be invoked. Let's check all the options one by one:\n\n\"Remove add(int i, int j) method declaration and definition.\" add(10, 20); => auto-boxing will convert literal 10 and 20 to Integer instances and will call the add(Integer, Integer) method. So this option is valid. \n\n\n\nReplace add(10, 20); by add(new Integer(10), new Integer(20)); => This statement is specifically calling add(Integer, Integer); So this option is also valid. \n\n\n\nReplace add(10, 20); by add(10.0, 20.0);  10.0 and 20.0 are default literals and can't be mapped to int or Integer types, hence this gives compilation error. Not a valid option.\n\n\n\nReplace add(10, 20); by add(null, null);  As Integer is reference type hence add(null, null); maps to add(Integer, Integer); So this is also valid option."},{"id":27,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    \n    private static void add(double d1, double d2) {\n        System.out.println(\"double version: \" + (d1 + d2));\n    }\n    \n    private static void add(Double d1, Double d2) {\n        System.out.println(\"Double version: \" + (d1 + d2));\n    }\n    \n    public static void main(String[] args) {\n        add(10.0, new Integer(10));\n    }\n    \n}","type":"Single Choice","answer":"B","answers":{"A":"Compilation error\n","B":"double version: 20.0\n","C":"Double version: 20.0\n","D":"An exception is thrown at runtime\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"int can be converted to double but Integer type can't be converted to Double type as Integer and Double are siblings (both extends from Number class) so can't be casted to each other.\n\n\n\nadd(10.0, new Integer(10)); => 1st parameter is tagged to double primitive type and 2nd parameter is converted to int, is tagged to double primitive type as well. So, add(double, double); method is invoked."},{"id":28,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    \n    private static void add(double d1, double d2) {\n        System.out.println(\"double version: \" + (d1 + d2));\n    }\n    \n    private static void add(Double d1, Double d2) {\n        System.out.println(\"Double version: \" + (d1 + d2));\n    }\n    \n    public static void main(String[] args) {\n        add(10.0, new Double(10.0));\n    }\n    \n}","type":"Single Choice","answer":"A","answers":{"A":"Compilation error\n","B":"double version: 20.0\n","C":"Double version: 20.0\n","D":"An exception is thrown at runtime\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"add(10.0, new Double(10.0)); is an ambiguous call as compiler can't decide whether to convert 1st argument to Double reference type or 2nd argument to double primitive type.\n\nSo, add(10.0, new Double(10.0)); causes compilation error."},{"id":29,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\n//Test.java\npackage com.udayan.oca;\n \nclass Student {\n    String name;\n    int marks;\n    \n    Student(String name, int marks) {\n        this.name = name;\n        this.marks = marks;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Student student = new Student(\"James\", 25);\n        int marks = 25;\n        review(student, marks);\n        System.out.println(marks + \"-\" + student.marks);\n    }\n    \n    private static void review(Student stud, int marks) {\n        marks = marks + 10;\n        stud.marks+=marks;\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"25-25\n","B":"35-25\n","C":"35-60\n","D":"25-60\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"In below statements: student<main> means student inside main method.\n\nOn execution of main method: student<main> --> {\"James\", 25}, marks<main> = 25.\n\nOn execution of review method: stud<review> --> {\"James\", 25} (same object referred by student<main>), marks<review> = 25 (this marks is different from the marks defined in main method). marks<review> = 35 and stud.marks = 60. So at the end of review method: stud<review> --> {\"James\", 60}, marks<review> = 35.\n\nControl goes back to main method: student<main> --> {\"James\", 60}, marks<main> = 25. Changes done to reference variable are visible in main method but changes done to primitive variable are not reflected in main method."},{"id":30,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        int x = 1;\n        while(checkAndIncrement(x)) {\n            System.out.println(x);\n        }\n    }\n    \n    private static boolean checkAndIncrement(int x) {\n        if(x < 5) {\n            x++;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"2\n3\n4\n5\n","B":"1\n2\n3\n4\n","C":"1\n2\n3\n4\n5\n","D":"Infinite loop\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"x of checkAndIncrement method contains the copy of variable x defined in main method. So, changes done to x in checkAndIncrement method are not reflected in the variable x of main. x of main remains 1 as code inside main is not changing its value.\n\nEvery time checkAndIncrement method is invoked with argument value 1, so true is returned always and hence while loop executes indefinitely."},{"id":31,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider the code of Test.java file:\n\npackage com.udayan.oca;\n \nclass Student {\n    String name;\n    int age;\n    \n    void Student() {\n        Student(\"James\", 25);\n    }\n    \n    void Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Student s = new Student();\n        System.out.println(s.name + \":\" + s.age);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"Compilation error\n","B":"null:0\n","C":"James:25\n","D":"An exception is thrown at runtime\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Methods can have same name as the class. Student() and Student(String, int) are methods and not constructors of the class, note the void return type of these methods.\n\nAs no constructors are provided in the Student class, java compiler adds default no-arg constructor. That is why the statement Student s = new Student(); doesn't give any compilation error.\n\nDefault values are assigned to instance variables, hence null is assigned to name and 0 is assigned to age. \n\nIn the output, null:0 is displayed."},{"id":32,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider the code of Test.java file:\n\npackage com.udayan.oca;\n \nclass Student {\n    String name;\n    int age;\n    \n    Student() {\n        Student(\"James\", 25);\n    }\n    \n    Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Student s = new Student();\n        System.out.println(s.name + \":\" + s.age);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error\n","B":"null:0\n","C":"James:25\n","D":"An exception is thrown at runtime\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"A constructor can call another constructor by using this(...) and not the constructor name.\n\nHence Student(\"James\", 25); gives compilation error."},{"id":33,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider the code of Test.java file:\n\npackage com.udayan.oca;\n \nclass Student {\n    String name;\n    int age;\n    \n    Student() {\n        Student(\"James\", 25);\n    }\n    \n    Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Student s = new Student();\n        System.out.println(s.name + \":\" + s.age);\n    }\n}\nThere is a compilation error in the Student class.\nWhich modifications, done independently, print \"James:25\" on to the console? \n\nSelect 2 options.","type":"Multiple Choice","answer":"A, C","answers":{"A":"Add below code in the Student class:\n void Student(String name, int age) {\n     this.name = name;\n     this.age = age;\n }\n","B":"Replace Student(\"James\", 25);  with super(\"James\", 25); \n","C":"Replace Student(\"James\", 25);  with this(\"James\", 25); \n","D":"Replace Student(\"James\", 25);  with this.Student(\"James\", 25); \n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"First find out the reason for compilation error, all the options are giving hint :)\n\n\n\nno-arg constructor of Student class calling another overloaded constructor by the name and this causes compilation error. This problem can be fixed in 2 ways:\n\n1st one: replace Student(\"James\", 25); with this(\"James\", 25) OR 2nd one: add void Student(String, int) method in the Student class.\n\n\n\nMethod can have same name as the class name and constructor can call other methods."},{"id":34,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    static String str = \"KEEP IT \"; //Line n1\n    public static void main(String[] args) {\n        String str = str + \"SIMPLE\"; //Line n2\n        System.out.println(str);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"KEEP IT\n","B":"KEEP IT SIMPLE\n","C":"SIMPLE\n","D":"Compilation error\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"At Line n2, local variable 'str' shadows the static variable 'str' created at Line n1. Hence, for the expression `str + \"SIMPLE\"`, Java compiler complains as local variable 'str' is not initialized."},{"id":35,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code of TestSquare.java file:\n\npackage com.udayankhattry.oca;\n \nclass Square {\n    int length;\n    Square sq;\n    \n    Square(int length) {\n        this.length = length;\n    }\n    \n    void setInner(Square sq) {\n        this.sq = sq;\n    }\n    \n    int getLength() {\n        return this.length;\n    }\n}\n \npublic class TestSquare {\n    public static void main(String[] args) {\n        Square sq1 = new Square(10); //Line n1\n        Square sq2 = new Square(5); //Line n2\n        sq1.setInner(sq2); //Line n3\n        System.out.println(sq1.sq.length); //Line n4\n    }\n}\n\n\nWhat will be the result of compiling and executing TestSquare class?","type":"Single Choice","answer":"B","answers":{"A":"It prints 0 on to the console\n","B":"It prints 5 on to the console\n","C":"It prints 10 on to the console\n","D":"It prints null on to the console\n","E":"Compilation error\n","F":"An exception is thrown at runtime\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"As both the classes: Square and TestSquare are in the same file, hence variables 'length' and 'sq' can be accessed using dot operator. Given code compiles successfully.\n\n\n\nLine n1 creates an instance of Square class and 'sq1' refers to it. sq1.length = 10 and sq1.sq = null.\n\nLine n2 creates an instance of Square class and 'sq2' refers to it. sq2.length = 5 and sq2.sq = null.\n\n\n\nOn execution of Line n3, sq1.sq = sq2.\n\n\n\nLine n4: System.out.println(sq1.sq.length); => System.out.println(sq2.length); => Prints 5 on to the console."},{"id":36,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code fragment:\n\nprivate void emp() {}\n\n\n\nAnd the statements:\n\n1. Given code compiles successfully if it is used inside the class named 'emp'\n\n2. Given code compiles successfully if it is used inside the class named 'Emp'\n\n3. Given code compiles successfully if it is used inside the class named 'employee'\n\n4. Given code compiles successfully if it is used inside the class named 'Employee'\n\n5. Given code compiles successfully if it is used inside the class named 'Student'\n\n6. Given code compiles successfully if it is used inside the class named '_emp_'\n\n\n\nHow many statements are true?","type":"Single Choice","answer":"F","answers":{"A":"Only one statement\n","B":"Two statements\n","C":"Three statements\n","D":"Four statements\n","E":"Five statements\n","F":"All six statements\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"`private void emp() {}` is a valid method declaration.\n\nClass name and method name can be same and that is why given method can be declared in any of the given classes: 'emp', 'Emp', 'employee', 'Employee', 'Student' and '_emp_'.\n\n'_emp_' is also a valid Java identifier."},{"id":37,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider the code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Report {\n    public String generateReport() {\n        return \"CSV\";\n    }\n    \n    public Object generateReport() {\n        return \"XLSX\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Report rep = new Report();\n        String csv = rep.generateReport();\n        Object xlsx = rep.generateReport();\n        System.out.println(csv + \":\" + (String)xlsx);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error\n","B":"An exception is thrown at runtime\n","C":"CSV:XLSX\n","D":"CSV:CSV\n","E":"XLSX:CSV\n","F":"XLSX:XLSX\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Both the methods of Report class have same signature(name and parameters match).\n\nHaving just different return types don't overload the methods and therefore Java compiler complains about duplicate generateReport() methods in Report class."},{"id":38,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Calculator {\n    int calculate(int i1, int i2) {\n        return i1 + i2;\n    }\n    \n    double calculate(byte b1, byte b2) {\n        return b1 % b2;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        byte b = 100;\n        int i = 20;\n        System.out.println(new Calculator().calculate(b, i));\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Compilation error\n","B":"An exception is thrown at runtime\n","C":"120\n","D":"120.0\n","E":"5\n","F":"5.0\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"calculate method is correctly overloaded as both the methods have different signature: calculate(int, int) and calculate(byte, byte). Please note that there is no rule regarding return type for overloaded methods, return type can be same or different.\n\n\n\n`new Calculator().calculate(b, i)` tags to `calculate(int, int)` as byte value is implicitly casted to int type.\n\n\n\nGiven code compiles successfully and on execution prints 120 on to the console."},{"id":39,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Car {\n    void speed(Byte val) { //Line n1\n        System.out.println(\"DARK\"); //Line n2\n    } //Line n3\n \n    void speed(byte... vals) {\n        System.out.println(\"LIGHT\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        byte b = 10; //Line n4\n        new Car().speed(b); //Line n5\n    }\n}\n\n\nWhich of the following needs to be done so that LIGHT is printed on to the console?","type":"Single Choice","answer":"B","answers":{"A":"No changes are required as given code prints LIGHT on execution\n","B":"Delete Line n1, Line n2 and Line n3\n","C":"Replace Line n4 with byte... b = 10;\n","D":"Replace Line n5 with new Car().speed((byte...)b);\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"speed method is correctly overloaded in Car class as both the methods have different signature: speed(Byte) and speed(byte...). Please note that there is no rule regarding return type for overloaded methods, return type can be same or different.\n\n\n\n`new Car().speed(b);` tags to speed(Byte) as boxing is preferred over variable arguments. Code as is prints DARK on to the console.\n\n\n\nVariable arguments syntax '...' can be used only for method parameters and not for variable type and type-casting. Hence the option of replacing Line n4 and Line n5 are not correct.\n\n\n\nIf you delete speed(Byte) method, i.e. Line n1, Line n2 and Line n3, then `new Car().speed(b);` would tag to speed(byte...) method and on execution would print LIGHT on to the console."},{"id":40,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code of TestMessage.java file:\n\npackage com.udayankhattry.oca;\n \nclass Message {\n    String msg = \"LET IT GO!\";\n    \n    public void print() {\n        System.out.println(msg);\n    }\n}\n \npublic class TestMessage {\n    public static void change(Message m) { //Line n5\n        m.msg = \"NEVER LOOK BACK!\"; //Line n6\n    }\n    \n    public static void main(String[] args) {\n        Message obj = new Message(); //Line n1\n        obj.print(); //Line n2\n        change(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}\n\n\nWhat will be the result of compiling and executing TestMessage class?","type":"Single Choice","answer":"D","answers":{"A":"null\nNEVER LOOK BACK!\n","B":"NEVER LOOK BACK!\nNEVER LOOK BACK!\n","C":"null\nnull\n","D":"LET IT GO!\nNEVER LOOK BACK!\n","E":"LET IT GO!\nLET IT GO!\n","F":"Compilation error\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Message class doesn't specify any constructor, hence Java compiler adds below default constructor:\n\nMessage() {super();}\n\n\n\nLine n1 creates an instance of Message class and initializes instance variable 'msg' to \"LET IT GO!\". Variable 'obj' refers to this instance.\n\nLine n2 prints LET IT GO! on to the console.\n\nLine n3 invokes change(Message) method, as it is a static method defined in TestMessage class, hence `change(obj);` is the correct syntax to invoke it. Line n3 compiles successfully. On invocation parameter variable 'm' copies the content of variable 'obj' (which stores the address to Message instance created at Line n1). 'm' also refers to the same instance referred by 'obj'.\n\n\n\nLine n6, assigns \"NEVER LOOK BACK!\" to the 'msg' variable of the instance referred by 'm'. As 'obj' and 'm' refer to the same instance, hence obj.msg also refers to \"NEVER LOOK BACK!\". change(Message) method finishes its execution and control goes back to main(String[]) method.\n\n\n\nLine n4 is executed next, print() method is invoked on the 'obj' reference and as obj.msg refers to \"NEVER LOOK BACK!\", so this statement prints NEVER LOOK BACK! on to the console.\n\n\n\nHence in the output, you get:\n\nLET IT GO!\n\nNEVER LOOK BACK!"},{"id":41,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code of AvoidThreats.java file:\n\npublic class AvoidThreats {\n    public static void evaluate(Threat t) { //Line n5\n        t = new Threat(); //Line n6\n        t.name = \"PHISHING\"; //Line n7\n    }\n    \n    public static void main(String[] args) {\n        Threat obj = new Threat(); //Line n1\n        obj.print(); //Line n2\n        evaluate(obj); //Line n3\n        obj.print(); //Line n4\n    }\n}\n \nclass Threat {\n    String name = \"VIRUS\";\n    \n    public void print() {\n        System.out.println(name);\n    }\n}\n\n\nWhat will be the result of compiling and executing AvoidThreats class?","type":"Single Choice","answer":"C","answers":{"A":"VIRUS\nPHISHING\n","B":"PHISHING\nPHISHING\n","C":"VIRUS\nVIRUS\n","D":"null\nVIRUS\n","E":"null\nnull\n","F":"None of the other options\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Threat class doesn't specify any constructor, hence Java compiler adds below default constructor:\n\nThreat() {super();}\n\n\n\nLine n1 creates an instance of Threat class and initializes instance variable 'name' to \"VIRUS\". Variable 'obj' refers to this instance.\n\nLine n2 prints VIRUS on to the console.\n\nLine n3 invokes evaluate(Threat) method, as it is a static method defined in AvoidThreats class, hence `evaluate(obj);` is the correct syntax to invoke it. Line n3 compiles successfully. On invocation parameter variable 't' copies the content of variable 'obj' (which stores the address to Threat instance created at Line n1). 't' also refers to the same instance referred by 'obj'.\n\n\n\nOn execution of Line n6, another Threat instance is created, its instance variable 'name' refers to \"VIRUS\" and 't' starts referring to this newly created instance of Threat class. Variable 'obj' of main(String[]) method still refers to the Threat instance created at Line n1. So, 'obj' and 't' now refer to different Threat instances.\n\n\n\nLine n7, assigns \"PHISHING\" to the 'name' variable of the instance referred by 't'. evaluate(Threat) method finishes its execution and control goes back to main(String[]) method.\n\n\n\nLine n4 is executed next, print() method is invoked on the 'obj' reference and as obj.msg still refers to \"VIRUS\", so this statement prints VIRUS on to the console.\n\n\n\nHence in the output, you get:\n\nVIRUS\n\nVIRUS"},{"id":42,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    int i1 = 10;\n    static int i2 = 20;\n    \n    private void change1(int val) {\n        i1 = ++val; //Line n1\n        i2 = val++; //Line n2\n    }\n    \n    private static void change2(int val) {\n        i1 = --val; //Line n3\n        i2 = val--; //Line n4\n    }\n    \n    public static void main(String[] args) {\n        change1(5); //Line n5\n        change2(5); //Line n6\n        System.out.println(i1 + i2); //Line n7\n    }\n}\n\n\nWhich of the following statements are correct regarding above code?\n\nSelect 3 options.","type":"Multiple Choice","answer":"C, E, G","answers":{"A":"Line n1 causes compilation error\n","B":"Line n2 causes compilation error\n","C":"Line n3 causes compilation error\n","D":"Line n4 causes compilation error\n","E":"Line n5 causes compilation error\n","F":"Line n6 causes compilation error\n","G":"Line n7 causes compilation error\n","H":"Above code compiles successfully\n","I":"Above code prints 8 on execution\n","J":"Above code prints 30 on execution\n"},"explanation":"i1 is an instance variable and i2 is a static variable.\n\nInstance method can access both instance and static members. Hence, Line n1 and Line n2 compile successfully.\n\nStatic method can access only static members. Hence, Line n3 [accessing instance variable i1], Line n5 [accessing instance method change1(int)] and Line n7 [accessing instance variable i1] cause compilation error."},{"id":43,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    static int i1 = 10;\n    int i2 = 20;\n    \n    int add() {\n        return this.i1 + this.i2; //Line n1\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(new Test().add()); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"It executes successfully and prints 30 on to the console\n","B":"It executes successfully and prints 20 on to the console\n","C":"It executes successfully and prints 10 on to the console\n","D":"Line n1 causes compilation error\n","E":"Line n2 causes compilation error\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"i1 is a static variable and i2 is an instance variable. Preferred way to access static variable i1 inside add() method is by using 'i1' or 'Test.i1'. Even though 'this.i1' is not the recommended way but it works.\n\nAnd instance variable i2 can be accessed inside add() method by using 'i2' or 'this.i2'. Hence, Line n1 compiles successfully.\n\n\n\nAs add() is an instance method of Test class, so an instance of Test class is needed to invoke the add() method. `new Test().add()` correctly invokes the add() method of Test class and returns 30. Line n2 prints 30 on to the console."},{"id":44,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Counter {\n    static int ctr = 0;\n    int count = 0;\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Counter ctr1 = new Counter();\n        Counter ctr2 = new Counter();\n        Counter ctr3 = new Counter();\n        \n        for(int i = 1; i <= 5; i++ ) {\n            ctr1.ctr++;\n            ctr1.count++;\n            ctr2.ctr++;\n            ctr2.count++;\n            ctr3.ctr++;\n            ctr3.count++;\n        }\n        \n        System.out.println(ctr3.ctr + \":\" + ctr3.count);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error\n","B":"5:5 is printed on to the console\n","C":"15:15 is printed on to the console\n","D":"15:5 is printed on to the console\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Each instance of the class contains separate copies of instance variable and share one copy of static variable.\n\nThere are 3 instances of Counter class created by main method and these are referred by ctr1, ctr2 and ctr3.\n\nAs 'ctr' is a static variable of Counter class, hence ctr1.ctr, ctr2.ctr and ctr3.ctr refer to the same variable. In fact, 'Counter.ctr' is the preferred way to refer the static variable 'ctr' but ctr1.ctr, ctr2.ctr and ctr3.ctr are also allowed.\n\n\n\nAs 'count' is an instance variable, so there are 3 separate copies: ctr1.count, ctr2.count, ctr3.count.\n\n\n\nOn the completion of for loop: ctr1.count = 5, ctr2.count = 5 and ctr3.count = 5 and Counter.ctr = 15.\n\n\n\n15:5 is printed on to the console."},{"id":45,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider the code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    private static void m(int i) {\n        System.out.print(1);\n    }\n    \n    private static void m(int i1, int i2) {\n        System.out.print(2);\n    }\n    \n    private static void m(char... args) {\n        System.out.print(3);\n    }\n    \n    public static void main(String... args) {\n        m('A');\n        m('A', 'B');\n        m('A', 'B', 'C');\n        m('A', 'B', 'C', 'D');\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Above code causes compilation error\n","B":"It compiles successfully and on execution prints 3333 on to the console\n","C":"It compiles successfully and on execution prints 1233 on to the console\n","D":"It compiles successfully and on execution prints 1333 on to the console\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"If choice is between implicit casting and variable arguments, then implicit casting takes precedence because variable arguments syntax was added in Java 5 version.\n\nm('A'); is tagged to m(int) as 'A' is char literal and implicitly casted to int.\n\nm('A', 'B'); is tagged to m(int, int) as 'A' and 'B' are char literals and implicitly casted to int.\n\nm('A', 'B', 'C'); is tagged to m(char...)\n\nm('A', 'B', 'C', 'D'); is tagged to m(char...)\n\n\n\nThere is no compilation error and on execution output is: 1233"},{"id":46,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code of TestBook.java file:\n\npackage com.udayankhattry.oca;\n \nclass Book {\n    private String name;\n    private String author;\n    \n    Book() {}\n    \n    Book(String name, String author) {\n        name = name;\n        author = author;\n    }\n    \n    String getName() {\n        return name;\n    }\n    \n    String getAuthor() {\n        return author;\n    }\n}\n \npublic class TestBook {\n    public static void main(String[] args) {\n        private Book book = new Book(\"Head First Java\", \"Kathy Sierra\");\n        System.out.println(book.getName());\n        System.out.println(book.getAuthor());\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"B","answers":{"A":"Compilation error in Book class\n","B":"Compilation error in TestBook class\n","C":"null\nnull\n","D":"Head First Java\nKathy Sierra\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Variable 'book' in main(String[]) method of TestBook class cannot be declared private as it is a local variable. Hence, there is a compilation error in TestBook class. \n\nOnly final modifier can be used with local variables."},{"id":47,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"_________ modifier is most restrictive and __________ modifier is least restrictive.\n\n\n\nWhich of the following options (in below specified order) can be filled in above blank spaces?","type":"Single Choice","answer":"B","answers":{"A":"public, private\n","B":"private, public\n","C":"default (with no access modifier specified), public\n","D":"protected, public\n","E":"default (with no access modifier specified), protected\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'private' is most restrictive, then comes 'default (with no access modifier specified)', after that 'protected' and finally 'public' is least restrictive."},{"id":48,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code snippet:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    String testNo;\n    String desc;\n    /*\n    Other codes...\n    */\n}\n\n\nWhich of the options are correct so that instance variables 'testNo' and 'desc' are accessible only within 'com.udayankhattry.oca' package?","type":"Single Choice","answer":"A","answers":{"A":"No changes are necessary\n\n\n\n","B":"Change the instance variable declarations to:\nprivate String testNo;\nprivate String desc;\n","C":"Change the instance variable declarations to:\nprotected String testNo;\nprotected String desc;\n","D":"Change the instance variable declarations to:\npublic String testNo;\npublic String desc;\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'As member variables 'testNo' and 'desc' are declared with no explicit access specifier, this means these variables have package scope, hence these variables are accessible only to classes within the same package. Hence, no changes are necessary.\n\nIf you use private, then instance variables will not be accessible to any other classes, even within the same package.\n\nIf you use protected, then instance variables will be accessible to the subclasses outside 'com.udayankhattry.oca' package.\n\nIf you use public, then instance variables will be accessible to all the classes."},{"id":49,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code of Circle.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Circle {\n    private double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\n\nUser must be allowed to read and change the value of radius field. What needs to be done so that all the classes can read/change the value of radius field and Circle class is well encapsulated as well?","type":"Single Choice","answer":"E","answers":{"A":"Nothing needs to be done\n","B":"Change radius declaration from `private double radius;` to `double radius;`\n","C":"Change radius declaration from `private double radius;` to `protected double radius;`\n","D":"Change radius declaration from `private double radius;` to `public double radius;`\n","E":"Add below 2 methods in Circle class:\npublic double getRadius() {\n    return radius;\n}\npublic void setRadius(double radius) {\n    this.radius = radius;\n}\n","F":"Add below 2 methods in Circle class:\nprotected double getRadius() {\n    return radius;\n}\nprotected void setRadius(double radius) {\n    this.radius = radius;\n}\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'Circle class needs to be well encapsulated, this means that instance variable radius must be declared with private access modifier and getter/setter methods must be public, so that value in radius variable can be read/changed by other classes.\n\nOut of the given options, below option is correct:\n\nAdd below 2 methods in Circle class:\n\npublic double getRadius() {\n\n    return radius;\n\n}\n\n\n\npublic void setRadius(double radius) {\n\n    this.radius = radius;\n\n}"},{"id":50,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"super keyword in java is used to:","type":"Single Choice","answer":"D","answers":{"A":"refer to static variable of the class.\n","B":"refer to static method of the class.\n","C":"refer to current class object.\n","D":"refer to parent class object.\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'super refers to parent class object and this refers to currently executing object."},{"id":51,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nclass A {\n    A() {\n        this(1);\n        System.out.println(\"M\");\n    }\n    \n    A(int i) {\n        System.out.println(\"N\");\n    }\n}\n \nclass B extends A {\n    \n}\n \npublic class Test {\n    public static void main(String[] args) {\n        new B();\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"M\n","B":"N\n","C":"N\nM\n","D":"M\nN\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'Default constructor added by Java compiler in B class is:\n\nB() {\n    super();\n}\nOn executing new B(); statement, class B's default constructor is invoked, which invokes no-arg constructor of class A [super();].\n\nno-arg constructor of class A invokes parameterized constructor of class A [this(1);].\n\nN is printed first and after that M is printed."},{"id":52,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nclass Super {\n    public Super(int i) {\n        System.out.println(100);\n    }\n}\n \nclass Sub extends Super {\n    public Sub() {\n        System.out.println(200);\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        new Sub();\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"200\n","B":"200\n100\n","C":"100\n200\n","D":"Compilation Error\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'super(); is added by the compiler as the first statement in both the constructors.\n\nClass Super extends from Object class and Object class has no-argument constructor, hence no issues with the constructor of Super class.\n\nBut no-arg constructor is not available in Super class, hence calling super(); from Sub class constructor causes compilation error."},{"id":53,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Which of these keywords can be used to prevent inheritance of a class?","type":"Single Choice","answer":"C","answers":{"A":"constant\n","B":"super\n","C":"final\n","D":"class\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'Class declared as final can't be inherited.\n\nExamples are: String, Integer, System etc."},{"id":54,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Circus class?\n\n//Circus.java\npackage com.udayan.oca;\n \nclass Animal {\n    protected void jump() {\n        System.out.println(\"Animal\");\n    }\n}\n \nclass Cat extends Animal {\n    public void jump(int a) {\n        System.out.println(\"Cat\");\n    }\n}\n \nclass Deer extends Animal {\n    public void jump() {\n        System.out.println(\"Deer\");\n    }\n}\n \npublic class Circus {\n    public static void main(String[] args) {\n        Animal cat = new Cat();\n        Animal deer = new Deer();\n        cat.jump();\n        deer.jump();\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"Animal\nDeer\n","B":"Cat\nDeer\n","C":"Animal\nAnimal\n","D":"Cat\nAnimal\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'Cat class doesn't override the jump() method of Animal class, in fact jump(int) method is overloaded in Cat class.\n\nDeer class overrides jump() method of Animal class.\n\n\n\nReference variable cat is of Animal type, cat.jump() syntax is fine and as Cat doesn't override jump() method hence Animal version is invoked, which prints Animal to the console.\n\n\n\nEven though reference variable deer is of Animal type but at runtime deer.jump(); invokes overriding method of Deer class, this prints Deer to the console."},{"id":55,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing TestBaseDerived class?\n\n//TestBaseDerived.java\npackage com.udayan.oca;\n \nclass Base {\n    protected void m1() {\n        System.out.println(\"Base: m1()\");\n    }\n}\n \nclass Derived extends Base {\n    void m1() {\n        System.out.println(\"Derived: m1()\");\n    }\n}\n \npublic class TestBaseDerived {\n    public static void main(String[] args) {\n        Base b = new Derived();\n        b.m1();\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"Base: m1()\n","B":"Derived: m1()\n","C":"Base: m1()\nDerived: m1()\n","D":"None of the other options\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'Derived class overrides method m1() of Base class.\n\nAccess modifier of method m1() in Base class is protected, so overriding method can use protected or public.\n\nBut overriding method in this case used default modifier and hence there is compilation error."},{"id":56,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Which is not a valid statement based on given code?\n\nclass A{}\nclass B extends A{}","type":"Single Choice","answer":"A","answers":{"A":"B b = new A();  \n","B":"A a = new B(); \n","C":"B a = new B(); \n","D":"A a = new A();\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'B b = new A(); -> child class reference cannot refer to parent class object. This will give compilation error.\n\nA a = new B(); -> parent class reference can refer to child class object. This is Polymorphism.\n\nB a = new B(); -> No issues at all.\n\nA a = new A(); -> No issues at all."},{"id":57,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nclass M { }\nclass N extends M { }\nclass O extends N { }\nclass P extends O { }\n \npublic class Test {\n    public static void main(String args []) {\n        M obj = new O();\n        if(obj instanceof M) \n            System.out.print(\"M\");\n        if(obj instanceof N) \n            System.out.print(\"N\");\n        if(obj instanceof O) \n            System.out.print(\"O\");\n        if(obj instanceof P) \n            System.out.print(\"P\");\n    }\n}","type":"Single Choice","answer":"A","answers":{"A":"MNO\n","B":"MNP\n","C":"NOP\n","D":"MOP\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'M\n\n^\n\nN\n\n^\n\nO [obj refers to instance of O class]\n\n^\n\nP\n\n\n\nobj instanceof M -> true\n\nobj instanceof N -> true\n\nobj instanceof O -> true\n\nbut\n\nobj instanceof P -> false"},{"id":58,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Which one of these top level classes cannot be sub-classed?","type":"Single Choice","answer":"C","answers":{"A":"class Dog {} \n","B":"abstract class Cat {} \n","C":"final class Electronics {} \n","D":"private class Car {} \n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'class Dog {}: can be sub-classed within the same package.\n\nabstract class Cat {}: can be sub-classed within the same package.\n\nfinal class Electronics {}: a class with final modifier cannot be sub-classed.\n\nprivate class Car {}: a top level class cannot be declared with private modifier."},{"id":59,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\npackage com.udayan.oca;\n \nclass Vehicle {\n    public int getRegistrationNumber() {\n        return 1;\n    }\n}\n \nclass Car {\n    public int getRegistrationNumber() {\n        return 2;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Vehicle obj = new Car();\n        System.out.println(obj.getRegistrationNumber());\n    }\n}","type":"Single Choice","answer":"D","answers":{"A":"1\n","B":"2\n","C":"An exception is thrown at runtime\n\n","D":"Compilation error\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'class Car doesn't extend from Vehicle class, this means Vehicle is not super type of Car.\n\nHence, Vehicle obj = new Car(); causes compilation error."},{"id":60,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"For the given code:\n\npackage com.udayan.oca;\n \ninterface I01 {\n    void m1();\n}\n \npublic class Implementer extends Object implements I01 {\n    protected void m1() {\n        \n    }\n}\nWhich of the statement is true?","type":"Single Choice","answer":"C","answers":{"A":"interface I01 gives compilation error as method m1 is not public.\n","B":"Implementer class declaration is not correct.\n","C":"Method m1() in Implementer class is not implemented correctly.\n","D":"None of the other options.\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'void m1(); in interface I01 is equivalent to public abstract void m1(); So method m1() is implicitly public and abstract.\n\nIn java,  a class can extend from only one class but can implement multiple interfaces. Correct keywords are: extends and implements.\n\nso class declaration is correct. \n\nAs method m1() is implicitly public in I01, hence overriding method in Implementer class should also be public. But it is protected and hence compiler complains."},{"id":61,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Which of these access modifiers can be used for a top level interface?","type":"Single Choice","answer":"C","answers":{"A":"private\n","B":"protected\n","C":"public\n","D":"All of the other options\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'A top level interface can be declared with either public or default modifiers.\n\npublic interface is accessible across all packages but interface declared with default modifier and be accessed in the defining package only."},{"id":62,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Given the following definitions of the class Insect and the interface Flyable, the task is to declare a class Mosquito that inherits from the class Insect and implements the interface Flyable.\n\nclass Insect {}\ninterface Flyable {}\n\nSelect the correct option to accomplish this task:","type":"Single Choice","answer":"C","answers":{"A":"class Mosquito implements Insect extends Flyable{} \n","B":"class Mosquito implements Insect, Flyable{} \n","C":"class Mosquito extends Insect implements Flyable{} \n","D":"class Mosquito extends Insect, Flyable{} \n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'A class in Java extends class and implements interface."},{"id":63,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class?\n\n//Test.java\npackage com.udayan.oca;\n \nabstract class Animal {\n    private String name;\n    \n    Animal(String name) {\n        this.name = name;\n    }\n    \n    public String getName() {\n        return name;\n    }\n}\n \nclass Dog extends Animal {\n    private String breed;\n \n    Dog(String breed) {\n        this.breed = breed;\n    }\n    \n    Dog(String name, String breed) {\n        super(name);\n        this.breed = breed;\n    }\n    \n    public String getBreed() {\n        return breed;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Dog dog1 = new Dog(\"Beagle\");\n        Dog dog2 = new Dog(\"Bubbly\", \"Poodle\");\n        System.out.println(dog1.getName() + \":\" + dog1.getBreed() + \":\" + \n                                dog2.getName() + \":\" + dog2.getBreed());\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"Compilation error for Animal Class\n","B":"Compilation error for Animal(String) constructor\n","C":"Compilation error for Dog(String) constructor\n","D":"Compilation error for Dog(String, String) constructor\n","E":"null:Beagle:Bubbly:Poodle\n","F":":Beagle:Bubbly:Poodle\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'abstract class can have constructors and it also possible to have abstract class without any abstract method. So, there is no issue with Animal class.\n\n\n\nJava compiler adds super(); as the first statement inside constructor, if call to another constructor using this(...) or super(...) is not available. \n\n\n\nInside Animal class Constructor, compiler adds super(); => Animal(String name) { super(); this.name = name; }, super() in this case invokes the no-arg constructor of Object class and hence no compilation error here. \n\n\n\nCompiler changes Dog(String) constructor to: Dog(String breed) { super(); this.breed = breed; }. No-arg constructor is not available in Animal class and as another constructor is provided, java compiler doesn't add default constructor. Hence Dog(String) constructor gives compilation error.\n\n\n\nThere is no issue with Dog(String, String) constructor."},{"id":64,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"What will be the result of compiling and executing Test class? \n\n//Test.java\npackage com.udayan.oca;\n \nclass Parent {\n    int i = 10;\n    Parent(int i) {\n        super();\n        this.i = i;\n    }\n}\n \nclass Child extends Parent {\n    int j = 20;\n    \n    Child(int j) {\n        super(0);\n        this.j = j;\n    }\n    \n    Child(int i, int j) {\n        super(i);\n        this(j);\n    }\n    \n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Child child = new Child(1000, 2000);\n        System.out.println(child.i + \":\" + child.j);\n    }\n}","type":"Single Choice","answer":"C","answers":{"A":"Compilation error for Parent(int) constructor\n","B":"Compilation error for Child(int) constructor\n","C":"Compilation error for Child(int, int) Constructor\n","D":"Compilation error for Test class\n","E":"1000:2000\n","F":"1000:00:00\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'super(); inside Parent(int) constructor invokes the no-arg constructor of Object class and hence no compilation error for Parent(int) constructor. \n\n\n\nsuper(0); inside Child(int) constructor invokes Parent(int) constructor, which is available and hence no issues. \n\n\n\nChild(int, int) constructor has both super(i) and this(j) statements. A constructor should have super(...) or this(...) but not both. Hence Child(int, int) causes compilation failure.\n\n\n\nAs all the classes are defined in Test.java file under com.udayan.oca.test package, hence child.i and child.j don't give compilation error. i and j are declared with package scope."},{"id":65,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Given code of LogHelper.java file:\n\npackage com.udayan.oca;\n \nabstract class Helper {\n    int num = 100;\n    String operation = null;\n    \n    protected abstract void help();\n    \n    void log() {\n        System.out.println(\"Helper-log\");\n    }\n}\n \npublic class LogHelper extends Helper {\n    private int num = 200;\n    protected String operation = \"LOGGING\";\n    \n    void help() {\n        System.out.println(\"LogHelper-help\");\n    }\n    \n    void log() {\n        System.out.println(\"LogHelper-log\");\n    }\n    \n    public static void main(String [] args) {\n        new LogHelper().help();\n    }\n}\n\n\nWhich of the following changes, done independently, allows the code to compile and on execution prints LogHelper-help?\n\nSelect 3 options.","type":"Multiple Choice","answer":"C, E, F","answers":{"A":"Remove the private modifier from the num variable of LogHelper class\n","B":"Remove the protected modifier from the operation variable of LogHelper class\n","C":"Remove the protected modifier from the help() method of Helper class\n","D":"Add the protected modifier to the log() method of Helper class\n","E":"Add the protected modifier to the help() method of LogHelper class\n","F":"Add the public modifier to the help() method of LogHelper class\n","G":"Add the public modifier to the log() method of LogHelper class\n","H":"Add the protected modifier to the log() method of LogHelper class\n","I":"\n","J":"\n"},"explanation":"'Let us first find out the issue:\n\nAs instance variables are hidden by subclasses and not overridden, hence overriding rules are not for the instance variables. There are no issues with variables 'num' and 'operation'.\n\nlog() method is declared with default modifier in both the classes, hence no issue with log() method as well.\n\nabstract method help() is declared with protected modifier in Helper class and in LogHelper class, it is overridden with default modifier and this causes compilation error. So below solutions to resolved this issue:\n\n1. Remove the protected modifier from the help() method of Helper class: Both the overridden and overriding methods will have same default modifier, which is allowed\n\nOR\n\n2. Add the protected modifier to the help() method of LogHelper class: Both the overridden and overriding methods will have same protected modifier, which is allowed\n\nOR\n\n3. Add the public modifier to the help() method of LogHelper class: Overridden method will have protected modifier and overriding method will have public modifier, which is allowed"},{"id":66,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code fragment:\n\npackage com.udayan.oca;\n \ninterface Printable {\n    public void setMargin();\n    public void setOrientation();\n}\n \nabstract class Paper implements Printable { //Line 7\n    public void setMargin() {}\n    //Line 9\n}\n \nclass NewsPaper extends Paper { //Line 12\n    public void setMargin() {}\n    //Line 14\n}\n\n\nAbove code is currently giving compilation error.\n\nWhich 2 modifications, done independently, enable the code to compile?","type":"Multiple Choice","answer":"C, D","answers":{"A":"Replace the code at Line 7 with: class Paper implements Printable { \n","B":"Insert at Line 9: public abstract void setOrientation(); \n","C":"Replace the code at Line 12 with: abstract class NewsPaper extends Paper { \n","D":"Insert at Line 14: public void setOrientation() {} \n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'First you should find out the reason for compilation error. Methods declared in Printable interface are implicitly abstract, no issues with Printable interface.\n\n\n\nclass Paper is declared abstract and it implements Printable interface, it overrides setMargin() method but setOrientation() method is still abstract. No issues with class Paper as it is an abstract class and can have 0 or more abstract methods. \n\n\n\nclass NewsPaper is concrete class and it extends Paper class (which is abstract). So class NewsPaper must override setOrientation() method OR it must be declared abstract.\n\n\n\nReplacing Line 9 with 'public abstract void setOrientation();' is not necessary and it will not resolve the compilation error in NewsPaper class.\n\n\n\nReplacing Line 7 with 'class Paper implements Printable {' will cause compilation failure of Paper class as it inherits abstract method 'setOrientation'."},{"id":67,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider code below:\n\npackage com.udayan.oca;\n \nclass PenDrive {\n    int capacity;\n    PenDrive(int capacity) {\n        this.capacity = capacity;\n    }\n}\n \nclass OTG extends PenDrive {\n    String type;\n    String make; \n    OTG(int capacity, String type) {\n        /*INSERT-1*/\n    }\n    OTG(String make) {\n        /*INSERT-2*/\n        this.make = make;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        OTG obj = new OTG(128, \"TYPE-C\");\n        System.out.println(obj.capacity + \":\" + obj.type);\n    }\n}\nCurrently above code causes compilation error.\n\nWhich of the options can successfully print 128:TYPE-C on to the console?","type":"Single Choice","answer":"C","answers":{"A":"Replace /*INSERT-1*/ with:\nsuper(capacity);\nReplace /*INSERT-2*/ with:\nsuper(128);\n","B":"Replace /*INSERT-1*/ with:\nsuper.capacity = capacity;\nthis.type = type;\nReplace /*INSERT-2*/ with:\nsuper(128);\n","C":"Replace /*INSERT-1*/ with:\nsuper(capacity);\nthis.type = type;\nReplace /*INSERT-2*/ with:\nsuper(0);\n","D":"Replace /*INSERT-1*/ with:\nthis.type = type;\nsuper(capacity);\nReplace /*INSERT-2*/ with:\nsuper(128);\n","E":"None of the other options\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'Java compiler adds super(); as the first statement inside constructor, if call to another constructor using this(...) or super(...) is not available. \n\nCompiler adds super(); as the first line in OTG's constructor: OTG(int capacity, String type) { super(); } but PenDrive class doesn't have a no-arg constructor and that is why OTG's constructor causes compilation error.\n\nFor the same reason, OTG(String make) constructor also causes compilation error.\n\nTo correct these compilation errors, parent class constructor should be invoked by using super(int); This would resolve compilation error.\n\nRemember: Constructor call using this(...) or super(...) must be the first statement inside the constructor.\n\n\n\nIn the main(String[]) method, OTG(int, String) constructor is invoked, which means, we OTG(String) constructor will not be executed. So, to solve the complilation error in OTG(String) constructor, super(0); or super(128); both will work and these will not affect the expected output.\n\n\n\nWe have to make changes in OTG(int, String) constructor such that on execution, output is 128:TYPE-C.\n\nsuper(capacity); will only assign value to capacity property, to assign value to type another statement is needed.\n\nthis.type = type; must be the 2nd statement.\n\nSo, /*INSERT-1*/ must be replaced with:\n\nsuper(capacity);\n\nthis.type = type;"},{"id":68,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code of Test.java file:\n\npackage com.udayan.oca;\n \nclass Document {\n    int pages;\n    Document(int pages) {\n        this.pages = pages;\n    }\n}\n \nclass Word extends Document {\n    String type;\n    Word(String type) {\n        super(20); //default pages\n        /*INSERT-1*/\n    }\n    \n    Word(int pages, String type) {\n        /*INSERT-2*/\n        super.pages = pages;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Word obj = new Word(25, \"TEXT\");\n        System.out.println(obj.type + \",\" + obj.pages);\n    }\n}\n\n\nCurrently above code causes compilation error.\n\nWhich of the options can successfully print TEXT,25 on to the console?","type":"Single Choice","answer":"B","answers":{"A":"Replace /*INSERT-1*/ with:\nthis(type);\nReplace /*INSERT-2*/ with:\nthis.type = type;\n","B":"Replace /*INSERT-1*/ with:\nthis.type = type;\nReplace /*INSERT-2*/ with:\nthis(type);\n","C":"Replace /*INSERT-1*/ with:\nsuper.type = type;\nReplace /*INSERT-2*/ with:\nthis(type);\n","D":"Replace /*INSERT-1*/ with:\nsuper.type = type;\nReplace /*INSERT-2*/ with:\nsuper(type);\n","E":"None of the other options\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'Java compiler adds super(); as the first statement inside constructor, if call to another constructor using this(...) or super(...) is not available. \n\nCompiler adds super(); as the first line in Word's constructor: Word(int pages, String type) { super(); } but Document class doesn't have a no-argument constructor and that is why Word's constructor `Word(int pages, String type)` causes compilation error.\n\n\n\nWord(String) constructor is actually not setting the passed type argument. Replace /*INSERT-1*/ with: `this.type = type;` will set the value to type variable.\n\n\n\nAs the first statement inside Word(int pages, String type){} constructor, you can either have `super(pages);` or `this(type);` but not both.\n\nReplacing /*INSERT-2*/ with `super(pages);` will be redundant as in the next statement `super.pages = pages;`, pages variable of Document class is set. Hence, replacing /*INSERT-2*/ with `this(type);` is needed to set the type variable."},{"id":69,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider codes below:\n\n//A.java\npackage com.udayan.oca;\n \npublic class A {\n    public int i1 = 1;\n    protected int i2 = 2;\n}\n\n\n//B.java\npackage com.udayan.oca.test;\n \nimport com.udayan.oca.A;\n \npublic class B extends A {\n    public void print() {\n        A obj = new A();\n        System.out.println(obj.i1); //Line 8\n        System.out.println(obj.i2); //Line 9\n        System.out.println(this.i2); //Line 10\n        System.out.println(super.i2); //Line 11\n    }\n    \n    public static void main(String [] args) {\n        new B().print();\n    }\n}\nOne of the statements inside print() method is causing compilation failure. \nWhich of the below solutions will help to resolve compilation error?","type":"Single Choice","answer":"B","answers":{"A":"Comment the statement at Line 8\n","B":"Comment the statement at Line 9\n","C":"Comment the statement at Line 10\n","D":"Comment the statement at Line 11\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'class A is declared public and defined in com.udayan.oca package, there is no problem in accessing class A outside com.udayan.oca package.\n\nclass B is defined in com.udayan.oca.test package, to extend from class A either use import statement \"import com.udayan.oca.A;\" or fully qualified name of the class com.udayan.oca.A. No issues with this class definition as well.\n\n\n\nVariable i1 is declared public in class A, so Line 8 doesn't cause any compilation error. Variable i2 is declared protected so it can only be accessed in subclass using using inheritance but not using object reference variable. obj.i2 causes compilation failure.\n\n\n\nclass B inherits variable i2 from class A, so inside class B it can be accessed by using either this or super. Line 10 and Line 11 don't cause any compilation error."},{"id":70,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider codes below:\n\n//A.java\npackage com.udayan.oca;\n \npublic class A {\n    public void print() {\n        System.out.println(\"A\");\n    }\n}\n\n\n//B.java\npackage com.udayan.oca;\n \npublic class B extends A {\n    public void print() {\n        System.out.println(\"B\");\n    }\n}\n\n\n//C.java\npackage com.udayan.oca;\n \npublic class C extends A {\n    public void print() {\n        System.out.println(\"C\");\n    }\n}\n\n\n//Test.java\npackage com.udayan.oca.test;\n \nimport com.udayan.oca.*;\n \npublic class Test {\n    public static void main(String[] args) {\n        A obj1 = new C();\n        A obj2 = new B();\n        C obj3 = (C)obj1;\n        C obj4 = (C)obj2;\n        obj3.print();\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"A\n","B":"B\n","C":"C\n","D":"Compilation error\n","E":"ClassCastException is thrown at runtime\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'Class A, B and C are declared public and inside same package com.udayan.oca. Method print() of class A has correctly been overridden by B and C.\n\nprint() method is public so no issues in accessing it anywhere.\n\n\n\nLet's check the code inside main method.\n\nA obj1 = new C(); => obj1 refers to an instance of C class, it is polymorphism. \n\nA obj2 = new B(); => obj2 refers to an instance of B class, it is polymorphism. \n\nC obj3 = (C)obj1; => obj1 actually refers to an instance of C class, so at runtime obj3 (C type) will refer to an instance of C class. As obj1 is of A type so explicit typecasting is necessary. \n\nC obj4 = (C)obj2; => obj2 actually refers to an instance of B class, so at runtime obj4 (C type) will refer to an instance of B class. B and C are siblings and can't refer to each other, so this statement will throw ClassCastException at runtime."},{"id":71,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider codes below:\n\n//A.java\npackage com.udayan.oca;\n \npublic class A {\n    public void print() {\n        System.out.println(\"A\");\n    }\n}\n\n\n//B.java\npackage com.udayan.oca;\n \npublic class B extends A {\n    public void print() {\n        System.out.println(\"B\");\n    }\n}\n\n\n//Test.java\npackage com.udayan.oca.test;\n \nimport com.udayan.oca.*;\n \npublic class Test {\n    public static void main(String[] args) {\n        A obj1 = new A();\n        B obj2 = (B)obj1;\n        obj2.print();\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"A\n","B":"B\n","C":"Compilation error\n","D":"ClassCastException is thrown at runtime\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'Class A and B are declared public and inside same package com.udayan.oca. Method print() of class A has correctly been overridden by B.\n\nprint() method is public so no issues in accessing it anywhere.\n\n\n\nLet's check the code inside main method.\n\nA obj1 = new A(); => obj1 refers to an instance of class A.\n\nB obj2 = (B)obj1; => obj1 is of type A and it is assigned to obj2 (B type), hence explicit casting is necessary. obj1 refers to an instance of class A, so at runtime obj2 will also refer to an instance of class A. sub type can't refer to an object of super type so at runtime B obj2 = (B)obj1; will throw ClassCastException."},{"id":72,"trainingUnit":"OCA","trainingContent":"Methods, Encapsulation, Inheritance and Polymorphism - 1","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nclass Parent {\n    public String toString() {\n        return \"Inner \";\n    }\n}\n \nclass Child extends Parent {\n    public String toString() {\n        return super.toString().concat(\"Peace!\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(new Child());\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Inner\n","B":"Peace!\n","C":"Inner Peace!\n","D":"Compilation error\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'System.out.println(new Child()); invokes the toString() method on Child's instance.\n\nParent class's method can be invoked by super keyword. super.toString() method returns \"Inner \" and \"Inner \".concat(\"Peace!\") returns \"Inner Peace!\"."}]