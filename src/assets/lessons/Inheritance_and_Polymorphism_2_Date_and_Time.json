[{"id":1,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Super {\n    Super() {\n        System.out.print(\"Reach\");\n    }\n}\n \nclass Sub extends Super {\n    Sub() {\n        Super();\n        System.out.print(\"Out\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        new Sub();\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"B","answers":{"A":"Compilation Error in Super class\n","B":"Compilation Error in Sub class\n","C":"Compilation Error in Test class\n","D":"It prints ReachOut on to the console\n","E":"It prints OutReach on to the console\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Parent (Super) class constructor is invoked by `super();` (all letters in lowercase) from within the constructor of subclass.\n\nFirst statement inside no-argument constructor of Sub class is: `Super();` (Letter 'S' is in uppercase) and hence it causes compilation error."},{"id":2,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Super {\n    void Super() {\n        System.out.print(\"KEEP_\");\n    }\n}\n \nclass Base extends Super {\n    Base() {\n        Super();\n        System.out.print(\"GOING_\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        new Base();\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"D","answers":{"A":"Compilation Error in Super class\n","B":"Compilation Error in Base class\n","C":"Compilation Error in Test class\n","D":"It prints KEEP_GOING_ on to the console\n","E":"It prints GOING_KEEP_ on to the console\n","F":"It prints KEEP_KEEP_GOING_ on to the console\n","G":"It prints GOING_ on to the console\n","H":"\n","I":"\n","J":"\n"},"explanation":"Super class defines a method with name Super() but not any constructor. Hence compiler adds below default constructor in Super class:\nSuper() {\n    super();\n}\nClass Super extends from Object class and Object class has no-argument constructor, which is called by the super(); statement in above default constructor.\nJava compiler also adds `super();` as the first statement inside the no-argument constructor of Base class:\nBase() {\n    super();\n    Super();\n    System.out.print(\"GOING_\");\n}\nAs Base extends Super and both the classes are in the same package, hence `super();` invokes the no-argument constructor of Super class and `Super();` invokes the Super() method of Super class. Base class inherits the Super() method of Super class.\nNo compilation error in any of the classes.\nOn executing Test class, main(String[]) is invoked, which executes `new Base();` statement.\nNo-argument constructor of Base class is invoked, which executes `super();`, hence no-argument constructor of Super class is invoked.\nNext, `Super();` is executed and this invokes the Super() method of Super class and hence KEEP_ is printed on to the console.\nAfter that, `System.out.print(\"GOING_\");` is executed and GOING_ is printed on to the console.\nmain(String []) method finishes its execution and program terminates successfully after printing KEEP_GOING_ on to the console."},{"id":3,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass MyClass {\n    MyClass() {\n        System.out.println(101);\n    }\n}\n \nclass MySubClass extends MyClass {\n    final MySubClass() {\n        System.out.println(202);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(new MySubClass());\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error\n","B":"101\n202\n<Some text containing @ symbol>\n","C":"202\n<Some text containing @ symbol>\n","D":"202\n101\n<Some text containing @ symbol>\n","E":"101\n<Some text containing @ symbol>\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Constructors cannot use final, abstract or static modifiers. As no-argument constructor of MySubClass uses final modifier, therefore it causes compilation error."},{"id":4,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 3 java files:\n\n//Animal.java\npackage a;\n \npublic class Animal {\n    Animal() {\n        System.out.print(\"ANIMAL-\");\n    }\n}\n\n\n//Dog.java\npackage d;\n \nimport a.Animal;\n \npublic class Dog extends Animal {\n    public Dog() {\n        System.out.print(\"DOG\");\n    }\n}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \nimport d.Dog;\n \npublic class Test {\n    public static void main(String[] args) {\n        new Dog();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"Compilation error in Animal.java file\n","B":"Compilation error in Dog.java file\n","C":"Compilation error in Test.java file\n","D":"It executes successfully and prints ANIMAL-DOG on to the console\n","E":"It executes successfully and prints DOG on to the console\n\n","F":"It executes successfully but nothing is printed on to the console\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"super(); is added by the compiler as the first statement in both the constructors:\n\nAnimal() {\n\n    super();\n\n    System.out.print(\"ANIMAL-\");\n\n}\n\n\n\nand\n\n\n\npublic Dog() {\n\n    super();\n\n    System.out.print(\"DOG\");\n\n}\n\n\n\nClass Animal extends from Object class and Object class has no-argument constructor, hence no issues with the constructor of Animal class.\n\n\n\nAnimal class's constructor has package scope, which means it is accessible to all the classes declared in package 'a'. But Dog class is declared in package 'b' and hence `super();` statement inside Dog class's constructor causes compilation error as no-argument constructor of Animal class is not visible.\n\n\n\nThere is no compilation error in Test.java file as Dog class's constructor is public and therefore `new Dog();` compiles successfully."},{"id":5,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code fragment:\n\npackage com.udayankhattry.oca;\n \nabstract class Food {\n    protected abstract double getCalories();\n}\n \nclass JunkFood extends Food {\n    double getCalories() {\n        return 200.0;\n    }\n}\n\n\nWhich 3 modifications, done independently, enable the code to compile?","type":"Multiple Choice","answer":"B,D,E","answers":{"A":"Make the getCalories() method of Food class public\n","B":"Remove the protected access modifier from the getCalories() method of Food class\n","C":"Make the getCalories() method of Food class private\n","D":"Make the getCalories() method of JunkFood class protected\n","E":"Make the getCalories() method of JunkFood class public\n","F":"Make the getCalories() method of JunkFood class private\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"abstract methods cannot be declared with private modifier as abstract methods need to be overridden in child classes.\n\nabstract methods can be declared with either public, protected and package (no access modifier) modifier and hence overriding method cannot be declared which private modifier in the child class. That is why getCalories() method in Food and JunkFood classes cannot be declared private.\n\n\n\nAccess modifier of overriding method should either be same as the access modifier of overridden method or it should be less restrictive than the access modifier of overridden method. Hence below solutions will work:\n\n1. Remove the protected access modifier from the getCalories() method of Food class: By doing this, both the overridden and overriding methods will have same access modifier (no access modifier)\n\nor\n\n2. Make the getCalories() method of JunkFood class protected: By doing this, both the overridden and overriding methods will have same access modifier (protected)\n\nor\n\n3. Make the getCalories() method of JunkFood class public: By doing this, access modifier of overriding method (which is public) is less restrictive than the access modifier of overridden method (which is protected)"},{"id":6,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nabstract class Log {\n    abstract long count(); //Line n1\n    abstract Object get(); //Line n2\n}\n \nclass CommunicationLog extends Log {\n    int count() { //Line n3\n        return 100;\n    }\n    \n    String get() { //Line n4\n        return \"COM-LOG\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Log log = new CommunicationLog(); //Line n5\n        System.out.print(log.count());\n        System.out.print(log.get());\n    }\n}\n\n\nWhich of the following statement is correct?","type":"Single Choice","answer":"A","answers":{"A":"Line n3 causes compilation error\n","B":"Line n4 causes compilation error\n","C":"Line n5 causes compilation error\n","D":"Given code compiles successfully and on execution prints 100COM-LOG on to the console\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"CommunicationLog class overrides count() and get() methods of Log class.\n\nThere are 2 rules related to return types:\n\n1. If return type of overridden method is of primitive type, then overriding method should use same primitive type.\n\n2. If return type of overridden method is of reference type, then overriding method can use same reference type or its sub-type (also known as covariant return type).\n\n\n\ncount() method at Line n1 returns long but overriding method at Line n3 returns int and that is why Line n3 causes compilation error.\n\nget() method at Line n2 returns Object but overriding method at Line n4 returns String. String is a subclass of Object, so it is a case of covariant return type and hence allowed. Line n4 compiles successfully."},{"id":7,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        P p = new R(); //Line n1\n        System.out.println(p.compute(\"Go\")); //Line n2\n    }\n}\n \nclass P {\n    String compute(String str) {\n        return str + str + str;\n    }\n}\n \nclass Q extends P {\n    String compute(String str) {\n        return super.compute(str.toLowerCase());\n    }\n}\n \nclass R extends Q {\n    String compute(String str) {\n        return super.compute(str.replace('o', 'O')); //2nd argument is uppercase O\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"gOgOgO\n","B":"gogogo\n","C":"GoGoGo\n","D":"GOGOGO\n","E":"Go\n","F":"GO\n","G":"go\n","H":"\n","I":"\n","J":"\n"},"explanation":"Class Q correctly overrides the compute(String) method of P class and class R correctly overrides the compute(String) method of Q class. Keyword super is used to invoke the method of parent class.\n\n\n\nAt Line n1, reference variable 'p' refers to an instance of class R, hence p.compute(\"Go\") invokes the compute(String) method of R class.\n\nreturn super.compute(str.replace('o', 'O')); => return super.compute(\"Go\".replace('o', 'O')); => return super.compute(\"GO\");\n\n\n\nIt invokes the compute(String) method of Parent class, which is Q.\n\n=> return super.compute(str.toLowerCase()); => return super.compute(\"GO\".toLowerCase()); => return super.compute(\"go\");\n\n\n\nIt invokes the compute(String) method of Parent class, which is P.\n\n=> return str + str + str; => return \"gogogo\";\n\n\n\nControl goes back to compute(String) method of Q and to the compute(String) method of R, which returns \"gogogo\".\n\nLine n2 prints gogogo on to the console."},{"id":8,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass X {\n    void A() {\n        System.out.print(\"A\");\n    }\n}\n \nclass Y extends X {\n    void A() {\n        System.out.print(\"A-\");\n    }\n    \n    void B() {\n        System.out.print(\"B-\");\n    }\n    \n    void C() {\n        System.out.print(\"C-\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        X obj = new Y(); //Line n1\n        obj.A(); //Line n2\n        obj.B(); //Line n3\n        obj.C(); //Line n4\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"D","answers":{"A":"A-B-C-\n","B":"AB-C-\n","C":"Compilation error in class Y\n","D":"Compilation error in class Test\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Class Y correctly extends class X and it overrides method A() and provides two new methods B() and C().\n\nAt Line n1, obj is of X type and therefore obj.B(); and obj.C(); cause compilation error as these methods are not defined in class X."},{"id":9,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 3 java files:\n\n//M.java\npackage com.udayankhattry.oca;\n \npublic class M {\n    public void printName() {\n        System.out.println(\"M\");\n    }\n}\n\n\n//N.java\npackage com.udayankhattry.oca;\n \npublic class N extends M {\n    public void printName() {\n        System.out.println(\"N\");\n    }\n}\n\n\n//Test.java\npackage com.udayankhattry.oca.test;\n \nimport com.udayankhattry.oca.*;\n \npublic class Test {\n    public static void main(String[] args) {\n        M obj1 = new M();\n        N obj2 = (N)obj1;\n        obj2.printName();\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"It executes successfully and prints M on to the console\n","B":"It executes successfully and prints N on to the console\n","C":"Compilation error\n","D":"An exception is thrown at runtime\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Class M and M are declared public and inside same package com.udayankhattry.oca. Method printName() of class M has correctly been overridden by N.\n\nprintName() method is public so no issues in accessing it anywhere.\n\n\n\nLet's check the code inside main method.\n\nM obj1 = new M(); => obj1 refers to an instance of class M.\n\nN obj2 = (N)obj1; => obj1 is of type M and it is assigned to obj2 (N type), hence explicit casting is necessary. obj1 refers to an instance of class M, so at runtime obj2 will also refer to an instance of class M. sub type can't refer to an instance of super type so at runtime `N obj2 = (N)obj1;` will throw ClassCastException."},{"id":10,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Currency {\n    String notation = \"-\"; //Line n1\n \n    String getNotation() { //Line n2\n        return notation;\n    }\n}\n \nclass USDollar extends Currency {\n    String notation = \"$\"; //Line n3\n \n    String getNotation() { //Line n4\n        return notation;\n    }\n}\n \nclass Euro extends Currency {\n    protected String notation = \"€\"; //Line n5\n \n    protected String getNotation() { //Line n6\n        return notation;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Currency c1 = new USDollar();\n        System.out.println(c1.notation + \":\" + c1.getNotation());\n        \n        Currency c2 = new Euro();\n        System.out.println(c2.notation + \":\" + c2.getNotation());\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"A","answers":{"A":"-:$\n-:€\n","B":"-:-\n-:-\n","C":"$:$\n€:€\n","D":"Compilation error in USDollar class\n","E":"Compilation error in Euro class\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n3 hides the variable created at Line n1 and Line n4 overrides the getNotation() method of Line n2. There is no compilation error for USDollar class as it correctly overrides getNotation() method.\n\nSimilarly, Line n5 hides the variable created at Line n1 and Line n6 overrides the getNotation() method of Line n2. There is no compilation error for Euro class as it correctly overrides getNotation() method as well.\n\n\n\n'c1' is of Currency type, hence c1.notation refers to \"-\" and c1.getNotation() invokes overriding method of USDollar class and it returns \"$\".\n\nSimilarly, c2.notation refers to \"-\" and c2.getNotation() invokes overriding method of Euro class and it returns \"€\"."},{"id":11,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Shape {\n    int side = 0; //Line n1\n \n    int getSide() { //Line n2\n        return side;\n    }\n}\n \nclass Square extends Shape {\n    private int side = 4; //Line n3\n \n    protected int getSide() { //Line n4\n        return side;\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Shape s = new Square();\n        System.out.println(s.side + \":\" + s.getSide());\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error at Line n3\n","B":"Compilation error at Line n4\n","C":"0:0\n","D":"0:4\n","E":"4:4\n","F":"4:0\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n3 hides the variable created at Line n1 and Line n4 overrides the getSide() method of Line n2. There is no compilation error for Square class as it correctly overrides getSide() method. You can use any access modifier at Line n3 as well, there are no rules for variable hiding.\n\n\n\n's' is of Shape type, hence s.side equals to 0 and s.getSide() invokes overriding method of Square class and it returns 4. Hence output is: 0:4."},{"id":12,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Super {\n    public String num = \"10\"; //Line n1\n}\n \nclass Sub extends Super {\n    protected int num = 20; //Line n2\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Super obj = new Sub();\n        System.out.println(obj.num += 2); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"E","answers":{"A":"Compilation error at Line n2\n","B":"Compilation error at Line n3\n","C":"It executes successfully and prints 12 on to the console\n","D":"It executes successfully and prints 22 on to the console\n","E":"It executes successfully and prints 102 on to the console\n","F":"It executes successfully and prints 202 on to the console\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n2 hides the variable created at Line n1, there is no rules related to hiding (type and access modifier can be changed).\n\n\n\n'obj' is of Super type, hence obj.num refers to num variable at Line n1, which is of String type.\n\nExpression at Line n3:\n\nobj.num += 2\n\n=> obj.num = obj.num + 2\n\n=> obj.num = \"10\" + 2\n\n=> obj.num = \"102\"\n\n\n\nobj.num refers to \"102\" and same is printed on to the console."},{"id":13,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Parent {\n    int var = 1000; // Line n1\n \n    int getVar() {\n        return var;\n    }\n}\n \nclass Child extends Parent {\n    private int var = 2000; // Line n2\n \n    int getVar() {\n        return super.var; //Line n3\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Child obj = new Child(); // Line n4\n        System.out.println(obj.var); // Line n5\n    }\n}\n\n\nThere is a compilation error in the code.\n\nWhich three modifications, done independently, print 1000 on to the console?","type":"Multiple Choice","answer":"B,D,F","answers":{"A":"Change Line n1 to private int var = 1000;\n","B":"Delete the Line n2\n","C":"Change Line n3 to return var;\n","D":"Change Line n4 to Parent obj = new Child();\n","E":"Delete the method getVar() from the Child class\n","F":"Change Line n5 to System.out.println(obj.getVar());\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n2 hides the variable created at Line n1, there is no rules related to hiding (type and access modifier can be changed).\n\n\n\nLine n5 causes compilation error as obj is of Child type and 'var' is declared private in Child class. Variable 'var' of Child class cannot be accessed outside the Child class.\n\n\n\nLet's check all the options one by one:\n\n'Change Line n1 to private int var = 1000;' => It will not rectify the existing error of Line n5, in fact after this change, Line n3 will also cause compilation error.\n\n\n\n'Delete the Line n2' => After deleting this line, obj.var at Line n5 will refer to variable 'var' of Parent class. Hence, output will be 1000 in this case.\n\n\n\n'Change Line n3 to return var;' => This will have no effect to the output of the code, as getVar() method has not been invoked.\n\n\n\n'Change Line n4 to Parent obj = new Child();' => After this modification, obj becomes Parent type, hence obj.var will refer to variable 'var' of Parent class. Hence, output will be 1000 in this case.\n\n\n\n'Delete the method getVar() from the Child class' => This will have no effect to the output of the code, as getVar() method has not been invoked.\n\n\n\n'Change Line n5 to System.out.println(obj.getVar());' => obj.getVar() will invoke the getVar() method of Child class and this method returns the variable value from Parent class (super.var). Hence, output will be 1000 in this case."},{"id":14,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Base {\n    String msg = \"INHALE\"; //Line n1\n}\n \nclass Derived extends Base {\n    Object msg = \"EXHALE\"; //Line n2\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base obj1 = new Base(); //Line n3\n        Base obj2 = new Derived(); //Line n4\n        Derived obj3 = (Derived) obj2; //Line n5\n        String text = obj1.msg + \"-\" + obj2.msg + \"-\" + obj3.msg; //Line n6\n        System.out.println(text); //Line n7\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"E","answers":{"A":"Line n2 causes compilation error\n","B":"Line n5 throws Exception at runtime\n","C":"Line n6 causes compilation error\n","D":"It executes successfully and prints INHALE-EXHALE-EXHALE\n","E":"It executes successfully and prints INHALE-INHALE-EXHALE\n","F":"It executes successfully and prints INHALE-INHALE-EXHALE\n","G":"None of the other options\n","H":"\n","I":"\n","J":"\n"},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n2 hides the variable created at Line n1, there is no rules related to hiding (type and access modifier can be changed).\n\n\n\nAt Line n3, obj1 is of Base type and refers to an instance of Base class.\n\n\n\nAt Line n4, obj2 is of Base type and refers to an instance of Derived class.\n\n\n\nAt Line n5, as obj2 refers to an instance of Derived class, hence typecasting it to Derived type doesn't cause any Exception. obj3 is of Derived type and refers to an instance of Derived class.\n\n\n\nLet's check the expression of Line n6:\n\nobj1.msg + \"-\" + obj2.msg + \"-\" + obj3.msg;\n\n=> (obj1.msg + \"-\") + obj2.msg + \"-\" + obj3.msg; //+ operator is left to right associative and behaves as concatenation operator as one of the operand is of String type.\n\n=> ((obj1.msg + \"-\") + obj2.msg) + \"-\" + obj3.msg;\n\n=> (((obj1.msg + \"-\") + obj2.msg) + \"-\") + obj3.msg;\n\nLet's solve the expression now:\n\n=> (((\"INHALE\" + \"-\") + obj2.msg) + \"-\") + obj3.msg; //obj1 is of Base type, hence obj1.msg refers to \"INHALE\"\n\n=> ((\"INHALE-\" + obj2.msg) + \"-\") + obj3.msg;\n\n=> ((\"INHALE-\" + \"INHALE\") + \"-\") + obj3.msg; //obj2 is of Base type, hence obj2.msg refers to \"INHALE\"\n\n=> (\"INHALE-INHALE\" + \"-\") + obj3.msg;\n\n=> \"INHALE-INHALE-\" + obj3.msg;\n\nIn above expression, left operand is of String type and right operand is of Object type, so toString() method is invoked. So, given expression is evaluated as:\n\n=> \"INHALE-INHALE-\" + obj3.msg.toString();\n\n=> \"INHALE-INHALE-\" + \"EXHALE\"; //As obj3.msg is of Object type and refers to an instance of String type, hence toString() method on \"EXHALE\" instance is invoked and this returns \"EXHALE\".\n\n=> \"INHALE-INHALE-EXHALE\";\n\n\n\nLine n7 prints INHALE-INHALE-EXHALE on to the console."},{"id":15,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Base {\n    static void print() { //Line n1\n        System.out.println(\"BASE\");\n    }\n}\n \nclass Derived extends Base {\n    static void print() { //Line n2\n        System.out.println(\"DERIVED\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base b = null;\n        Derived d = (Derived) b; //Line n3\n        d.print(); //Line n4\n    }\n}\n\n\nWhich of the following statements is true for above code?","type":"Single Choice","answer":"F","answers":{"A":"Line n2 causes compilation error\n","B":"Line n3 causes compilation error\n","C":"Line n4 causes compilation error\n","D":"Code compiles successfully and on execution Line n3 throws an exception\n","E":"Code compiles successfully and on execution prints BASE on to the console\n","F":"Code compiles successfully and on execution prints DERIVED on to the console\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"print() method at Line n2 hides the method at Line n1. So, no compilation error at Line n2.\n\n\n\nReference variable 'b' is of type Base, so `(Derived) b` does not cause any compilation error. Moreover, at runtime it will not throw any ClassCastException as well because b is null. Had 'b' been referring to an instance of Base class [Base b = new Base();], `(Derived) b` would have thrown ClassCastException.\n\n\n\nd.print(); doesn't cause any compilation error but as this syntax creates confusion, so it is not a good practice to access the static variables or static methods using reference variable, instead class name should be used. Derived.print(); is the preferred syntax.\n\n\n\nd.print(); invokes the static print() method of Derived class and prints DERIVED on to the console."},{"id":16,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Paper {\n    static String getType() { //Line n1\n        return \"GENERIC\";\n    }\n}\n \nclass RuledPaper extends Paper {\n    String getType() { //Line n2\n        return \"RULED\";\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Paper paper = new RuledPaper(); //Line n3\n        System.out.println(paper.getType()); //Line n4\n    }\n}\n\n\nWhich of the following statements is true for above code?","type":"Single Choice","answer":"A","answers":{"A":"Compilation error in RuledPaper class\n","B":"Compilation error in Test class\n","C":"Code compiles successfully and on execution prints GENERIC on to the console\n","D":"Code compiles successfully and on execution prints RULED on to the console\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Instance method of subclass cannot override the static method of superclass.\n\n\n\nInstance method at Line n2 tries to override the static method at Line n1 and hence Line n2 causes compilation error.\n\n\n\nThere is no issue with Line n3 as reference variable of superclass can refer to an instance of subclass.\n\n\n\nAt Line n4, paper.getType() doesn't cause compilation error but as this syntax creates confusion, so it is not a good practice to access the static variables or static methods using reference variable, instead class name should be used. Paper.getType() is the preferred syntax."},{"id":17,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass M {\n    public void main(String[] args) { //Line n1\n        System.out.println(\"M\");\n    }\n}\n \nclass N extends M {\n    public static void main(String[] args) { //Line n2\n        new M().main(args); //Line n3\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        N.main(args); //Line n4\n    }\n}\n\n\nWhich of the following statements is true for above code?","type":"Single Choice","answer":"B","answers":{"A":"Line n1 causes compilation error\n","B":"Line n2 causes compilation error\n","C":"Line n3 causes compilation error\n","D":"Line n4 causes compilation error\n","E":"It executes successfully and prints M on to the console\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"The static method of subclass cannot hide the instance method of superclass. static main(String []) method at Line n2 tries to hide the instance main(String []) method at Line n1 and hence Line n2 causes compilation error.\n\n\n\nThere is no issue with Line n3 as it is a valid syntax to invoke the instance main(String []) method of M class.\n\n\n\nNo issue with Line n4 as well as it correctly invokes static main(String []) method of N class."},{"id":18,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Parent {\n    String quote = \"MONEY DOESN'T GROW ON TREES\";\n}\n \nclass Child extends Parent {\n    String quote = \"LIVE LIFE KING SIZE\";\n}\n \nclass GrandChild extends Child {\n    String quote = \"PLAY PLAY PLAY\";\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        GrandChild gc = new GrandChild();\n        System.out.println(/*INSERT*/);\n    }\n}\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print MONEY DOESN'T GROW ON TREES on to the console?\n\nSelect 2 options.","type":"Multiple Choice","answer":"C,D","answers":{"A":"gc.quote\n","B":"(Parent)gc.quote\n","C":"((Parent)gc).quote\n","D":"((Parent)(Child)gc).quote\n","E":"(Parent)(Child)gc.quote\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"As instance variables are hidden by subclasses and not overridden, therefore instance variable can be accessed by using explicit casting.\n\nLet's check all the options one by one:\n\ngc.quote => It refers to \"PLAY PLAY PLAY\" as gc is of GrandChild class.\n\n\n\n(Parent)gc.quote => gc.quote will be evaluated first as dot (.) operator has higher precedence than cast. gc.quote refers to String, hence it cannot be casted to Parent type. This would cause compilation error.\n\n\n\n((Parent)gc).quote => Variable 'gc' is casted to Parent type, so this expression refers to \"MONEY DOESN'T GROW ON TREES\". It is one of the correct options.\n\n\n\n((Parent)(Child)gc).quote => 'gc' is of GrandChild type, it is first casted to Child and then to Parent type and finally quote variable is accessed, so this expression refers to \"MONEY DOESN'T GROW ON TREES\". It is also one of the correct options.\n\n\n\n(Parent)(Child)gc.quote => gc.quote will be evaluated first as dot (.) operator has higher precedence than cast. gc.quote refers to String, hence it cannot be casted to Child type. This would cause compilation error."},{"id":19,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass X {\n    void greet() {\n        System.out.println(\"Good Morning!\");\n    }\n}\n \nclass Y extends X {\n    void greet() {\n        System.out.println(\"Good Afternoon!\");\n    }\n}\n \nclass Z extends Y {\n    void greet() {\n        System.out.println(\"Good Night!\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        X x = new Z();\n        x.greet(); //Line n1\n        ((Y)x).greet(); //Line n2\n        ((Z)x).greet(); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error\n","B":"An exception is thrown at runtime\n","C":"It compiles successfully and on execution prints below:\nGood Night!\nGood Afternoon!\nGood Morning\n","D":"It compiles successfully and on execution prints below:\nGood Night!\nGood Night!\nGood Night!\n","E":"It compiles successfully and on execution prints below:\nGood Morning!\nGood Morning!\nGood Morning!\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Variable x is of X type (superclass) and refers to an instance of Z type (subclass).\n\nAt Line n1, compiler checks whether greet() method is available in class X or not. As greet() method is available in class X, hence no compilation error for Line n1.\n\nAt Line n2, x is casted to Y and compiler checks whether greet() method is available in class Y or not. As greet() method is available in class Y, hence no compilation error for Line n2.\n\nAt Line n3, x is casted to Z and compiler checks whether greet() method is available in class Z or not. As greet() method is available in class Z, hence no compilation error for Line n3.\n\n\n\nThere is no compilation error in the given code it compiles successfully.\n\n\n\nVariable x refers to an instance of Z class and at Line n1, n2 and n3 same instance is being used. Which overriding method to invoke, is decided at runtime based on the instance.\n\nAt runtime, all three statements, at Line n1, Line n2 and Line n3 would invoke the greet() method of Z class, which would print Good Night! three times on to the console."},{"id":20,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Base {\n    int id = 1000; //Line n1\n \n    Base() {\n        Base(); //Line n2\n    }\n \n    void Base() { //Line n3\n        System.out.println(++id); //Line n4\n    }\n}\n \nclass Derived extends Base {\n    int id = 2000; //Line n5\n \n    Derived() {} //Line n6\n \n    void Base() { //Line n7\n        System.out.println(--id); //Line n8\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Base base = new Derived(); //Line n9\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"H","answers":{"A":"1000\n","B":"1001\n","C":"999\n","D":"2000\n","E":"1999\n","F":"2001\n","G":"0\n","H":"-1\n","I":"Compilation error\n","J":"An exception is thrown\n"},"explanation":"Method can have same name as that of the Class. Hence, void Base() is a valid method declaration in Base class.\n\n\n\nLine n2 invokes the Base() method and not the constructor.\n\n\n\nSubclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n5 hides the variable created at Line n1, there is no rules related to hiding (type and access modifier can be changed).\n\n\n\nLine n7 correctly overrides the Base() method of class Base.\n\n\n\nCompiler adds super(); as the 1st statement inside the no-argument constructor of Base class and Derived class.\n\n\n\nThere is no compilation error, so let's check the execution.\n\n\n\nnew Derived() at Line n9 invokes the constructor of Derived class, at this point instance variable id is declared and 0 is assigned to it. In fact, instance variable id of Base class is also declared and 0 is assigned to it. Compiler added super(); as the first statement inside this constructor, hence control goes to the no-argument constructor of Base class.\n\n\n\nCompiler added super(); as the first statement inside this constructor as well, hence it invokes the no-argument constructor of the Object class. No-argument constructor of Object class finishes its execution and control goes back to the constructor of Base class. Before it starts executing remaining statements inside the constructor, instance variable assignment statement (if available) are executed. This means 1000 is assigned to variable id of Base class.\n\n\n\nLine n2 is executed next, Base() method defined in Derived class is executed. Which overriding method to invoke, is decided at runtime based on the instance. Instance is of Derived class (because of Line n9), hence control starts executing Base() method of Derived class.\n\nLine n8 is executed next, Derived class hides the id variable of Base class and that is why at Line n8, id points to variable created at Line n5. This id variable still stores the value 0 as Base class's constructor has not finishes its execution.\n\n\n\nvalue of id is decremented by 1, so id becomes -1 and -1 is printed on to the console. Base() method finishes its execution and control goes back to Line n2. No-argument constructor of Base class finishes its execution and control goes back to the constructor of Derived class. Before it starts executing remaining statements inside the constructor, instance variable assignment statement (if available) are executed. This means 2000 is assigned to variable id of Derived class.\n\n\n\nNo-argument constructor of Derived class finishes its execution and control goes back to Line n9. main(String []) method finishes its execution and program terminates successfully.\n\n\n\nHence, output is -1."},{"id":21,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Lock {\n    public void open() {\n        System.out.println(\"LOCK-OPEN\");\n    }\n}\n \nclass Padlock extends Lock {\n    public void open() {\n        System.out.println(\"PADLOCK-OPEN\");\n    }\n}\n \nclass DigitalPadlock extends Padlock {\n    public void open() {\n        /*INSERT*/\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Lock lock = new DigitalPadlock();\n        lock.open();\n    }\n}\n\n\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print LOCK-OPEN on to the console?","type":"Single Choice","answer":"E","answers":{"A":"super.open();\n","B":"super.super.open();\n","C":"((Lock)super).open();\n","D":"(Lock)super.open();\n","E":"None of the other options\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"super.open(); => Using super keyword, you can access methods and variables of immediate parent class, hence if you replace /*INSERT*/ with `super.open();`, then open() method of Padlock class will be invoked.\n\n\n\nsuper.super.open(); => super.super is not allowed in java, it causes compilation error.\n\n\n\n((Lock)super).open(); => Not possible to cast super keyword in java, it causes compilation error.\n\n\n\n(Lock)super.open(); => super.open(); will be evaluated first as dot (.) operator has higher precedence than cast. super.open(); returns void and hence it cannot be casted to Lock. It also causes compilation error.\n\n\n\nIn fact, it is not possible to directly reach to 2 levels, super keyword allows to access methods and variables of immediate parent class only (just 1 level up). Hence, correct answer is: 'None of the other options'"},{"id":22,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Super {\n    final int NUM = -1; //Line n1\n}\n \nclass Sub extends Super {\n    /*INSERT*/\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Sub obj = new Sub();\n        obj.NUM = 200; //Line n2\n        System.out.println(obj.NUM); //Line n3\n    }\n}\n\n\nAbove code causes compilation error, which modifications, done independently, enable the code to compile and on execution print 200 on to the console?\n\nSelect 4 options.","type":"Multiple Choice","answer":"A,C,D,H","answers":{"A":"Remove final modifier from Line n1\n","B":"Replace /*INSERT*/ with byte NUM;\n","C":"Replace /*INSERT*/ with short NUM;\n","D":"Replace /*INSERT*/ with int NUM;\n","E":"Replace /*INSERT*/ with float NUM;\n","F":"Replace /*INSERT*/ with double NUM;\n","G":"Replace /*INSERT*/ with boolean NUM;\n","H":"Replace /*INSERT*/ with Object NUM;\n","I":"\n","J":"\n"},"explanation":"Variable NUM is declared in Super class and class Sub extends Super, hence NUM can be accessed by using obj.NUM.\n\nBut as NUM Is final, hence it cannot be reassigned, therefore Line n2 causes compilation error. Let's check all the options one by one:\n\n\n\nRemove final modifier from Line n1 => ✓ Valid option and in this case output is 200.\n\nReplace /*INSERT*/ with byte NUM; => ✗ In this case, class Sub hides the variable NUM of Super class but Line n2 will still not compile as byte range is from -128 to 127 and 200 is out of range value.\n\nReplace /*INSERT*/ with short NUM; => ✓ In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to short type. In this case output is 200.\n\nReplace /*INSERT*/ with int NUM; => In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to int type. In this case output is 200.\n\nReplace /*INSERT*/ with float NUM; => ✗ In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to float type. But output in this case will be 200.0 and not 200.\n\nReplace /*INSERT*/ with double NUM; => ✗ In this case, class Sub hides the variable NUM of Super class and 200 can be easily assigned to double type. But output in this case will be 200.0 and not 200.\n\nReplace /*INSERT*/ with boolean NUM; => ✗ In this case, class Sub hides the variable NUM of Super class but Line n2 will still not compile as boolean type in java allows 2 values true and false. 200 is not compatible with boolean type.\n\nReplace /*INSERT*/ with Object NUM; => ✓ In this case, class Sub hides the variable NUM of Super class and at Line n2, value 200 is boxed to Integer, which is then assigned to obj.NUM. So, obj.NUM refers to an instance of Integer class. Line n3 invokes toString() method of Integer class and hence 200 is printed on to the console."},{"id":23,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 3 java files:\n\n//Sellable.java\npackage com.udayankhattry.oca;\n \npublic interface Sellable {\n    double getPrice();\n    \n    default String symbol() {\n        return \"$\";\n    }\n}\n\n\n//Chair.java\npackage com.udayankhattry.oca;\n \npublic class Chair implements Sellable {\n    public double getPrice() {\n        return 35;\n    }\n    \n    public String symbol() {\n        return \"£\";\n    }\n}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Sellable obj = new Chair(); //Line n1\n        System.out.println(obj.symbol() + obj.getPrice()); //Line n2\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"G","answers":{"A":"Compilation error in Chair class\n","B":"Compilation error in Test class\n","C":"It compiles successfully and on execution prints $35 on to the console\n","D":"It compiles successfully and on execution prints $35.0 on to the console\n","E":"It compiles successfully and on execution prints $35.00 on to the console\n","F":"It compiles successfully and on execution prints £35 on to the console\n","G":"It compiles successfully and on execution prints £35.0 on to the console\n","H":"It compiles successfully and on execution prints £35.00 on to the console\n","I":"\n","J":"\n"},"explanation":"default methods were added in Java 8. Class Chair correctly implements Sellable interface and it also overrides the default symbol() method of Sellable interface.\n\n\n\nAt Line n1, 'obj' refers to an instance of Chair class, so obj.symbol() and obj.getPrice() invoke the overriding methods of Chair class only.\n\nobj.symbol() returns \"£\" and obj.getPrice() returns 35.0\n\n\n\nAt Line n2, '+' operator behaves as concatenation operator and Line n2 prints £35.0 on to the console."},{"id":24,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 2 java files:\n\n//Flyable.java\npackage com.udayankhattry.oca;\n \npublic interface Flyable {\n    static int horizontalDegree() { //Line n1\n        return 20;\n    }\n \n    default void fly() {\n        System.out.println(\"Flying at \" + horizontalDegree() + \" degrees.\"); //Line n2\n    }\n \n    void land();\n}\n\n\n//Aeroplane.java\npackage com.udayankhattry.oca;\n \npublic class Aeroplane implements Flyable {\n    public void land() {\n        System.out.println(\"Landing at \" + -Flyable.horizontalDegree() + \" degrees.\"); //Line n3\n    }\n \n    public static void main(String[] args) {\n        new Aeroplane().fly();\n        new Aeroplane().land();\n    }\n}\n\n\nWhat will be the result of compiling and executing Aeroplane class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error at Line n1\n","B":"Compilation error at Line n2\n","C":"Compilation error at Line n3\n","D":"Given code compiles successfully and on execution prints below in the output:\nFlying at 20 degrees.\nLanding at -20 degrees.\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"As per Java 8, default and static methods were added in the interface and default methods can invoke static method as well. Hence, there is no issue with the Flyable interface.\n\n\n\nclass Aeroplane implements Flyable interface, hence it inherits the default method fly() and static method horizontalDegree() can be accessed using Flyable.horizontalDegree(). It also provides the implementation of land() method. There is no issue with Aeroplane class as well.\n\n\n\nOn execution below text is printed on to the console:\n\nFlying at 20 degrees.\n\nLanding at -20 degrees."},{"id":25,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 3 java files:\n\n//Super.java\npackage com.udayankhattry.oca;\n \npublic interface Super {\n    String name = \"SUPER\"; //Line n1\n}\n\n\n//Sub.java\npackage com.udayankhattry.oca;\n \npublic interface Sub extends Super { //Line n2\n \n}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Sub sub = null;\n        System.out.println(sub.name); //Line n3\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"E","answers":{"A":"Line n1 causes compilation error\n","B":"Line n2 causes compilation error\n","C":"Line n3 causes compilation error\n","D":"Line n3 throws an exception at runtime\n","E":"Test class compiles successfully and on execution prints SUPER on to the console\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Variable 'name' declared inside interface Super is implicitly public, static and final. Line n1 compiles successfully.\n\nIn Java a class can extend from only one class but an interface can extend from multiple interfaces. Line n2 compiles successfully.\n\nVariable 'name' can be accessed in 2 ways: Super.name and Sub.name.\n\nThough correct way to refer static variable is by using the type name, such as Sub.name but it can also be invoked by using Sub reference variable. Hence, sub.name at Line n3 correctly points to the name variable at Line n1.\n\nFor invoking static fields, object is not needed, therefore even if sub refers to null, sub.name doesn't throw NullPoionterException.\n\nTest class compiles successfully and on execution prints SUPER on to the console."},{"id":26,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 4 java files:\n\n//I1.java\npackage com.udayankhattry.oca;\n \npublic interface I1 {\n    int i = 10;\n}\n\n\n//I2.java\npackage com.udayankhattry.oca;\n \npublic interface I2 {\n    int i = 20;\n}\n\n\n//I3.java\npackage com.udayankhattry.oca;\n \npublic interface I3 extends I1, I2 { //Line n1\n \n}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(I1.i); //Line n2\n        System.out.println(I2.i); //Line n3\n        System.out.println(I3.i); //Line n4\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"D","answers":{"A":"Line n1 causes compilation error\n","B":"Line n2 causes compilation error\n","C":"Line n3 causes compilation error\n","D":"Line n4 causes compilation error\n","E":"There is no compilation error\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Variable 'i' declared inside interface I1 is implicitly public, static and final and similarly variable i declared inside interface I2 is implicitly public, static and final as well.\n\nIn Java a class can extend from only one class but an interface can extend from multiple interfaces. static variables are not inherited and hence there is no issue with Line n1.\n\n\n\nI1.i points to variable 'i' of interface I1.\n\nI2.i points to variable 'i' of interface I2.\n\nI3.i is an ambiguous call as compiler is not sure whether to point to I1.i or I2.i and therefore, Line n4 causes compilation error."},{"id":27,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 2 java files:\n\n//Counter.java\npackage com.udayankhattry.oca;\n \npublic interface Counter {\n    int count = 10; //Line n1\n}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Counter [] arr = new Counter[2]; //Line n2\n        for(Counter ctr : arr) {\n            System.out.print(ctr.count); //Line n3\n        }\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"F","answers":{"A":"Only Line n1 causes compilation error\n","B":"Only Line n2 causes compilation error\n","C":"Line n1 and Line n2 cause compilation error\n","D":"Only Line n3 causes compilation error\n","E":"Line n3 throws an exception at runtime\n","F":"Test class compiles successfully and on execution prints 1010 on to the console\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Variable 'count' declared inside interface Counter is implicitly public, static and final. Line n1 compiles successfully.\n\nLine n2 creates one dimensional array of 2 elements of Counter type and both the elements are initialized to null. Line n2 compiles successfully.\n\nThough correct way to refer static variable is by using the type name, such as Counter.count but it can also be invoked by using Counter reference variable. Hence ctr.count at Line n3 correctly points to the count variable at Line n1.\n\nFor invoking static fields, object is not needed, therefore even if 'ctr' refers to null, ctr.count doesn't throw NullPoionterException. Given loop executes twice and therefore output is: 1010"},{"id":28,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 2 java files:\n\n//GetSetGo.java\npackage com.udayankhattry.oca;\n \npublic interface GetSetGo {\n    int count = 1; //Line n1\n}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        GetSetGo [] arr = new GetSetGo[5]; //Line n2\n        for(GetSetGo obj : arr) {\n            obj.count++; //Line n3\n        }\n        System.out.println(GetSetGo.count); //Line n4\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"C","answers":{"A":"Line n1 causes compilation error\n","B":"Line n2 causes compilation error\n","C":"Line n3 causes compilation error\n","D":"Line n4 causes compilation error\n","E":"Test class compiles successfully and on execution prints 5 on to the console\n","F":"Test class compiles successfully and on execution prints 6 on to the console\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Variable 'count' declared inside interface GetSetGo is implicitly public, static and final. Line n1 compiles successfully.\n\nLine n2 creates one dimensional array of 5 elements of GetSetGo type and all 5 elements are initialized to null. Line n2 compiles successfully.\n\nThough correct way to refer static variable is by using the type name, such as GetSetGo.count but it can also be invoked by using GetSetGo reference variable. Hence, obj.count at Line n3 correctly points to the count variable at Line n1. But as variable 'count' is implicitly final, therefore obj.count++ causes compilation error. Line n3 fails to compile.\n\nLine n4 compiles successfully as variable 'count' is implicitly static and GetSetGo.count is the correct syntax to point to 'count' variable of interface GetSetGo."},{"id":29,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 3 java files:\n\n//Shrinkable.java\npackage com.udayankhattry.oca;\n \npublic interface Shrinkable {\n    public static void shrinkPercentage() {\n        System.out.println(\"80%\");\n    }\n}\n\n\n//AntMan.java\npackage com.udayankhattry.oca;\n \npublic class AntMan implements Shrinkable { }\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        AntMan.shrinkPercentage();\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"C","answers":{"A":"There is a compilation error in Shrinkable.java file\n","B":"There is a compilation error in AntMan.java file\n","C":"There is a compilation error in Test.java file\n","D":"There is no compilation error and on execution, Test class prints 80% on to the console\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"As per Java 8, default and static methods were added in the interface. There is no issue in Shrinkable.java file.\n\nclass AntMan implements Shrinkable interface but as there is no abstract method in Shrinkable interface, hence AntMan class is not needed to implement any method. AntMan.java file compiles successfully.\n\nstatic method of Shrinkable interface can only be accessed by using Shrinkable.shrinkPercentage(). `AntMan.shrinkPercentage();` causes compilation error."},{"id":30,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 3 java files:\n\n//Buyable.java\npackage com.udayankhattry.oca;\n \npublic interface Buyable {\n    int salePercentage = 85;\n \n    public static String salePercentage() {\n        return salePercentage + \"%\";\n    }\n}\n\n\n//Book.java\npackage com.udayankhattry.oca;\n \npublic class Book implements Buyable {}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Buyable [] arr = new Buyable[2];\n        for(Buyable b : arr) {\n            System.out.println(b.salePercentage); //Line n1\n            System.out.println(b.salePercentage()); //Line n2\n        }\n        \n        Book [] books = new Book[2];\n        for(Book b : books) {\n            System.out.println(b.salePercentage); //Line n3\n            System.out.println(b.salePercentage()); //Line n4\n        }\n    }\n}\n\n\nWhich of the following statements are correct?\n\nSelect 2 options.","type":"Multiple Choice","answer":"D,F","answers":{"A":"There is a compilation error in Buyable.java file\n","B":"There is a compilation error in Book.java file\n","C":"There is a compilation error at Line n1\n","D":"There is a compilation error at Line n2\n","E":"There is a compilation error at Line n3\n","F":"There is a compilation error at Line n4\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Variable 'salePercentage' declared inside interface Buyable is implicitly public, static and final. As per Java 8, default and static methods were added in the interface. There is no compilation error in Buyable.java file.\n\nclass Book implements Buyable interface but as there is no abstract method in Buyable interface, hence Book class is not needed to implement any method. Book.java file compiles successfully.\n\n\n\n`Buyable [] arr = new Buyable[2];` creates one dimensional array of 2 elements of Buyable type and both the elements are initialized to null.\n\n\n\nThere are some difference in which static variables and static methods of the interface are accessed.\n\nCorrect and only way to access static method of an Interface is by using the name of the interface, such as Buyable.salePercentage(). Line n2 and Line n4 cause compilation error.\n\n\n\nAs far as public static final variable of interface is concerned, even through the correct way to access static variable is by using the name of the interface, such as Buyable.salePercentage but it can also be accessed by using following:\n\nReference variable of the interface: Buyable obj1 = null; System.out.println(obj1.salePercentage);\n\nName of the implementer class: System.out.println(Book.salePercentage);\n\nReference variable of the implementer class: Book obj2 = null; System.out.println(obj2.salePercentage);\n\nHence, Line n1 and Line n3 compile successfully."},{"id":31,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface Profitable {\n    double profitPercentage = 42.0;\n}\n \nclass Business implements Profitable {\n    double profitPercentage = 50.0; //Line n1\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Profitable obj = new Business(); //Line n2\n        System.out.println(obj.profitPercentage); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Line n1 causes compilation error\n","B":"Line n2 causes compilation error\n","C":"Line n3 causes compilation error\n","D":"Test class compiles successfully and on execution prints 42.0 on to the console\n","E":"Test class compiles successfully and on execution prints 50.0 on to the console\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"'profitPercentage' variable of Profitable interface is implicitly public, static and final.\n\nLine n1 defines the instance variable 'profitPercentage' of Business class. There is no error at Line n1.\n\nSuper type reference variable can refer to an instance of Sub type, therefore no issues at Line n2 as well.\n\n\n\nEven though correct syntax for accessing interface variable is by using Interface name, such as Profitable.profitPercentage but reference variable also works. obj.profitPercentage doesn't cause any compilation error.\n\nAs, obj is of Profitable type, hence obj.profitPercentage points to the 'profitPercentage' variable of Profitable type. Given code compiles successfully and on execution prints 42.0 on to the console."},{"id":32,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface I1 {\n    public static void print(String str) {\n        System.out.println(\"I1:\" + str.toUpperCase());\n    }\n}\n \nclass C1 implements I1 {\n    void print(String str) {\n        System.out.println(\"C1:\" + str.toLowerCase());\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        I1 obj = new C1();\n        obj.print(\"Java\");\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"B","answers":{"A":"Class C1 causes compilation error\n","B":"Class Test causes compilation error\n","C":"Interface I1 causes compilation error\n","D":"Given code compiles successfully and on execution prints I1:JAVA on to the console\n","E":"Given code compiles successfully and on execution prints C1:java on to the console\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"As per Java 8, default and static methods were added in the interface. Interface I1 defines static method print(String), there is no compilation error in interface I1.\n\nAlso the scope of print(String) method of I1 is limited to interface I1 and it can be invoked by using Interface name only, I1.print(\"\").\n\n\n\nclass C1 implements I1 and it also defines print(String) instance method. Even though class C1 implements I1, it doesn't have static print(String) method in its scope, therefore class C1 compiles successfully.\n\n\n\nSuper type reference variable can refer to an instance of Sub type, therefore the statement `I1 obj = new C1();` compiles successfully.\n\nobj is of I1 type, hence `obj.print(\"Java\");` tries to tag the static method of I1 but static print(String) method of I1 can only be invoked by using I1.print(\"Java\");.\n\nTherefore, `obj.print(\"Java\");` causes compilation error."},{"id":33,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 3 java files:\n\n//Profitable1.java\npackage com.udayankhattry.oca;\n \npublic interface Profitable1 {\n    default double profit() {\n        return 12.5;\n    }\n}\n\n\n//Profitable2.java\npackage com.udayankhattry.oca;\n \npublic interface Profitable2 {\n    default double profit() {\n        return 25.5;\n    }\n}\n\n\n//Profit.java\npackage com.udayankhattry.oca;\n \npublic abstract class Profit implements Profitable1, Profitable2 {\n    /*INSERT*/\n}\n\n\nWhich of the following needs to be done so that there is no compilation error?","type":"Single Choice","answer":"F","answers":{"A":"No need for any modifications, code compiles as is\n","B":"Replace /*INSERT*/ with below code:\ndouble profit() {\n    return 50.0;\n}\n","C":"Replace /*INSERT*/ with below code:\npublic default double profit() {\n    return 50.0;\n}\n","D":"Replace /*INSERT*/ with below code:\nprotected double profit() {\n    return 50.0;\n}\n","E":"Replace /*INSERT*/ with below code:\npublic double profit() {\n    return Profitable1.profit();\n}\n","F":"Replace /*INSERT*/ with below code:\npublic double profit() {\n    return Profitable2.super.profit();\n}\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Profit class causes compilation error as it complains about duplicate default methods: Profitable1.profit() and Profitable2.profit(). To rectify this error abstract class Profit must override the profit() method.\n\n\n\ndefault keyword for method is allowed only inside the interface and default methods are implicitly public. So overriding method should use public modifier and shouldn't use default keyword.\n\nIf you want to invoke the default method implementation from the overriding method, then the correct syntax is: [Interface_name].super.[default_method_name].\n\nHence, `Profitable1.super.profit();` will invoke the default method of Profitable1 interface and `Profitable2.super.profit();` will invoke the default method of Profitable2 interface.\n\n\n\nBased on above points, let's check all the options one by one:\n\nNo need for any modifications, code compiles as is: ✗\n\n\n\nReplace /*INSERT*/ with below code:\n\ndouble profit() {\n\n    return 50.0;\n\n}: ✗\n\nprofit() method must be declared with public access modifier.\n\n\n\nReplace /*INSERT*/ with below code:\n\npublic default double profit() {\n\n    return 50.0;\n\n}: ✗\n\ndefault keyword for method is allowed only inside the interface.\n\n\n\nReplace /*INSERT*/ with below code:\n\nprotected double profit() {\n\n    return 50.0;\n\n}: ✗\n\nprofit() method must be declared with public access modifier.\n\n\n\nReplace /*INSERT*/ with below code:\n\npublic double profit() {\n\n    return Profitable1.profit();\n\n}: ✗\n\nProfitable1.profit(); causes compilation error as correct syntax is: Profitable1.super.profit();\n\n\n\nReplace /*INSERT*/ with below code:\n\npublic double profit() {\n\n    return Profitable2.super.profit();\n\n}: ✓\n\nIt compiles successfully."},{"id":34,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface Perishable1 {\n    default int maxDays() {\n        return 1;\n    }\n}\n \ninterface Perishable2 extends Perishable1 {\n    default int maxDays() {\n        return 2;\n    }\n}\n \nclass Milk implements Perishable2, Perishable1 {}\n \npublic class Test {\n    public static void main(String[] args) {\n        Perishable1 obj = new Milk();\n        System.out.println(obj.maxDays());\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"E","answers":{"A":"Interface Perishable2 causes compilation error\n","B":"Class Milk causes compilation error\n","C":"Class Test causes compilation error\n","D":"Given code compiles successfully and on execution Test class prints 1 on to the console\n","E":"Given code compiles successfully and on execution Test class prints 2 on to the console\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"As per Java 8, default methods were added in the interface. Interface Perishable1 defines default method maxDays(), there is no compilation error in interface Perishable1. Method maxDays() is implicitly public in Perishable1.\n\n\n\ninterface Perishable2 extends Perishable1 and it overrides the default method maxDays() of Document, overriding method in Perishable2 is implicitly public. Interface Perishable2 compiles successfully.\n\n\n\nClass Milk implements Perishable2 and Perishable1. Although it is redundant for Milk class to implement Preishable1 as Perishable2 already extends Perishable1.\n\nThere is no conflict in Milk class as it inherits the default method maxDays() of Perishable2 interface. Milk class compiles successfully.\n\n\n\n`Perishable1 obj = new Milk();` It compiles fine as Perishable1 is supertype and Milk is subtype.\n\n`obj.maxDays()` executes the default maxDays() method of Perishable2 interface and it returns 2. `System.out.println(obj.maxDays());` prints 2 on to the console."},{"id":35,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below codes of 4 java files:\n\n//Moveable.java\npackage com.udayankhattry.oca;\n \npublic interface Moveable {\n    void move();\n}\n\n\n//Animal.java\npackage com.udayankhattry.oca;\n \npublic abstract class Animal {\n    void move() {\n        System.out.println(\"ANIMAL MOVING\");\n    }\n}\n\n\n//Dog.java\npackage com.udayankhattry.oca;\n \npublic class Dog extends Animal implements Moveable {}\n\n\n//Test.java\npackage com.udayankhattry.oca;\n \npublic class Test {\n    public static void main(String[] args) {\n        Moveable moveable = new Dog();\n        moveable.move();\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"B","answers":{"A":"There is a compilation error in Animal.java file\n","B":"There is a compilation error in Dog.java file\n","C":"There is a compilation error in Test.java file\n","D":"There is no compilation error and on execution, Test class prints ANIMAL MOVING on to the console\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Method move() declared in Moveable interface is implicitly public and abstract.\n\nAbstract class Animal has non-abstract method move() and it is declared with no modifier (package scope). Abstract class in java can have 0 or more abstract methods. Hence Animal class compiles successfully.\n\nclass Dog extends Animal and as both the classes Animal and Dog are within the same package 'com.udayankhattry.oca', Dog inherits the move() method defined in Animal class.\n\nDog class implements Moveable interface as well, therefore it must implement public move() method as well. But as inherited move() method from Animal class is not public, therefore Dog class fails to compile."},{"id":36,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface M {\n    public static void log() {\n        System.out.println(\"M\");\n    }\n}\n \nabstract class A {\n    public static void log() { \n        System.out.println(\"N\");\n    }\n}\n \nclass MyClass extends A implements M {}\n \npublic class Test {\n    public static void main(String[] args) {\n        M obj1 = new MyClass();\n        obj1.log(); //Line n1\n        \n        A obj2 = new MyClass();\n        obj2.log(); //Line n2\n        \n        MyClass obj3 = new MyClass();\n        obj3.log(); //Line n3\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"C","answers":{"A":"There is a compilation error in interface M\n","B":"There is a compilation error in class A\n","C":"Line n1 causes compilation error\n","D":"Line n2 causes compilation error\n","E":"Line n3 causes compilation error\n","F":"Given code compiles successfully\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"As per Java 8, default and static methods were added in the interface. Interface M defines static method log(), there is no compilation error in interface M.\n\nAlso the scope of static log() method of M is limited to interface M and it can be invoked by using Interface name only, M.log().\n\n\n\nAbstract class A also defines the static log() method. Abstract class can have 0 or more abstract methods. Hence, no compilation error in class A as well.\n\n\n\nSuper type reference variable can refer to an instance of Sub type, therefore the statement `M obj1 = new MyClass();` compiles successfully.\n\nobj1 is of M type, hence `obj1.log();` tries to tag the static method of M but static log() method of M can only be invoked by using M.log();.\n\nTherefore, Line n1 causes compilation error.\n\n\n\nScope of static log() method of A is not limited to class A only but MyClass also gets A.log() method in its scope.\n\nThere are different ways in which static method of an abstract class can be accessed:\n\n1. By using the name of the abstract class: A.log(); //Preferred way\n\n2. By using the reference variable of abstract class: A o1 = null; o1.log();\n\n3. By using the name of the subclass: MyClass.log();\n\n4. By using the reference variable of the subclass: MyClass o2 = null; o2.log();\n\nHence, Line n2 and Line n3 compile successfully."},{"id":37,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code snippet:\n\ninterface ILog {\n    default void log() {\n        System.out.println(\"ILog\");\n    }\n}\n \nabstract class Log {\n    public static void log() { \n        System.out.println(\"Log\");\n    }\n}\n \nclass MyLogger extends Log implements ILog {}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"D","answers":{"A":"There is no compilation error in the above code\n","B":"There is a compilation error in interface ILog\n","C":"There is a compilation error in abstract class Log\n","D":"There is a compilation error in MyLogger class\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"As per Java 8, default and static methods were added in the interface. Interface ILog defines default method log(), there is no compilation error in interface ILog.\n\n\n\nAbstract class Log defines the static log() method. Abstract class can have 0 or more abstract methods. Hence, no compilation error in class Log as well.\n\n\n\nDefault methods of an interface are implicitly public and are inherited by the implementer class. Class MyLogger implements ILog interface and therefore it inherits the default log() method of ILog interface.\n\nAlso, the scope of static log() method of abstract class Log is not limited to class Log only but MyLogger also gets Log.log() method in its scope.\n\nSo, MyLogger class has instance method log() [inherited from ILog interface] and static method log() [from Log class] and this causes conflict. Static and non-static methods with same signature are not allowed in one scope, therefore class MyLogger fails to compile."},{"id":38,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface Rideable {\n    void ride(String name);\n}\n \nclass Animal {}\n \nclass Horse extends Animal implements Rideable {\n    public void ride(String name) {\n        System.out.println(name.toUpperCase() + \" IS RIDING THE HORSE\");\n    }\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Animal horse = new Horse();\n        /*INSERT*/\n    }\n}\n\n\nWhich of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print EMMA IS RIDING THE HORSE on to the console?\n\nSelect 4 options.","type":"Multiple Choice","answer":"C,E,H,I","answers":{"A":"horse.ride(\"EMMA\");\n","B":"(Horse)horse.ride(\"EMMA\");\n","C":"((Horse)horse).ride(\"Emma\");\n","D":"(Rideable)horse.ride(\"emma\");\n","E":"((Rideable)horse).ride(\"emma\");\n","F":"(Rideable)(Horse)horse.ride(\"EMMA\");\n","G":"(Horse)(Rideable)horse.ride(\"EMMA\");\n","H":"((Rideable)(Horse)horse).ride(\"EMMA\");\n","I":"((Horse)(Rideable)horse).ride(\"emma\");\n","J":"\n"},"explanation":"Let's check all the options one by one:\n\nhorse.ride(\"EMMA\"); ✗ Variable 'horse' is of Animal type and ride(String) method is not defined in Animal class, therefore it causes compilation error.\n\n\n\n(Horse)horse.ride(\"EMMA\"); ✗ horse.ride(\"EMMA\") will be evaluated first as dot (.) operator has higher precedence than cast. horse.ride(\"EMMA\") returns void, hence it cannot be casted to Horse type. This would cause compilation error.\n\n\n\n((Horse)horse).ride(\"Emma\"); ✓ Variable 'horse' refers to an instance of Horse type and variable 'horse' is casted to Horse type. Horse class has ride(String) method, hence no compilation error. ride(String) method of Horse class will get invoked at runtime and will print the expected output. As, name.toUpperCase() method is invoked, hence it doesn't matter in what case you pass the name, in the output name will always be displayed in the upper case.\n\n\n\n(Rideable)horse.ride(\"emma\"); ✗ horse.ride(\"EMMA\") will be evaluated first as dot (.) operator has higher precedence than cast. horse.ride(\"EMMA\") returns void, hence it cannot be casted to Rideable type. This would cause compilation error.\n\n\n\n((Rideable)horse).ride(\"emma\"); ✓ Variable 'horse' refers to an instance of Horse type and variable 'horse' is casted to Rideable type (super type of Horse). Rideable interface has ride(String) method, hence no compilation error. ride(String) method of Horse class will get invoked at runtime and will print the expected output.\n\n\n\n(Rideable)(Horse)horse.ride(\"EMMA\"); ✗ horse.ride(\"EMMA\") will be evaluated first as dot (.) operator has higher precedence than cast. horse.ride(\"EMMA\") returns void, hence it cannot be casted to Horse type. This would cause compilation error.\n\n\n\n(Horse)(Rideable)horse.ride(\"EMMA\"); ✗ horse.ride(\"EMMA\") will be evaluated first as dot (.) operator has higher precedence than cast. horse.ride(\"EMMA\") returns void, hence it cannot be casted to Rideable type. This would cause compilation error.\n\n\n\n((Rideable)(Horse)horse).ride(\"EMMA\"); ✓ Variable 'horse' refers to an instance of Horse type, it is first casted to Horse type and then casted to Rideable type. Rideable interface has ride(String) method, hence no compilation error. ride(String) method of Horse class will get invoked at runtime and will print the expected output.\n\n\n\n((Horse)(Rideable)horse).ride(\"emma\"); ✓ Variable 'horse' refers to an instance of Horse type, it is first casted to Rideable type and then casted to Horse type. Horse class has ride(String) method, hence no compilation error. ride(String) method of Horse class will get invoked at runtime and will print the expected output."},{"id":39,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface X1 {\n    default void print() {\n        System.out.println(\"X1\");\n    }\n}\n \ninterface X2 extends X1 {\n    void print();\n}\n \ninterface X3 extends X2 {\n    default void print() {\n        System.out.println(\"X3\");\n    }\n}\n \nclass X implements X3 {}\n \npublic class Test {\n    public static void main(String[] args) {\n        X1 obj = new X();\n        obj.print();\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"G","answers":{"A":"interface X1 fails to compile\n","B":"interface X2 fails to compile\n","C":"interface X3 fails to compile\n","D":"class X fails to compile\n","E":"class Test fails to compile\n","F":"class Test compiles successfully and on execution prints X1 on to the console\n","G":"class Test compiles successfully and on execution prints X3 on to the console\n","H":"\n","I":"\n","J":"\n"},"explanation":"As per Java 8, default methods were added in the interface. Interface X1 defines default method print(), there is no compilation error in interface X1. Method print() is implicitly public in X1.\n\n\n\ninterface X2 extends X1 and it overrides the default method print() of X1, overriding method in X2 is implicitly abstract and public. An interface in java can override the default method of super type with abstract modifier. interface X2 compiles successfully.\n\n\n\ninterface X3 extends X2 and it implements the abstract method print() of X2, overriding method in X3 is default and implicitly public. An interface in java can implement the abstract method of super type with default modifier. interface X3 compiles successfully.\n\n\n\nclass X implements X3 and therefore it inherits the default method print() defined in interface X3.\n\n\n\n`X1 obj = new X();` compiles successfully as X1 is of super type (X implements X3, X3 extends X2 and X2 extends X1).\n\n`obj.print();` invokes the default method print() defined in interface X3 and hence X3 is printed on to the console."},{"id":40,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file:\n\npackage com.udayankhattry.oca;\n \ninterface Document {\n    default String getType() {\n        return \"TEXT\";\n    }\n}\n \ninterface WordDocument extends Document {\n    String getType();\n}\n \nclass Word implements WordDocument {}\n \npublic class Test {\n    public static void main(String[] args) {\n        Document doc = new Word(); //Line n1\n        System.out.println(doc.getType()); //Line n2\n    }\n}\n\n\nWhich of the following statements is correct?","type":"Single Choice","answer":"C","answers":{"A":"Interface Document causes compilation error\n","B":"Interface WordDocument causes compilation error\n","C":"Class Word causes compilation error\n","D":"Test class compiles successfully and on execution prints TEXT on to the console\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"As per Java 8, default methods were added in the interface. Interface Document defines default method getType(), there is no compilation error in interface Document. Method getType() is implicitly public in Document.\n\n\n\ninterface WordDocument extends Document and it overrides the default method getType() of Document, overriding method in WordDocument is implicitly abstract and public. An interface in java can override the default method of super type with abstract modifier. interface WordDocument compiles successfully.\n\n\n\nclass Word implements WordDocument and as WordDocument interface has abstract method getType(), and as class Word doesn't implement the getType() method hence it causes compilation failure."},{"id":41,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code snippet:\n\ninterface Workable {\n    void work();\n}\n \n/*INSERT*/ {\n    public void work() {} //Line n1\n}\n\n\nAnd the statements:\n\n1. abstract class Work implements Workable\n\n2. class Work implements Workable\n\n3. interface Work extends Workable\n\n4. abstract interface Work extends Workable\n\n5. abstract class Work\n\n\n\nHow many statements can replace /*INSERT*/ such that there is no compilation error?","type":"Single Choice","answer":"C","answers":{"A":"One statement\n","B":"Two statements\n","C":"Three statements\n","D":"Four statements\n","E":"Five statements\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"/*INSERT*/ cannot be replaced with interface as work() method at Line n1 is neither abstract nor default. Hence, statements 3 and 4 will not work.\n\nLet's check other statements:\n\n1. abstract class Work implements Workable: abstract class in java can have 0 or more abstract methods. It compiles successfully.\n\n2. class Work implements Workable: It correctly implements the work() method of Workable interface, hence it compiles successfully.\n\n5. abstract class Work: abstract class in java can have 0 or more abstract methods. It compiles successfully.\n\n\n\nHence, out of 5 statements, 3 will compile successfully."},{"id":42,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"2018-1-01\");\n        System.out.println(date);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"2018-01-01\n","B":"2018-1-1\n","C":"2018-1-01\n","D":"An exception is thrown at runtime\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"LocalDate.parse(CharSequence) method accepts String in \"9999-99-99\" format only. Single digit month and day value are padded with 0 to convert it to 2 digits. \n\nTo represent 9th June 2018, format String must be \"2018-06-09\". If correct format string is not passed then an instance of java.time.format.DateTimeParseException is thrown."},{"id":43,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2020, 9, 31);\n        System.out.println(date);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"Compilation error\n","B":"An exception is thrown at runtime\n","C":"2020-10-01\n","D":"2020-09-30\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"LocalDate.of(...) method first validates year, then month and finally day of the month. \n\nSeptember can't have 31 days so LocalDate.of(...) method throws an instance of java.time.DateTimeException class."},{"id":44,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2020, 9, 6);\n        System.out.println(date);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"2020-9-6\n","B":"2020-09-06\n","C":"2020-6-9\n","D":"2020-06-09\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"In LocalDate.of(int, int, int) method, 1st parameter is year, 2nd is month and 3rd is day of the month. \n\ntoString() method of LocalDate class prints the LocalDate object in ISO-8601 format: \"uuuu-MM-dd\"."},{"id":45,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2068, 4, 15);\n        System.out.println(date.getMonth() + \":\" + date.getMonthValue());\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"APRIL:3\n","B":"APRIL:4\n","C":"April:3\n","D":"April:4\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"date.getMonth() returns the month of the year filed, using Month enum, all the enum constant names are in upper case. \n\n\n\ndate.getMonthValue() returns the value of the month. \n\n\n\nNOTE: month value starts with 1 and it is different from java.util.Date API, where month value starts with 0."},{"id":46,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate newYear = LocalDate.of(2018, 1, 1);\n        LocalDate christmas = LocalDate.of(2018, 12, 25);\n        boolean flag1 = newYear.isAfter(christmas);\n        boolean flag2 = newYear.isBefore(christmas);\n        System.out.println(flag1 + \":\" + flag2);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"false:true\n","B":"true:false\n","C":"An exception is thrown at runtime\n","D":"Compilation error\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"isAfter and isBefore method can be interpreted as:\n\nDoes 1st Jan 2018 come after 25th Dec 2018? No, false. \n\nDoes 1st Jan 2018 come before 25th Dec 2018? Yes, true."},{"id":47,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate newYear = LocalDate.of(2018, 1, 1);\n        LocalDate eventDate = LocalDate.of(2018, 1, 1);\n        boolean flag1 = newYear.isAfter(eventDate);\n        boolean flag2 = newYear.isBefore(eventDate);\n        System.out.println(flag1 + \":\" + flag2);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"false:false\n","B":"true:true\n","C":"false:true\n","D":"false:true\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"isAfter and isBefore method can be interpreted as:\n\nDoes 1st Jan 2018 come after 1st Jan 2018? No, false. \n\nDoes 1st Jan 2018 come before 1st Jan 2018? No, false."},{"id":48,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"2018-06-06\");\n        date.minusDays(10);\n        System.out.println(date);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"2018-05-26\n","B":"2018-05-27\n","C":"2018-06-26\n","D":"2018-06-25\n","E":"2018-06-06\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"date --> {2018-06-06},\n\ndate.minusDays(10); => as LocalDate is immutable, hence a new LocalDate object is created {2018-05-27} but no variable refers to it. date still refers to {2018-06-06}.\n\n2018-06-06 is displayed on to the console."},{"id":49,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date1 = LocalDate.parse(\"1980-03-16\");\n        LocalDate date2 = LocalDate.parse(\"1980-03-16\");\n        System.out.println(date1.equals(date2) + \" : \" + date1.isEqual(date2));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"true : false\n","B":"true : true\n","C":"false : true\n","D":"false : false\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Both the methods \"public boolean isEqual(ChronoLocalDate)\" and \"public boolean equals(Object)\" return true if date objects are equal otherwise false. \n\nNOTE: LocalDate implements ChronoLocalDate."},{"id":50,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \nclass MyLocalDate extends LocalDate {\n    @Override\n    public String toString() {\n        return super.getDayOfMonth() + \"-\" \n                + super.getMonthValue() + \"-\" +  super.getYear();\n    }\n}\n \npublic class Test {\n    public static void main(String [] args) {\n        MyLocalDate date = LocalDate.parse(\"1980-03-16\");\n        System.out.println(date);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"1980-03-16\n","B":"16-03-1980\n","C":"16-3-1980\n","D":"An exception is thrown at runtime\n","E":"Compilation error\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"LocalDate is a final class so cannot be extended."},{"id":51,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"1980-03-16\");\n        System.out.println(date.minusYears(-5));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"B","answers":{"A":"1975-03-16\n","B":"1975-03-16\n","C":"Compilation error\n","D":"Runtime exception\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"minusYears, minusMonths, minusWeeks, minusDays methods accept long parameter so you can pass either positive or negative value.\n\nIf positive value is passed, then that specified value is subtracted and if negative value is passed, then that specified value is added.\n\nI think you still remember: minus minus is plus. \n\n\n\nSimilarly plusYears, plusMonths, plusWeeks, plusDays methods work in the same manner. IF positive value is passed, then that specified value is added and if negative value is passed, then that specified value is subtracted."},{"id":52,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate joiningDate = LocalDate.parse(\"2006-03-16\");\n        System.out.println(joiningDate.withDayOfYear(29));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"2006-03-29\n","B":"2006-01-01\n","C":"2006-01-29\n","D":"None of the other options\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"joiningDate --> {2006-03-16}. \n\njoiningDate.withDayOfYear(29) returns a new LocalDate object with the day of the Year altered.\n\nA year has 365 days, so 29 means 29th day of the year, which is 29th Jan 2006.\n\n\n\nNOTE: There are other with methods, you should know for the exam. withDayOfMonth(int), withMonth(int) and withYear(int)."},{"id":53,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalTime;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalTime time = LocalTime.of(23, 60);\n        System.out.println(time);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"23:60\n","B":"00:00\n","C":"00:01\n","D":"Compilation error\n","E":"An exception is thrown at runtime\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"LocalTime.of(int hour, int minute) creates an instance of LocalTime class. Valid value for hour is: 0 to 23 and valid value for minute is 0 to 59. \n\n\n\njava.time.DateTimeException is thrown if invalid values are passed as arguments. \n\n\n\nNOTE: There are other overloaded of methods available:\n\nLocalTime of(int hour, int minute, int second) and\n\nLocalTime of(int hour, int minute, int second, int nanoOfSecond).\n\n\n\nValid value for second is: 0 to 59 and valid value for nano second is: 0 to 999,999,999."},{"id":54,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Period;\nimport java.time.format.DateTimeFormatter;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2012, 1, 11);\n        Period period = Period.ofMonths(2);\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"MM-dd-yy\");\n        System.out.print(formatter.format(date.minus(period)));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"11-11-12\n","B":"01-11-11\n","C":"01-11-12\n","D":"11-11-11\n","E":"Runtime exception\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"date --> {2012-01-11}, period --> {P2M},\n\ndate.minus(period) --> {2011-11-11} [subtract 2 months period from {2012-01-11}, month is changed to 11 and year is changed to 2011].\n\n\n\nformatter -> {MM-dd-yy}, when date {2011-11-11} is formatted in this format 11-11-11 is printed on to the console."},{"id":55,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Period;\nimport java.time.format.DateTimeFormatter;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2012, 1, 11);\n        Period period = Period.ofMonths(2);\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"mm-dd-yy\");\n        System.out.print(formatter.format(date.minus(period)));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"11-11-12\n","B":"01-11-11\n","C":"01-11-11\n","D":"11-11-11\n","E":"Runtime exception\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"While working with dates, programmers get confused with M & m and D & d. \n\nEasy way to remember is that Bigger(Upper case) letters represent something bigger. M represents month & m represents minute, D represents day of the year & d represents day of the month. \n\n\n\nLocalDate's object doesn't have time component, mm represents minute and not months so at runtime format method throws exception."},{"id":56,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Period;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate obj = new LocalDate(2020, 2, 14);\n        System.out.println(obj.minus(Period.ofDays(10)));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"2020-02-04\n","B":"2020-02-03\n","C":"Compilation error\n","D":"Runtime exception\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Constructor of LocalDate is declared private so cannot be called from outside, hence new LocalDate(2020, 2, 14); causes compilation failure. \n\nOverloaded static methods \"of\" and \"parse\" are provided to create the instance of LocalDate. \n\nLocalTime, LocalDateTime, Period also specify private constructors and provide \"of\" and \"parse\" methods to create respective instances."},{"id":57,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.Period;\n \npublic class Test {\n    public static void main(String [] args) {\n        Period period = Period.of(0, 1000, 0);\n        System.out.println(period);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"P0Y1000M0D\n","B":"p0y1000m0d\n","C":"P1000M\n","D":"p0y1000m0d\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Check the toString() method of Period class. ZERO period is displayed as P0D, other than that, Period components (year, month, day) with 0 values are ignored. \n\n\n\ntoString()'s result starts with P, and for non-zero year, Y is appended; for non-zero month, M is appended; and for non-zero day, D is appended. P,Y,M and D are in upper case. \n\n\n\nNOTE: Period.parse(CharSequence) method accepts the String parameter in \"PnYnMnD\" format, over here P,Y,M and D can be in any case."},{"id":58,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.Period;\n \npublic class Test {\n    public static void main(String [] args) {\n        Period period = Period.of(0, 0, 0);\n        System.out.println(period);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"P0Y0M0D\n","B":"p0y0m0d\n","C":"P0D\n","D":"p0d\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Period.of(0, 0, 0); is equivalent to Period.ZERO. ZERO period is displayed as P0D, other than that, Period components (year, month, day) with 0 values are ignored. \n\n\n\ntoString()'s result starts with P, and for non-zero year, Y is appended; for non-zero month, M is appended; and for non-zero day, D is appended. P,Y,M and D are in upper case. \n\n\n\nNOTE: Period.parse(CharSequence) method accepts the String parameter in \"PnYnMnD\" format, over here P,Y,M and D can be in any case."},{"id":59,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.Period;\n \npublic class Test {\n    public static void main(String [] args) {\n        Period period = Period.of(2, 1, 0).ofYears(10).ofMonths(5).ofDays(2);\n        System.out.println(period);\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"P12Y6M2D\n","B":"P2Y1M0D\n","C":"P2Y1M\n","D":"P2D\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"of and ofXXX methods are static methods and not instance methods.\n\nPeriod.of(2, 1, 0) => returns an instance of Period type.\n\nstatic methods can be invoked using class_name or using reference variable.\n\nIn this case ofYears(10) is invoked on period instance but compiler uses Period's instance to resolve the type, which is period. A new Period instance {P10Y} is created, after that another Period instance {P5M} is created and finally Period instance {P2D} is created. This instance is assigned to period reference variable and hence P2D is printed on to the console."},{"id":60,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"2000-06-25\");\n        while(date.getDayOfMonth() >= 20) {\n            System.out.println(date);\n            date.plusDays(-1);\n        }\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error\n","B":"An exception is thrown at runtime\n","C":"System.out.println(date);  is executed 6 times\n","D":"System.out.println(date);  is executed more than 6 times\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"date --> {2000-06-25}. date.getDayOfMonth() = 25, 25 >= 20 is true, hence control goes inside while loop and executes System.out.println(date); statement.\n\ndate.plusDays(-1); creates a new LocalDate object {2000-06-24} but date reference variable still refers to {2000-06-25}. date.getDayOfMonth() again returns 25, this is an infinite loop."},{"id":61,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate obj = LocalDate.now();\n        System.out.println(obj.getHour());\n    }\n}\nWhich of the following statement is correct?","type":"Single Choice","answer":"A","answers":{"A":"Code fails to compile\n","B":"Code compiles successfully but throws Runtime exception\n","C":"It will print any int value between 0 and 23\n","D":"It will print any int value between 1 and 24\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"LocalDate.now(); retrieves the current date from the system clock. There is no issue with this statement.\n\nobj is of LocalDate type and getHour() method is not defined in LocalDate class, it is defined in LocalTime and LocalDateTime class. Hence obj.getHour() causes compilation failure."},{"id":62,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDateTime;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDateTime obj = LocalDateTime.now();\n        System.out.println(obj.getSecond());\n    }\n}\nWhich of the following statement is correct?","type":"Single Choice","answer":"C","answers":{"A":"Code fails to compile\n","B":"Code fails to compile\n","C":"It will print any int value between 0 and 59\n","D":"It will print any int value between 1 and 60\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"LocalDateTime stores both date and time parts. LocalDateTime.now(); retrieves the current date and time from the system clock.\n\nobj.getSecond() can return any value between 0 and 59."},{"id":63,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate d1 = LocalDate.parse(\"1999-09-09\");\n        LocalDate d2 = LocalDate.parse(\"1999-09-09\");\n        LocalDate d3 = LocalDate.of(1999, 9, 9);\n        LocalDate d4 = LocalDate.of(1999, 9, 9);\n        System.out.println((d1 == d2) + \":\" + (d2 == d3) + \":\" + (d3 == d4));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"true:false:true\n","B":"false:false:true\n","C":"true:true:true\n","D":"false:false:false\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"\"parse\" and \"of\" methods create new instances, so in this case you get 4 different instances of LocalDate stored at 4 different memory addresses."},{"id":64,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(1987, 9, 1);\n        String str = date.format(DateTimeFormatter.ISO_DATE_TIME);\n        System.out.println(\"Date is: \" + str);\n    }\n}\n\n\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"E","answers":{"A":"Date is: 1987-09-01\n","B":"Date is: 1987-01-09\n","C":"Date is: 01-09-1987\n","D":"Given code executes successfully but output does not match with the given options\n","E":"Runtime exception\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"LocalDate object doesn't contain time part but ISO_DATE_TIME looks for time portion and throws exception at runtime.\n\nFor the OCA exam, you can check following DateTimeFormatter types: BASIC_ISO_DATE, ISO_DATE, ISO_LOCAL_DATE, ISO_TIME, ISO_LOCAL_TIME, ISO_DATE_TIME, ISO_LOCAL_DATE_TIME."},{"id":65,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date1 = LocalDate.parse(\"1947-08-15\", DateTimeFormatter.ISO_DATE);\n        LocalDate date2 = LocalDate.parse(\"1947-08-15\", DateTimeFormatter.ISO_LOCAL_DATE);\n        LocalDate date3 = LocalDate.of(1947, 8, 15);\n        \n        System.out.println(date1.equals(date2) + \" : \" + date2.equals(date3));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"A","answers":{"A":"true : true\n","B":"false : false\n","C":"true : false\n","D":"false : true\n","E":"Runtime exception\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"ISO_LOCAL_DATE formatter formats the date without the offset, such as \"1947-08-15\". \n\nISO_DATE formatter formats the date with offset (if available), such as \"1947-08-15\" or \"1947-08-15+05:30\", but remember LocalDate object doesn't contain any offset information. \n\nIn this case, all the three date instances are meaningfully equal. \n\n\n\nFor the OCA exam, you can check following DateTimeFormatter types: BASIC_ISO_DATE, ISO_DATE, ISO_LOCAL_DATE, ISO_TIME, ISO_LOCAL_TIME, ISO_DATE_TIME, ISO_LOCAL_DATE_TIME."},{"id":66,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Given code of Test.java file: \n\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.LocalTime;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"1947-08-14\");\n        LocalTime time = LocalTime.MAX;\n        System.out.println(date.atTime(time));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"1947-08-14T23:59:59\n","B":"1947-08-14T23:59:59.999\n","C":"1947-08-14T23:59:59.999999999\n","D":"1947-08-14T23:59:59.0\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"LocalTime.MIN --> {00:00},\n\nLocalTime.MAX --> {23:59:59.999999999},\n\nLocalTime.MIDNIGHT --> {00:00},\n\nLocalTime.NOON --> {12:00}. \n\n\n\ndate.atTime(LocalTime) method creates a LocalDateTime instance by combining date and time parts.\n\n\n\ntoString() method of LocalDateTime class prints the date and time parts separated by T in upper case."},{"id":67,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Period;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"2000-01-01\");\n        Period period = Period.ofYears(-3000);\n        System.out.println(date.plus(period));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"D","answers":{"A":"Compilation error\n","B":"Runtime exception\n","C":"1000-01-01\n","D":"-1000-01-01\n","E":"5000-01-01\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"The minimum supported LocalDate is: {-999999999-01-01} and maximum supported LocalDate is: {+999999999-12-31}.\n\nIf period of -3000 years is added to 1st Jan 2000, then result is 1st Jan -1000."},{"id":68,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code: \n\n//Test.java\npackage com.udayan.oca;\n \nimport java.time.LocalDate;\nimport java.time.Month;\nimport java.time.Period;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.of(2000, Month.JANUARY, 1);\n        Period period = Period.parse(\"p-30000y\");\n        System.out.println(date.plus(period));\n    }\n}\nWhat will be the result of compiling and executing Test class?","type":"Single Choice","answer":"C","answers":{"A":"Compilation error\n","B":"Runtime exception\n","C":"-28000-01-01\n","D":"32000-01-01\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"There are 2 of methods available in LocalDate class: of(int, int, int) and of(int, Month, int). Month can either be passed as int value (1 to 12) or enum constants Month.JANUARY to Month.DECEMBER.\n\n\n\nPeriod.parse(CharSequence) method accepts the String parameter in \"PnYnMnD\" format, over here P,Y,M and D can be in any case. \"p-30000y\" means Period of -30000 years. \n\n\n\nThe minimum supported LocalDate is: {-999999999-01-01} and maximum supported LocalDate is: {+999999999-12-31}. If period of -30000 years is added to 1st Jan 2000, then result is 1st Jan -28000."},{"id":69,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"DateTimeFormatter is defined inside which package?","type":"Single Choice","answer":"D","answers":{"A":"java.time\n","B":"java.util\n","C":"java.text\n","D":"java.time.format\n","E":"\n","F":"\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"DateTimeFormatter is a part of \"java.time.format\" package, whereas LocalDate, LocalTime, LocalDateTime and Period are defined inside \"java.time\" package."},{"id":70,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Which of the following will give you current system time? Select 2 options.","type":"Multiple Choice","answer":"D,F","answers":{"A":"System.out.println(new LocalDate()); \n","B":"System.out.println(LocalDate.now()); \n","C":"System.out.println(new LocalTime()); \n","D":"System.out.println(LocalTime.now()); \n","E":"System.out.println(new LocalDateTime()); \n","F":"System.out.println(LocalDateTime.now()); \n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"new LocalDate(), new LocalTime() and new LocalDateTime() give compilation error as constructor of these classes are declared private. \n\nSystem.out.println(LocalDate.now()); => Prints current date only. \n\nSystem.out.println(LocalTime.now()); => Prints current time only.\n\nSystem.out.println(LocalDateTime.now()); => Prints current date and time both."},{"id":71,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nclass Super {\n    public String num = \"10\"; //Line n1\n}\n \nclass Sub extends Super {\n    protected int num = 20; //Line n2\n}\n \npublic class Test {\n    public static void main(String[] args) {\n        Super obj = new Sub();\n        System.out.println(obj.num += 2); //Line n3\n    }\n}\n\n\nWhat will be the result of compiling and executing above code?","type":"Single Choice","answer":"E","answers":{"A":"Compilation error at Line n2\n","B":"Compilation error at Line n3\n","C":"It executes successfully and prints 12 on to the console\n","D":"It executes successfully and prints 22 on to the console\n","E":"It executes successfully and prints 102 on to the console\n","F":"It executes successfully and prints 202 on to the console\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"Subclass overrides the methods of superclass but it hides the variables of superclass.\n\n\n\nLine n2 hides the variable created at Line n1, there is no rules related to hiding (type and access modifier can be changed).\n\n\n\n'obj' is of Super type, hence obj.num refers to num variable at Line n1, which is of String type.\n\nExpression at Line n3:\n\nobj.num += 2\n\n=> obj.num = obj.num + 2\n\n=> obj.num = \"10\" + 2\n\n=> obj.num = \"102\"\n\n\n\nobj.num refers to \"102\" and same is printed on to the console."},{"id":72,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"1983-06-30\");\n        System.out.println(date.plusMonths(8));\n    }\n}\n\n\nWhat is the result?","type":"Single Choice","answer":"E","answers":{"A":"1983-02-30\n","B":"1983-02-29\n","C":"1983-02-28\n","D":"1984-02-30\n","E":"1984-02-29\n","F":"1984-02-28\n","G":"An exception is thrown at runtime\n","H":"\n","I":"\n","J":"\n"},"explanation":"plusMonths(long) method of LocalDate class returns a copy of this LocalDate with the specified number of months added.\n\nThis method adds the specified amount to the months field in three steps:\n\n    Add the input months to the month-of-year field\n\n    Check if the resulting date would be invalid\n\n    Adjust the day-of-month to the last valid day if necessary\n\n\n\nFor the given code,\n\n1983-06-30 plus 8 months would result in the invalid date 1984-02-30. Instead of returning an invalid result, the last valid day of the month, 1984-02-29, is returned.\n\nPlease note, 1984 is leap year and hence last day of February is 29 and not 28."},{"id":73,"trainingUnit":"OCA","trainingContent":"Inheritance and Polymorphism -2, Date and Time","question":"Consider below code of Test.java file:\n\npackage com.udayankhattry.oca;\n \nimport java.time.LocalDate;\n \npublic class Test {\n    public static void main(String [] args) {\n        LocalDate date = LocalDate.parse(\"2020-08-31\");\n        System.out.println(date.plusMonths(-6));\n    }\n}\n\n\nWhat is the result?","type":"Single Choice","answer":"C","answers":{"A":"2020-02-31\n","B":"2020-02-30\n","C":"2020-02-29\n","D":"2020-02-28\n","E":"An exception is thrown at runtime\n","F":"Compilation error\n","G":"\n","H":"\n","I":"\n","J":"\n"},"explanation":"plusMonths(long) method of LocalDate class returns a copy of this LocalDate with the specified number of months added. Negative argument will subtract the passed month(s), hence date.plusMonths(-6) doesn't cause any compilation error.\n\nThis method adds the specified amount to the months field in three steps:\n\n    Add the input months to the month-of-year field\n\n    Check if the resulting date would be invalid\n\n    Adjust the day-of-month to the last valid day if necessary\n\n\n\nFor the given code,\n\n2020-08-31 plus -6 months would subtract 6 months from the given date and would reslut in the invalid date 2020-02-31. Instead of returning an invalid result, the last valid day of the month, 2020-02-29, is returned.\n\nPlease note, 2020 is leap year and hence last day of February is 29 and not 28."}]